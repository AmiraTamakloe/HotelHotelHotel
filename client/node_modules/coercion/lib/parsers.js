var boolean, csv, date, dateRange, dateRangeRegex, dateRegex, integer, intersection, pagination, parseSort, positiveInteger,
  __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

parseSort = require('./sort');

intersection = function(a, b) {
  var value, _i, _len, _ref, _results;
  if (a.length > b.length) {
    _ref = [b, a], a = _ref[0], b = _ref[1];
  }
  _results = [];
  for (_i = 0, _len = a.length; _i < _len; _i++) {
    value = a[_i];
    if (__indexOf.call(b, value) >= 0) {
      _results.push(value);
    }
  }
  return _results;
};

csv = function(string, opt) {
  var all, allowed, fields, wildcard, _i, _len, _ref, _ref1;
  if (opt == null) {
    opt = {};
  }
  if (typeof string === 'number') {
    string = string.toString();
  }
  if (typeof string !== 'string') {
    return opt["default"] || [];
  }
  if ((_ref = opt.allowed) != null ? _ref.length : void 0) {
    all = string.split(',');
    allowed = opt.allowed.reduce(function(res, field) {
      var prefix;
      if (prefix = field.match(/(.*\.)\*$/)) {
        res.wildcards.push(prefix[1]);
      } else {
        res.fields.push(field);
      }
      return res;
    }, {
      fields: [],
      wildcards: []
    });
    fields = intersection(allowed.fields, all);
    _ref1 = allowed.wildcards;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      wildcard = _ref1[_i];
      fields = fields.concat(all.filter(function(val) {
        return val.indexOf(wildcard) === 0;
      }));
    }
  } else {
    fields = string.split(',');
  }
  if (fields != null ? fields.length : void 0) {
    return fields;
  }
  return opt["default"] || [];
};

boolean = function(value) {
  if (value === true || value === 'true' || value === 1 || value === '1' || value === 'yes') {
    return true;
  }
  return false;
};

integer = function(number, opt) {
  if (opt == null) {
    opt = {};
  }
  if (!(number = Math.round(number))) {
    return opt["default"] || 0;
  }
  if (opt.max != null) {
    number = Math.min(number, opt.max);
  }
  if (opt.min != null) {
    number = Math.max(number, opt.min);
  }
  return number;
};

positiveInteger = function(string, opt) {
  var int;
  if (opt == null) {
    opt = {};
  }
  int = integer(string, opt);
  if (int >= 0) {
    return int;
  }
  return opt["default"] || 0;
};

date = function(string) {
  if (/^[0-9\.]*$/.test(string)) {
    string = Number(string);
  }
  string = new Date(string);
  if (string.getTime()) {
    return string;
  }
};

dateRegex = "([0-9\.]{11,13}|[0-9]{4}-[0-9]{2}-[0-9a-zA-Z:\.]*)";

dateRangeRegex = "" + dateRegex + "?-?" + dateRegex + "?";

dateRange = function(string, formatter) {
  var date1, date2;
  if (formatter == null) {
    formatter = date;
  }
  if (typeof string === 'number') {
    string = string.toString();
  }
  if (typeof string === 'string' && (string = string != null ? string.match(new RegExp(dateRangeRegex)) : void 0)) {
    date1 = formatter(string[1]);
    date2 = formatter(string[2]);
  }
  return {
    from: date1,
    to: date2
  };
};

pagination = function(opt) {
  var limit, offset;
  if (opt == null) {
    opt = {};
  }
  limit = positiveInteger(opt.limit, {
    "default": opt["default"] || 50,
    max: opt.max
  });
  if (opt.page) {
    offset = (positiveInteger(opt.page, {
      "default": 1
    }) - 1) * limit;
  } else {
    offset = positiveInteger(opt.offset, {
      "default": 0
    });
  }
  return {
    offset: offset,
    limit: limit
  };
};

module.exports = {
  sort: function(string, opts) {
    return parseSort(opts)(string);
  },
  csv: csv,
  boolean: boolean,
  integer: integer,
  positiveInteger: positiveInteger,
  date: date,
  dateRange: dateRange,
  pagination: pagination
};
