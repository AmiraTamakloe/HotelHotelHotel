{"version":3,"file":"index.cjs","sources":["../tsc-out/intrinsicclass.js","../tsc-out/slots.js","../tsc-out/regex.js","../tsc-out/ecmascript.js","../tsc-out/intl.js","../tsc-out/instant.js","../tsc-out/calendar.js","../tsc-out/plaindate.js","../tsc-out/plaindatetime.js","../tsc-out/duration.js","../tsc-out/plainmonthday.js","../tsc-out/now.js","../tsc-out/plaintime.js","../tsc-out/timezone.js","../tsc-out/plainyearmonth.js","../tsc-out/zoneddatetime.js","../tsc-out/index.js","../tsc-out/legacydate.js"],"sourcesContent":["import { DEBUG } from './debug';\nconst INTRINSICS = {};\nconst customUtilInspectFormatters = {\n    ['Temporal.Duration'](depth, options) {\n        const descr = options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n        if (depth < 1)\n            return descr;\n        const entries = [];\n        for (const prop of [\n            'years',\n            'months',\n            'weeks',\n            'days',\n            'hours',\n            'minutes',\n            'seconds',\n            'milliseconds',\n            'microseconds',\n            'nanoseconds'\n        ]) {\n            if (this[prop] !== 0)\n                entries.push(`  ${prop}: ${options.stylize(this[prop], 'number')}`);\n        }\n        return descr + ' {\\n' + entries.join(',\\n') + '\\n}';\n    }\n};\nfunction defaultUtilInspectFormatter(depth, options) {\n    return options.stylize(`${this[Symbol.toStringTag]} <${this}>`, 'special');\n}\nexport function MakeIntrinsicClass(Class, name) {\n    Object.defineProperty(Class.prototype, Symbol.toStringTag, {\n        value: name,\n        writable: false,\n        enumerable: false,\n        configurable: true\n    });\n    if (DEBUG) {\n        Object.defineProperty(Class.prototype, Symbol.for('nodejs.util.inspect.custom'), {\n            value: customUtilInspectFormatters[name] || defaultUtilInspectFormatter,\n            writable: false,\n            enumerable: false,\n            configurable: true\n        });\n    }\n    for (const prop of Object.getOwnPropertyNames(Class)) {\n        // we know that `prop` is present, so the descriptor is never undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const desc = Object.getOwnPropertyDescriptor(Class, prop);\n        if (!desc.configurable || !desc.enumerable)\n            continue;\n        desc.enumerable = false;\n        Object.defineProperty(Class, prop, desc);\n    }\n    for (const prop of Object.getOwnPropertyNames(Class.prototype)) {\n        // we know that `prop` is present, so the descriptor is never undefined\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const desc = Object.getOwnPropertyDescriptor(Class.prototype, prop);\n        if (!desc.configurable || !desc.enumerable)\n            continue;\n        desc.enumerable = false;\n        Object.defineProperty(Class.prototype, prop, desc);\n    }\n    DefineIntrinsic(name, Class);\n    DefineIntrinsic(`${name}.prototype`, Class.prototype);\n}\nexport function DefineIntrinsic(name, value) {\n    const key = `%${name}%`;\n    if (INTRINSICS[key] !== undefined)\n        throw new Error(`intrinsic ${name} already exists`);\n    INTRINSICS[key] = value;\n}\nexport function GetIntrinsic(intrinsic) {\n    return INTRINSICS[intrinsic];\n}\n//# sourceMappingURL=intrinsicclass.js.map","// Instant\nexport const EPOCHNANOSECONDS = 'slot-epochNanoSeconds';\n// TimeZone\nexport const TIMEZONE_ID = 'slot-timezone-identifier';\n// DateTime, Date, Time, YearMonth, MonthDay\nexport const ISO_YEAR = 'slot-year';\nexport const ISO_MONTH = 'slot-month';\nexport const ISO_DAY = 'slot-day';\nexport const ISO_HOUR = 'slot-hour';\nexport const ISO_MINUTE = 'slot-minute';\nexport const ISO_SECOND = 'slot-second';\nexport const ISO_MILLISECOND = 'slot-millisecond';\nexport const ISO_MICROSECOND = 'slot-microsecond';\nexport const ISO_NANOSECOND = 'slot-nanosecond';\nexport const CALENDAR = 'slot-calendar';\n// Date, YearMonth, and MonthDay all have the same slots, disambiguation needed:\nexport const DATE_BRAND = 'slot-date-brand';\nexport const YEAR_MONTH_BRAND = 'slot-year-month-brand';\nexport const MONTH_DAY_BRAND = 'slot-month-day-brand';\n// ZonedDateTime\nexport const INSTANT = 'slot-cached-instant';\nexport const TIME_ZONE = 'slot-time-zone';\n// Duration\nexport const YEARS = 'slot-years';\nexport const MONTHS = 'slot-months';\nexport const WEEKS = 'slot-weeks';\nexport const DAYS = 'slot-days';\nexport const HOURS = 'slot-hours';\nexport const MINUTES = 'slot-minutes';\nexport const SECONDS = 'slot-seconds';\nexport const MILLISECONDS = 'slot-milliseconds';\nexport const MICROSECONDS = 'slot-microseconds';\nexport const NANOSECONDS = 'slot-nanoseconds';\n// Calendar\nexport const CALENDAR_ID = 'slot-calendar-identifier';\nconst slots = new WeakMap();\nexport function CreateSlots(container) {\n    slots.set(container, Object.create(null));\n}\nfunction GetSlots(container) {\n    return slots.get(container);\n}\nexport function HasSlot(container, ...ids) {\n    if (!container || 'object' !== typeof container)\n        return false;\n    const myslots = GetSlots(container);\n    return !!myslots && ids.reduce((all, id) => all && id in myslots, true);\n}\nexport function GetSlot(container, id) {\n    const value = GetSlots(container)[id];\n    if (value === undefined)\n        throw new TypeError(`Missing internal slot ${id}`);\n    return value;\n}\nexport function SetSlot(container, id, value) {\n    GetSlots(container)[id] = value;\n}\n//# sourceMappingURL=slots.js.map","const tzComponent = /\\.[-A-Za-z_]|\\.\\.[-A-Za-z._]{1,12}|\\.[-A-Za-z_][-A-Za-z._]{0,12}|[A-Za-z_][-A-Za-z._]{0,13}/;\nconst offsetNoCapture = /(?:[+\\u2212-][0-2][0-9](?::?[0-5][0-9](?::?[0-5][0-9](?:[.,]\\d{1,9})?)?)?)/;\nconst timeZoneID = new RegExp(`(?:(?:${tzComponent.source})(?:\\\\/(?:${tzComponent.source}))*|Etc/GMT[-+]\\\\d{1,2}|${offsetNoCapture.source})`);\nconst calComponent = /[A-Za-z0-9]{3,8}/;\nconst calendarID = new RegExp(`(?:${calComponent.source}(?:-${calComponent.source})*)`);\nconst yearpart = /(?:[+\\u2212-]\\d{6}|\\d{4})/;\nconst monthpart = /(?:0[1-9]|1[0-2])/;\nconst daypart = /(?:0[1-9]|[12]\\d|3[01])/;\nconst datesplit = new RegExp(`(${yearpart.source})(?:-(${monthpart.source})-(${daypart.source})|(${monthpart.source})(${daypart.source}))`);\nconst timesplit = /(\\d{2})(?::(\\d{2})(?::(\\d{2})(?:[.,](\\d{1,9}))?)?|(\\d{2})(?:(\\d{2})(?:[.,](\\d{1,9}))?)?)?/;\nexport const offset = /([+\\u2212-])([01][0-9]|2[0-3])(?::?([0-5][0-9])(?::?([0-5][0-9])(?:[.,](\\d{1,9}))?)?)?/;\nconst zonesplit = new RegExp(`(?:([zZ])|(?:${offset.source})?)(?:\\\\[(${timeZoneID.source})\\\\])?`);\nconst calendar = new RegExp(`\\\\[u-ca=(${calendarID.source})\\\\]`);\nexport const zoneddatetime = new RegExp(`^${datesplit.source}(?:(?:T|\\\\s+)${timesplit.source})?${zonesplit.source}(?:${calendar.source})?$`, 'i');\nexport const time = new RegExp(`^T?${timesplit.source}(?:${zonesplit.source})?(?:${calendar.source})?$`, 'i');\n// The short forms of YearMonth and MonthDay are only for the ISO calendar.\n// Non-ISO calendar YearMonth and MonthDay have to parse as a Temporal.PlainDate,\n// with the reference fields.\n// YYYYMM forbidden by ISO 8601 because ambiguous with YYMMDD, but allowed by\n// RFC 3339 and we don't allow 2-digit years, so we allow it.\n// Not ambiguous with HHMMSS because that requires a 'T' prefix\nexport const yearmonth = new RegExp(`^(${yearpart.source})-?(${monthpart.source})$`);\nexport const monthday = new RegExp(`^(?:--)?(${monthpart.source})-?(${daypart.source})$`);\nconst fraction = /(\\d+)(?:[.,](\\d{1,9}))?/;\nconst durationDate = /(?:(\\d+)Y)?(?:(\\d+)M)?(?:(\\d+)W)?(?:(\\d+)D)?/;\nconst durationTime = new RegExp(`(?:${fraction.source}H)?(?:${fraction.source}M)?(?:${fraction.source}S)?`);\nexport const duration = new RegExp(`^([+\\u2212-])?P${durationDate.source}(?:T(?!$)${durationTime.source})?$`, 'i');\n//# sourceMappingURL=regex.js.map","const ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush = Array.prototype.push;\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst MathMin = Math.min;\nconst MathMax = Math.max;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst MathSign = Math.sign;\nconst MathTrunc = Math.trunc;\nconst NumberIsNaN = Number.isNaN;\nconst NumberIsFinite = Number.isFinite;\nconst NumberCtor = Number;\nconst StringCtor = String;\nconst NumberMaxSafeInteger = Number.MAX_SAFE_INTEGER;\nconst ObjectAssign = Object.assign;\nconst ObjectCreate = Object.create;\nconst ObjectDefineProperty = Object.defineProperty;\nconst ObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nconst ObjectIs = Object.is;\nconst ReflectApply = Reflect.apply;\nimport { DEBUG } from './debug';\nimport JSBI from 'jsbi';\nimport { GetIntrinsic } from './intrinsicclass';\nimport { CreateSlots, GetSlot, HasSlot, SetSlot, EPOCHNANOSECONDS, TIMEZONE_ID, CALENDAR_ID, INSTANT, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, DATE_BRAND, YEAR_MONTH_BRAND, MONTH_DAY_BRAND, TIME_ZONE, CALENDAR, YEARS, MONTHS, WEEKS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS } from './slots';\nexport const ZERO = JSBI.BigInt(0);\nconst ONE = JSBI.BigInt(1);\nconst SIXTY = JSBI.BigInt(60);\nexport const THOUSAND = JSBI.BigInt(1e3);\nexport const MILLION = JSBI.BigInt(1e6);\nexport const BILLION = JSBI.BigInt(1e9);\nconst NEGATIVE_ONE = JSBI.BigInt(-1);\nconst DAY_SECONDS = 86400;\nconst DAY_NANOS = JSBI.multiply(JSBI.BigInt(DAY_SECONDS), BILLION);\nconst NS_MIN = JSBI.multiply(JSBI.BigInt(-86400), JSBI.BigInt(1e17));\nconst NS_MAX = JSBI.multiply(JSBI.BigInt(86400), JSBI.BigInt(1e17));\nconst YEAR_MIN = -271821;\nconst YEAR_MAX = 275760;\nconst BEFORE_FIRST_OFFSET_TRANSITION = JSBI.multiply(JSBI.BigInt(-388152), JSBI.BigInt(1e13)); // 1847-01-01T00:00:00Z\nconst ABOUT_TEN_YEARS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 10));\nconst ABOUT_ONE_YEAR_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(366 * 1));\nconst TWO_WEEKS_NANOS = JSBI.multiply(DAY_NANOS, JSBI.BigInt(2 * 7));\nconst BUILTIN_CALENDAR_IDS = [\n    'iso8601',\n    'hebrew',\n    'islamic',\n    'islamic-umalqura',\n    'islamic-tbla',\n    'islamic-civil',\n    'islamic-rgsa',\n    'islamicc',\n    'persian',\n    'ethiopic',\n    'ethioaa',\n    'coptic',\n    'chinese',\n    'dangi',\n    'roc',\n    'indian',\n    'buddhist',\n    'japanese',\n    'gregory'\n];\nfunction IsInteger(value) {\n    if (typeof value !== 'number' || !NumberIsFinite(value))\n        return false;\n    const abs = MathAbs(value);\n    return MathFloor(abs) === abs;\n}\nexport function IsObject(value) {\n    return (typeof value === 'object' && value !== null) || typeof value === 'function';\n}\nexport function ToNumber(value) {\n    if (typeof value === 'bigint')\n        throw new TypeError('Cannot convert BigInt to number');\n    return NumberCtor(value);\n}\nfunction ToInteger(value) {\n    const num = ToNumber(value);\n    if (NumberIsNaN(num))\n        return 0;\n    const integer = MathTrunc(num);\n    if (num === 0)\n        return 0;\n    return integer;\n}\nexport function ToString(value) {\n    if (typeof value === 'symbol') {\n        throw new TypeError('Cannot convert a Symbol value to a String');\n    }\n    return StringCtor(value);\n}\nexport function ToIntegerThrowOnInfinity(value) {\n    const integer = ToInteger(value);\n    if (!NumberIsFinite(integer)) {\n        throw new RangeError('infinity is out of range');\n    }\n    return integer;\n}\nfunction ToPositiveInteger(valueParam, property) {\n    const value = ToInteger(valueParam);\n    if (!NumberIsFinite(value)) {\n        throw new RangeError('infinity is out of range');\n    }\n    if (value < 1) {\n        if (property !== undefined) {\n            throw new RangeError(`property '${property}' cannot be a a number less than one`);\n        }\n        throw new RangeError('Cannot convert a number less than one to a positive integer');\n    }\n    return value;\n}\nexport function ToIntegerWithoutRounding(valueParam) {\n    const value = ToNumber(valueParam);\n    if (NumberIsNaN(value))\n        return 0;\n    if (!NumberIsFinite(value)) {\n        throw new RangeError('infinity is out of range');\n    }\n    if (!IsInteger(value)) {\n        throw new RangeError(`unsupported fractional value ${value}`);\n    }\n    return ToInteger(value); // ℝ(value) in spec text; converts -0 to 0\n}\nfunction divmod(x, y) {\n    const quotient = JSBI.divide(x, y);\n    const remainder = JSBI.remainder(x, y);\n    return { quotient, remainder };\n}\nfunction abs(x) {\n    if (JSBI.lessThan(x, ZERO))\n        return JSBI.multiply(x, NEGATIVE_ONE);\n    return x;\n}\nexport function ArrayPush(arr, ...newItem) {\n    ArrayPrototypePush.apply(arr, newItem);\n    return arr;\n}\nconst BUILTIN_CASTS = new Map([\n    ['year', ToIntegerThrowOnInfinity],\n    ['month', ToPositiveInteger],\n    ['monthCode', ToString],\n    ['day', ToPositiveInteger],\n    ['hour', ToIntegerThrowOnInfinity],\n    ['minute', ToIntegerThrowOnInfinity],\n    ['second', ToIntegerThrowOnInfinity],\n    ['millisecond', ToIntegerThrowOnInfinity],\n    ['microsecond', ToIntegerThrowOnInfinity],\n    ['nanosecond', ToIntegerThrowOnInfinity],\n    ['years', ToIntegerWithoutRounding],\n    ['months', ToIntegerWithoutRounding],\n    ['weeks', ToIntegerWithoutRounding],\n    ['days', ToIntegerWithoutRounding],\n    ['hours', ToIntegerWithoutRounding],\n    ['minutes', ToIntegerWithoutRounding],\n    ['seconds', ToIntegerWithoutRounding],\n    ['milliseconds', ToIntegerWithoutRounding],\n    ['microseconds', ToIntegerWithoutRounding],\n    ['nanoseconds', ToIntegerWithoutRounding],\n    ['era', ToString],\n    ['eraYear', ToInteger],\n    ['offset', ToString]\n]);\nconst BUILTIN_DEFAULTS = new Map([\n    ['hour', 0],\n    ['minute', 0],\n    ['second', 0],\n    ['millisecond', 0],\n    ['microsecond', 0],\n    ['nanosecond', 0]\n]);\n// each item is [plural, singular, category]\nconst SINGULAR_PLURAL_UNITS = [\n    ['years', 'year', 'date'],\n    ['months', 'month', 'date'],\n    ['weeks', 'week', 'date'],\n    ['days', 'day', 'date'],\n    ['hours', 'hour', 'time'],\n    ['minutes', 'minute', 'time'],\n    ['seconds', 'second', 'time'],\n    ['milliseconds', 'millisecond', 'time'],\n    ['microseconds', 'microsecond', 'time'],\n    ['nanoseconds', 'nanosecond', 'time']\n];\nconst SINGULAR_FOR = new Map(SINGULAR_PLURAL_UNITS.map((e) => [e[0], e[1]]));\nconst PLURAL_FOR = new Map(SINGULAR_PLURAL_UNITS.map(([p, s]) => [s, p]));\nconst UNITS_DESCENDING = SINGULAR_PLURAL_UNITS.map(([, s]) => s);\nconst DURATION_FIELDS = Array.from(SINGULAR_FOR.keys()).sort();\nimport * as PARSE from './regex';\nconst IntlDateTimeFormatEnUsCache = new Map();\nfunction getIntlDateTimeFormatEnUsForTimeZone(timeZoneIdentifier) {\n    let instance = IntlDateTimeFormatEnUsCache.get(timeZoneIdentifier);\n    if (instance === undefined) {\n        instance = new IntlDateTimeFormat('en-us', {\n            timeZone: StringCtor(timeZoneIdentifier),\n            hour12: false,\n            era: 'short',\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n        IntlDateTimeFormatEnUsCache.set(timeZoneIdentifier, instance);\n    }\n    return instance;\n}\nexport function IsTemporalInstant(item) {\n    return HasSlot(item, EPOCHNANOSECONDS) && !HasSlot(item, TIME_ZONE, CALENDAR);\n}\nexport function IsTemporalTimeZone(item) {\n    return HasSlot(item, TIMEZONE_ID);\n}\nexport function IsTemporalCalendar(item) {\n    return HasSlot(item, CALENDAR_ID);\n}\nexport function IsTemporalDuration(item) {\n    return HasSlot(item, YEARS, MONTHS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS);\n}\nexport function IsTemporalDate(item) {\n    return HasSlot(item, DATE_BRAND);\n}\nexport function IsTemporalTime(item) {\n    return (HasSlot(item, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND) &&\n        !HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY));\n}\nexport function IsTemporalDateTime(item) {\n    return HasSlot(item, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND);\n}\nexport function IsTemporalYearMonth(item) {\n    return HasSlot(item, YEAR_MONTH_BRAND);\n}\nexport function IsTemporalMonthDay(item) {\n    return HasSlot(item, MONTH_DAY_BRAND);\n}\nexport function IsTemporalZonedDateTime(item) {\n    return HasSlot(item, EPOCHNANOSECONDS, TIME_ZONE, CALENDAR);\n}\nexport function RejectObjectWithCalendarOrTimeZone(item) {\n    if (HasSlot(item, CALENDAR) || HasSlot(item, TIME_ZONE)) {\n        throw new TypeError('with() does not support a calendar or timeZone property');\n    }\n    if (item.calendar !== undefined) {\n        throw new TypeError('with() does not support a calendar property');\n    }\n    if (item.timeZone !== undefined) {\n        throw new TypeError('with() does not support a timeZone property');\n    }\n}\nfunction ParseTemporalTimeZone(stringIdent) {\n    let { ianaName, offset, z } = ParseTemporalTimeZoneString(stringIdent);\n    if (ianaName)\n        return ianaName;\n    if (z)\n        return 'UTC';\n    return offset; // if !ianaName && !z then offset must be present\n}\nfunction FormatCalendarAnnotation(id, showCalendar) {\n    if (showCalendar === 'never')\n        return '';\n    if (showCalendar === 'auto' && id === 'iso8601')\n        return '';\n    return `[u-ca=${id}]`;\n}\nfunction ParseISODateTime(isoString) {\n    // ZDT is the superset of fields for every other Temporal type\n    const match = PARSE.zoneddatetime.exec(isoString);\n    if (!match)\n        throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    let yearString = match[1];\n    if (yearString[0] === '\\u2212')\n        yearString = `-${yearString.slice(1)}`;\n    if (yearString === '-000000')\n        throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n    const year = ToInteger(yearString);\n    const month = ToInteger(match[2] || match[4]);\n    const day = ToInteger(match[3] || match[5]);\n    const hour = ToInteger(match[6]);\n    const hasTime = match[6] !== undefined;\n    const minute = ToInteger(match[7] || match[10]);\n    let second = ToInteger(match[8] || match[11]);\n    if (second === 60)\n        second = 59;\n    const fraction = (match[9] || match[12]) + '000000000';\n    const millisecond = ToInteger(fraction.slice(0, 3));\n    const microsecond = ToInteger(fraction.slice(3, 6));\n    const nanosecond = ToInteger(fraction.slice(6, 9));\n    let offset;\n    let z = false;\n    if (match[13]) {\n        offset = undefined;\n        z = true;\n    }\n    else if (match[14] && match[15]) {\n        const offsetSign = match[14] === '-' || match[14] === '\\u2212' ? '-' : '+';\n        const offsetHours = match[15] || '00';\n        const offsetMinutes = match[16] || '00';\n        const offsetSeconds = match[17] || '00';\n        let offsetFraction = match[18] || '0';\n        offset = `${offsetSign}${offsetHours}:${offsetMinutes}`;\n        if (+offsetFraction) {\n            while (offsetFraction.endsWith('0'))\n                offsetFraction = offsetFraction.slice(0, -1);\n            offset += `:${offsetSeconds}.${offsetFraction}`;\n        }\n        else if (+offsetSeconds) {\n            offset += `:${offsetSeconds}`;\n        }\n        if (offset === '-00:00')\n            offset = '+00:00';\n    }\n    let ianaName = match[19];\n    if (ianaName) {\n        try {\n            // Canonicalize name if it is an IANA link name or is capitalized wrong\n            ianaName = GetCanonicalTimeZoneIdentifier(ianaName).toString();\n        }\n        catch {\n            // Not an IANA name, may be a custom ID, pass through unchanged\n        }\n    }\n    const calendar = match[20];\n    RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    return {\n        year,\n        month,\n        day,\n        hasTime,\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond,\n        ianaName,\n        offset,\n        z,\n        calendar\n    };\n}\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalInstantString(isoString) {\n    const result = ParseISODateTime(isoString);\n    if (!result.z && !result.offset)\n        throw new RangeError('Temporal.Instant requires a time zone offset');\n    return result;\n}\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalZonedDateTimeString(isoString) {\n    const result = ParseISODateTime(isoString);\n    if (!result.ianaName)\n        throw new RangeError('Temporal.ZonedDateTime requires a time zone ID in brackets');\n    return result;\n}\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDateTimeString(isoString) {\n    return ParseISODateTime(isoString);\n}\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDateString(isoString) {\n    return ParseISODateTime(isoString);\n}\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalTimeString(isoString) {\n    const match = PARSE.time.exec(isoString);\n    let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (match) {\n        hour = ToInteger(match[1]);\n        minute = ToInteger(match[2] || match[5]);\n        second = ToInteger(match[3] || match[6]);\n        if (second === 60)\n            second = 59;\n        const fraction = (match[4] || match[7]) + '000000000';\n        millisecond = ToInteger(fraction.slice(0, 3));\n        microsecond = ToInteger(fraction.slice(3, 6));\n        nanosecond = ToInteger(fraction.slice(6, 9));\n        calendar = match[15];\n    }\n    else {\n        let z, hasTime;\n        ({ hasTime, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n            ParseISODateTime(isoString));\n        if (!hasTime)\n            throw new RangeError(`time is missing in string: ${isoString}`);\n        if (z)\n            throw new RangeError('Z designator not supported for PlainTime');\n    }\n    // if it's a date-time string, OK\n    if (/[tT ][0-9][0-9]/.test(isoString)) {\n        return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n    }\n    // slow but non-grammar-dependent way to ensure that time-only strings that\n    // are also valid PlainMonthDay and PlainYearMonth throw. corresponds to\n    // assertion in spec text\n    try {\n        const { month, day } = ParseTemporalMonthDayString(isoString);\n        RejectISODate(1972, month, day);\n    }\n    catch {\n        try {\n            const { year, month } = ParseTemporalYearMonthString(isoString);\n            RejectISODate(year, month, 1);\n        }\n        catch {\n            return { hour, minute, second, millisecond, microsecond, nanosecond, calendar };\n        }\n    }\n    throw new RangeError(`invalid ISO 8601 time-only string ${isoString}; may need a T prefix`);\n}\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalYearMonthString(isoString) {\n    const match = PARSE.yearmonth.exec(isoString);\n    let year, month, calendar, referenceISODay;\n    if (match) {\n        let yearString = match[1];\n        if (yearString[0] === '\\u2212')\n            yearString = `-${yearString.slice(1)}`;\n        if (yearString === '-000000')\n            throw new RangeError(`invalid ISO 8601 string: ${isoString}`);\n        year = ToInteger(yearString);\n        month = ToInteger(match[2]);\n        calendar = match[3];\n    }\n    else {\n        let z;\n        ({ year, month, calendar, day: referenceISODay, z } = ParseISODateTime(isoString));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainYearMonth');\n    }\n    return { year, month, calendar, referenceISODay };\n}\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalMonthDayString(isoString) {\n    const match = PARSE.monthday.exec(isoString);\n    let month, day, calendar, referenceISOYear;\n    if (match) {\n        month = ToInteger(match[1]);\n        day = ToInteger(match[2]);\n    }\n    else {\n        let z;\n        ({ month, day, calendar, year: referenceISOYear, z } = ParseISODateTime(isoString));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainMonthDay');\n    }\n    return { month, day, calendar, referenceISOYear };\n}\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalTimeZoneString(stringIdent) {\n    try {\n        let canonicalIdent = GetCanonicalTimeZoneIdentifier(stringIdent);\n        if (canonicalIdent)\n            return { ianaName: canonicalIdent.toString() };\n    }\n    catch {\n        // fall through\n    }\n    try {\n        // Try parsing ISO string instead\n        const result = ParseISODateTime(stringIdent);\n        if (result.z || result.offset || result.ianaName) {\n            return result;\n        }\n    }\n    catch {\n        // fall through\n    }\n    throw new RangeError(`Invalid time zone: ${stringIdent}`);\n}\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalDurationString(isoString) {\n    const match = PARSE.duration.exec(isoString);\n    if (!match)\n        throw new RangeError(`invalid duration: ${isoString}`);\n    if (match.slice(2).every((element) => element === undefined)) {\n        throw new RangeError(`invalid duration: ${isoString}`);\n    }\n    const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : 1;\n    const years = ToInteger(match[2]) * sign;\n    const months = ToInteger(match[3]) * sign;\n    const weeks = ToInteger(match[4]) * sign;\n    const days = ToInteger(match[5]) * sign;\n    const hours = ToInteger(match[6]) * sign;\n    let fHours = match[7];\n    let minutes = ToInteger(match[8]) * sign;\n    let fMinutes = match[9];\n    let seconds = ToInteger(match[10]) * sign;\n    const fSeconds = match[11] + '000000000';\n    let milliseconds = ToInteger(fSeconds.slice(0, 3)) * sign;\n    let microseconds = ToInteger(fSeconds.slice(3, 6)) * sign;\n    let nanoseconds = ToInteger(fSeconds.slice(6, 9)) * sign;\n    fHours = fHours ? (sign * ToInteger(fHours)) / 10 ** fHours.length : 0;\n    fMinutes = fMinutes ? (sign * ToInteger(fMinutes)) / 10 ** fMinutes.length : 0;\n    ({ minutes, seconds, milliseconds, microseconds, nanoseconds } = DurationHandleFractions(fHours, minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds));\n    RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n// ts-prune-ignore-next TODO: remove if test/validStrings is converted to TS.\nexport function ParseTemporalInstant(isoString) {\n    let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offset, z } = ParseTemporalInstantString(isoString);\n    if (!z && !offset)\n        throw new RangeError('Temporal.Instant requires a time zone offset');\n    // At least one of z or offset is defined, but TS doesn't seem to understand\n    // that we only use offset if z is not defined (and thus offset must be defined).\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const offsetNs = z ? 0 : ParseTimeZoneOffsetString(offset);\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond - offsetNs));\n    const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (epochNs === null)\n        throw new RangeError('DateTime outside of supported range');\n    return epochNs;\n}\nexport function RegulateISODate(yearParam, monthParam, dayParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    switch (overflow) {\n        case 'reject':\n            RejectISODate(year, month, day);\n            break;\n        case 'constrain':\n            ({ year, month, day } = ConstrainISODate(year, month, day));\n            break;\n    }\n    return { year, month, day };\n}\nexport function RegulateTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, overflow) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    switch (overflow) {\n        case 'reject':\n            RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n            break;\n        case 'constrain':\n            ({ hour, minute, second, millisecond, microsecond, nanosecond } = ConstrainTime(hour, minute, second, millisecond, microsecond, nanosecond));\n            break;\n    }\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function RegulateISOYearMonth(yearParam, monthParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    const referenceISODay = 1;\n    switch (overflow) {\n        case 'reject':\n            RejectISODate(year, month, referenceISODay);\n            break;\n        case 'constrain':\n            ({ year, month } = ConstrainISODate(year, month));\n            break;\n    }\n    return { year, month };\n}\nfunction DurationHandleFractions(fHoursParam, minutesParam, fMinutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam) {\n    let fHours = fHoursParam;\n    let minutes = minutesParam;\n    let fMinutes = fMinutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = nanosecondsParam;\n    if (fHours !== 0) {\n        [minutes, fMinutes, seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {\n            if (val !== 0)\n                throw new RangeError('only the smallest unit can be fractional');\n        });\n        const mins = fHours * 60;\n        minutes = MathTrunc(mins);\n        fMinutes = mins % 1;\n    }\n    if (fMinutes !== 0) {\n        [seconds, milliseconds, microseconds, nanoseconds].forEach((val) => {\n            if (val !== 0)\n                throw new RangeError('only the smallest unit can be fractional');\n        });\n        const secs = fMinutes * 60;\n        seconds = MathTrunc(secs);\n        const fSeconds = secs % 1;\n        if (fSeconds !== 0) {\n            const mils = fSeconds * 1000;\n            milliseconds = MathTrunc(mils);\n            const fMilliseconds = mils % 1;\n            if (fMilliseconds !== 0) {\n                const mics = fMilliseconds * 1000;\n                microseconds = MathTrunc(mics);\n                const fMicroseconds = mics % 1;\n                if (fMicroseconds !== 0) {\n                    const nans = fMicroseconds * 1000;\n                    nanoseconds = MathTrunc(nans);\n                }\n            }\n        }\n    }\n    return { minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ToTemporalDurationRecord(item) {\n    if (!IsObject(item)) {\n        return ParseTemporalDurationString(ToString(item));\n    }\n    if (IsTemporalDuration(item)) {\n        return {\n            years: GetSlot(item, YEARS),\n            months: GetSlot(item, MONTHS),\n            weeks: GetSlot(item, WEEKS),\n            days: GetSlot(item, DAYS),\n            hours: GetSlot(item, HOURS),\n            minutes: GetSlot(item, MINUTES),\n            seconds: GetSlot(item, SECONDS),\n            milliseconds: GetSlot(item, MILLISECONDS),\n            microseconds: GetSlot(item, MICROSECONDS),\n            nanoseconds: GetSlot(item, NANOSECONDS)\n        };\n    }\n    const result = {\n        years: 0,\n        months: 0,\n        weeks: 0,\n        days: 0,\n        hours: 0,\n        minutes: 0,\n        seconds: 0,\n        milliseconds: 0,\n        microseconds: 0,\n        nanoseconds: 0\n    };\n    let partial = ToTemporalPartialDurationRecord(item);\n    for (const property of DURATION_FIELDS) {\n        const value = partial[property];\n        if (value !== undefined) {\n            result[property] = value;\n        }\n    }\n    let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = result;\n    RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction ToTemporalPartialDurationRecord(temporalDurationLike) {\n    if (!IsObject(temporalDurationLike)) {\n        throw new TypeError('invalid duration-like');\n    }\n    const result = {\n        years: undefined,\n        months: undefined,\n        weeks: undefined,\n        days: undefined,\n        hours: undefined,\n        minutes: undefined,\n        seconds: undefined,\n        milliseconds: undefined,\n        microseconds: undefined,\n        nanoseconds: undefined\n    };\n    let any = false;\n    for (const property of DURATION_FIELDS) {\n        const value = temporalDurationLike[property];\n        if (value !== undefined) {\n            any = true;\n            result[property] = ToIntegerWithoutRounding(value);\n        }\n    }\n    if (!any) {\n        throw new TypeError('invalid duration-like');\n    }\n    return result;\n}\nfunction ToLimitedTemporalDuration(item, disallowedProperties) {\n    let record = ToTemporalDurationRecord(item);\n    for (const property of disallowedProperties) {\n        if (record[property] !== 0) {\n            throw new RangeError(`Duration field ${property} not supported by Temporal.Instant. Try Temporal.ZonedDateTime instead.`);\n        }\n    }\n    return record;\n}\nexport function ToTemporalOverflow(options) {\n    if (options === undefined)\n        return 'constrain';\n    return GetOption(options, 'overflow', ['constrain', 'reject'], 'constrain');\n}\nexport function ToTemporalDisambiguation(options) {\n    if (options === undefined)\n        return 'compatible';\n    return GetOption(options, 'disambiguation', ['compatible', 'earlier', 'later', 'reject'], 'compatible');\n}\nexport function ToTemporalRoundingMode(options, fallback) {\n    return GetOption(options, 'roundingMode', ['ceil', 'floor', 'trunc', 'halfExpand'], fallback);\n}\nfunction NegateTemporalRoundingMode(roundingMode) {\n    switch (roundingMode) {\n        case 'ceil':\n            return 'floor';\n        case 'floor':\n            return 'ceil';\n        default:\n            return roundingMode;\n    }\n}\nexport function ToTemporalOffset(options, fallback) {\n    if (options === undefined)\n        return fallback;\n    return GetOption(options, 'offset', ['prefer', 'use', 'ignore', 'reject'], fallback);\n}\nexport function ToShowCalendarOption(options) {\n    return GetOption(options, 'calendarName', ['auto', 'always', 'never'], 'auto');\n}\nexport function ToShowTimeZoneNameOption(options) {\n    return GetOption(options, 'timeZoneName', ['auto', 'never'], 'auto');\n}\nexport function ToShowOffsetOption(options) {\n    return GetOption(options, 'offset', ['auto', 'never'], 'auto');\n}\nexport function ToTemporalRoundingIncrement(options, dividend, inclusive) {\n    let maximum = Infinity;\n    if (dividend !== undefined)\n        maximum = dividend;\n    if (!inclusive && dividend !== undefined)\n        maximum = dividend > 1 ? dividend - 1 : 1;\n    const increment = GetNumberOption(options, 'roundingIncrement', 1, maximum, 1);\n    if (dividend !== undefined && dividend % increment !== 0) {\n        throw new RangeError(`Rounding increment must divide evenly into ${dividend}`);\n    }\n    return increment;\n}\nexport function ToTemporalDateTimeRoundingIncrement(options, smallestUnit) {\n    const maximumIncrements = {\n        year: undefined,\n        month: undefined,\n        week: undefined,\n        day: undefined,\n        hour: 24,\n        minute: 60,\n        second: 60,\n        millisecond: 1000,\n        microsecond: 1000,\n        nanosecond: 1000\n    };\n    return ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n}\nexport function ToSecondsStringPrecision(options) {\n    const smallestUnit = GetTemporalUnit(options, 'smallestUnit', 'time', undefined);\n    if (smallestUnit === 'hour') {\n        const ALLOWED_UNITS = SINGULAR_PLURAL_UNITS.reduce((allowed, [p, s, c]) => {\n            // Weirdly, local type inference seems to understand the types of s and p, but tsc still complains.\n            // Maybe this is fixed in later TS versions?\n            if (c === 'time' && s !== 'hour') {\n                allowed.push(s, p);\n            }\n            return allowed;\n        }, []);\n        throw new RangeError(`smallestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${smallestUnit}`);\n    }\n    switch (smallestUnit) {\n        case 'minute':\n            return { precision: 'minute', unit: 'minute', increment: 1 };\n        case 'second':\n            return { precision: 0, unit: 'second', increment: 1 };\n        case 'millisecond':\n            return { precision: 3, unit: 'millisecond', increment: 1 };\n        case 'microsecond':\n            return { precision: 6, unit: 'microsecond', increment: 1 };\n        case 'nanosecond':\n            return { precision: 9, unit: 'nanosecond', increment: 1 };\n        default: // fall through if option not given\n    }\n    let digits = options.fractionalSecondDigits;\n    if (digits === undefined)\n        digits = 'auto';\n    if (typeof digits !== 'number') {\n        const stringDigits = ToString(digits);\n        if (stringDigits === 'auto')\n            return { precision: 'auto', unit: 'nanosecond', increment: 1 };\n        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${stringDigits}`);\n    }\n    if (NumberIsNaN(digits) || digits < 0 || digits > 9) {\n        throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n    }\n    const precision = MathFloor(digits);\n    switch (precision) {\n        case 0:\n            return { precision, unit: 'second', increment: 1 };\n        case 1:\n        case 2:\n        case 3:\n            return { precision, unit: 'millisecond', increment: 10 ** (3 - precision) };\n        case 4:\n        case 5:\n        case 6:\n            return { precision, unit: 'microsecond', increment: 10 ** (6 - precision) };\n        case 7:\n        case 8:\n        case 9:\n            return { precision, unit: 'nanosecond', increment: 10 ** (9 - precision) };\n        default:\n            throw new RangeError(`fractionalSecondDigits must be 'auto' or 0 through 9, not ${digits}`);\n    }\n}\nexport const REQUIRED = Symbol('~required~');\n// This signature of the function is NOT used in type-checking, so restricting\n// the default value via generic binding like the other overloads isn't\n// necessary.\nexport function GetTemporalUnit(options, key, unitGroup, requiredOrDefault, extraValues = []) {\n    const allowedSingular = [];\n    for (const [, singular, category] of SINGULAR_PLURAL_UNITS) {\n        if (unitGroup === 'datetime' || unitGroup === category) {\n            allowedSingular.push(singular);\n        }\n    }\n    allowedSingular.push(...extraValues);\n    let defaultVal = requiredOrDefault;\n    if (defaultVal === REQUIRED) {\n        defaultVal = undefined;\n    }\n    else if (defaultVal !== undefined) {\n        allowedSingular.push(defaultVal);\n    }\n    const allowedValues = [\n        ...allowedSingular\n    ];\n    for (const singular of allowedSingular) {\n        const plural = PLURAL_FOR.get(singular);\n        if (plural !== undefined)\n            allowedValues.push(plural);\n    }\n    let retval = GetOption(options, key, allowedValues, defaultVal);\n    if (retval === undefined && requiredOrDefault === REQUIRED) {\n        throw new RangeError(`${key} is required`);\n    }\n    // Coerce any plural units into their singular form\n    if (SINGULAR_FOR.has(retval)) {\n        // We just has-checked this, but tsc doesn't understand that.\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return SINGULAR_FOR.get(retval);\n    }\n    return retval;\n}\nexport function ToRelativeTemporalObject(options) {\n    const relativeTo = options.relativeTo;\n    if (relativeTo === undefined)\n        return relativeTo;\n    let offsetBehaviour = 'option';\n    let matchMinutes = false;\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, timeZone, offset;\n    if (IsObject(relativeTo)) {\n        if (IsTemporalZonedDateTime(relativeTo) || IsTemporalDate(relativeTo))\n            return relativeTo;\n        if (IsTemporalDateTime(relativeTo))\n            return TemporalDateTimeToDate(relativeTo);\n        calendar = GetTemporalCalendarWithISODefault(relativeTo);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = PrepareTemporalFields(relativeTo, fieldNames, []);\n        const dateOptions = ObjectCreate(null);\n        dateOptions.overflow = 'constrain';\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, dateOptions));\n        // The `offset` and `timeZone` properties only exist on ZonedDateTime (or\n        // ZonedDateTimeLike-property bags). The assertions below are used to avoid\n        // TS errors while not diverging runtime code from proposal-temporal.\n        offset = relativeTo.offset;\n        if (offset === undefined)\n            offsetBehaviour = 'wall';\n        timeZone = relativeTo.timeZone;\n    }\n    else {\n        let ianaName, z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, ianaName, offset, z } =\n            ParseISODateTime(ToString(relativeTo)));\n        if (ianaName)\n            timeZone = ianaName;\n        if (z) {\n            offsetBehaviour = 'exact';\n        }\n        else if (!offset) {\n            offsetBehaviour = 'wall';\n        }\n        if (!calendar)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n        matchMinutes = true;\n    }\n    if (timeZone !== undefined) {\n        timeZone = ToTemporalTimeZone(timeZone);\n        let offsetNs = 0;\n        if (offsetBehaviour === 'option')\n            offsetNs = ParseTimeZoneOffsetString(ToString(offset));\n        const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, 'compatible', 'reject', matchMinutes);\n        return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n    }\n    return CreateTemporalDate(year, month, day, calendar);\n}\nexport function DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    for (const [prop, v] of [\n        ['years', years],\n        ['months', months],\n        ['weeks', weeks],\n        ['days', days],\n        ['hours', hours],\n        ['minutes', minutes],\n        ['seconds', seconds],\n        ['milliseconds', milliseconds],\n        ['microseconds', microseconds],\n        ['nanoseconds', nanoseconds]\n    ]) {\n        if (v !== 0) {\n            // All the above keys are definitely in SINGULAR_FOR\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return SINGULAR_FOR.get(prop);\n        }\n    }\n    return 'nanosecond';\n}\nexport function LargerOfTwoTemporalUnits(unit1, unit2) {\n    if (UNITS_DESCENDING.indexOf(unit1) > UNITS_DESCENDING.indexOf(unit2))\n        return unit2;\n    return unit1;\n}\nfunction MergeLargestUnitOption(optionsParam, largestUnit) {\n    let options = optionsParam;\n    if (options === undefined)\n        options = ObjectCreate(null);\n    return ObjectAssign(ObjectCreate(null), options, { largestUnit });\n}\nexport function PrepareTemporalFields(bag, fields, requiredFields, { emptySourceErrorMessage } = { emptySourceErrorMessage: 'no supported properties found' }) {\n    const result = ObjectCreate(null);\n    let any = false;\n    for (const property of fields) {\n        let value = bag[property];\n        if (value !== undefined) {\n            any = true;\n            if (BUILTIN_CASTS.has(property)) {\n                // We just has-checked this map access, so there will definitely be a\n                // value.\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                value = BUILTIN_CASTS.get(property)(value);\n            }\n            result[property] = value;\n        }\n        else if (requiredFields !== 'partial') {\n            // TODO: using .call in this way is not correctly type-checked by tsc.\n            // We might need a type-safe Call wrapper?\n            if (ArrayIncludes.call(requiredFields, property)) {\n                throw new TypeError(`required property '${property}' missing or undefined`);\n            }\n            value = BUILTIN_DEFAULTS.get(property);\n            result[property] = value;\n        }\n    }\n    if (requiredFields === 'partial' && !any) {\n        throw new TypeError(emptySourceErrorMessage);\n    }\n    if ((result.era === undefined) !== (result.eraYear === undefined)) {\n        throw new RangeError(\"properties 'era' and 'eraYear' must be provided together\");\n    }\n    return result;\n}\nexport function ToTemporalTimeRecord(bag, completeness = 'complete') {\n    // NOTE: Field order here is important.\n    const fields = ['hour', 'microsecond', 'millisecond', 'minute', 'nanosecond', 'second'];\n    const partial = PrepareTemporalFields(bag, fields, 'partial', { emptySourceErrorMessage: 'invalid time-like' });\n    const result = {};\n    for (const field of fields) {\n        const valueDesc = ObjectGetOwnPropertyDescriptor(partial, field);\n        if (valueDesc !== undefined) {\n            result[field] = valueDesc.value;\n        }\n        else if (completeness === 'complete') {\n            result[field] = 0;\n        }\n    }\n    return result;\n}\nexport function ToTemporalDate(itemParam, options) {\n    let item = itemParam;\n    if (IsObject(item)) {\n        if (IsTemporalDate(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDateTime(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n        }\n        const calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const fields = PrepareTemporalFields(item, fieldNames, []);\n        return CalendarDateFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    const { year, month, day, calendar, z } = ParseTemporalDateString(ToString(item));\n    if (z)\n        throw new RangeError('Z designator not supported for PlainDate');\n    const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n    return new TemporalPlainDate(year, month, day, calendar); // include validation\n}\nexport function InterpretTemporalDateTimeFields(calendar, fields, options) {\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(fields);\n    const overflow = ToTemporalOverflow(options);\n    const date = CalendarDateFromFields(calendar, fields, options);\n    const year = GetSlot(date, ISO_YEAR);\n    const month = GetSlot(date, ISO_MONTH);\n    const day = GetSlot(date, ISO_DAY);\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function ToTemporalDateTime(item, options) {\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (IsObject(item)) {\n        if (IsTemporalDateTime(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDate(item)) {\n            ToTemporalOverflow(options); // validate and ignore\n            return CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), 0, 0, 0, 0, 0, 0, GetSlot(item, CALENDAR));\n        }\n        calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fields = PrepareTemporalFields(item, fieldNames, []);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options));\n    }\n    else {\n        ToTemporalOverflow(options); // validate and ignore\n        let z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, z } =\n            ParseTemporalDateTimeString(ToString(item)));\n        if (z)\n            throw new RangeError('Z designator not supported for PlainDateTime');\n        RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        if (calendar === undefined)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n    }\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\nexport function ToTemporalDuration(item) {\n    if (IsTemporalDuration(item))\n        return item;\n    let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToTemporalDurationRecord(item);\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    return new TemporalDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n}\nexport function ToTemporalInstant(item) {\n    if (IsTemporalInstant(item))\n        return item;\n    if (IsTemporalZonedDateTime(item)) {\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        return new TemporalInstant(GetSlot(item, EPOCHNANOSECONDS));\n    }\n    const ns = ParseTemporalInstant(ToString(item));\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    return new TemporalInstant(ns);\n}\nexport function ToTemporalMonthDay(itemParam, options) {\n    let item = itemParam;\n    if (IsObject(item)) {\n        if (IsTemporalMonthDay(item))\n            return item;\n        let calendar, calendarAbsent;\n        if (HasSlot(item, CALENDAR)) {\n            calendar = GetSlot(item, CALENDAR);\n            calendarAbsent = false;\n        }\n        else {\n            let maybeStringCalendar = item.calendar;\n            calendarAbsent = maybeStringCalendar === undefined;\n            if (maybeStringCalendar === undefined)\n                maybeStringCalendar = GetISO8601Calendar();\n            calendar = ToTemporalCalendar(maybeStringCalendar);\n        }\n        // HasSlot above adjusts the type of 'item' to include\n        // TypesWithCalendarUnits, which causes type-inference failures below.\n        // This is probably indicative of problems with HasSlot's typing.\n        item = item;\n        const fieldNames = CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const fields = PrepareTemporalFields(item, fieldNames, []);\n        // Callers who omit the calendar are not writing calendar-independent\n        // code. In that case, `monthCode`/`year` can be omitted; `month` and\n        // `day` are sufficient. Add a `year` to satisfy calendar validation.\n        if (calendarAbsent && fields.month !== undefined && fields.monthCode === undefined && fields.year === undefined) {\n            fields.year = 1972;\n        }\n        return CalendarMonthDayFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    let { month, day, referenceISOYear, calendar: maybeStringCalendar } = ParseTemporalMonthDayString(ToString(item));\n    let calendar = maybeStringCalendar;\n    if (calendar === undefined)\n        calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    if (referenceISOYear === undefined) {\n        RejectISODate(1972, month, day);\n        return CreateTemporalMonthDay(month, day, calendar);\n    }\n    const result = CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n    return CalendarMonthDayFromFields(calendar, result);\n}\nexport function ToTemporalTime(itemParam, overflow = 'constrain') {\n    let item = itemParam;\n    let hour, minute, second, millisecond, microsecond, nanosecond, calendar;\n    if (IsObject(item)) {\n        if (IsTemporalTime(item))\n            return item;\n        if (IsTemporalZonedDateTime(item)) {\n            item = BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(item, TIME_ZONE), GetSlot(item, INSTANT), GetSlot(item, CALENDAR));\n        }\n        if (IsTemporalDateTime(item)) {\n            const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n            return new TemporalPlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n        }\n        calendar = GetTemporalCalendarWithISODefault(item);\n        if (ToString(calendar) !== 'iso8601') {\n            throw new RangeError('PlainTime can only have iso8601 calendar');\n        }\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ToTemporalTimeRecord(item));\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n    }\n    else {\n        ({ hour, minute, second, millisecond, microsecond, nanosecond, calendar } = ParseTemporalTimeString(ToString(item)));\n        RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n        if (calendar !== undefined && calendar !== 'iso8601') {\n            throw new RangeError('PlainTime can only have iso8601 calendar');\n        }\n    }\n    const TemporalPlainTime = GetIntrinsic('%Temporal.PlainTime%');\n    return new TemporalPlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\nexport function ToTemporalYearMonth(item, options) {\n    if (IsObject(item)) {\n        if (IsTemporalYearMonth(item))\n            return item;\n        const calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, ['month', 'monthCode', 'year']);\n        const fields = PrepareTemporalFields(item, fieldNames, []);\n        return CalendarYearMonthFromFields(calendar, fields, options);\n    }\n    ToTemporalOverflow(options); // validate and ignore\n    let { year, month, referenceISODay, calendar: maybeStringCalendar } = ParseTemporalYearMonthString(ToString(item));\n    // TODO: replace with ternary?\n    let calendar = maybeStringCalendar;\n    if (calendar === undefined)\n        calendar = GetISO8601Calendar();\n    calendar = ToTemporalCalendar(calendar);\n    if (referenceISODay === undefined) {\n        RejectISODate(year, month, 1);\n        return CreateTemporalYearMonth(year, month, calendar);\n    }\n    const result = CreateTemporalYearMonth(year, month, calendar, referenceISODay);\n    return CalendarYearMonthFromFields(calendar, result);\n}\nexport function InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute) {\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const dt = new DateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (offsetBehaviour === 'wall' || offsetOpt === 'ignore') {\n        // Simple case: ISO string without a TZ offset (or caller wants to ignore\n        // the offset), so just convert DateTime to Instant in the given time zone\n        const instant = BuiltinTimeZoneGetInstantFor(timeZone, dt, disambiguation);\n        return GetSlot(instant, EPOCHNANOSECONDS);\n    }\n    // The caller wants the offset to always win ('use') OR the caller is OK\n    // with the offset winning ('prefer' or 'reject') as long as it's valid\n    // for this timezone and date/time.\n    if (offsetBehaviour === 'exact' || offsetOpt === 'use') {\n        // Calculate the instant for the input's date/time and offset\n        const epochNs = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n        if (epochNs === null)\n            throw new RangeError('ZonedDateTime outside of supported range');\n        return JSBI.subtract(epochNs, JSBI.BigInt(offsetNs));\n    }\n    // \"prefer\" or \"reject\"\n    const possibleInstants = GetPossibleInstantsFor(timeZone, dt);\n    for (const candidate of possibleInstants) {\n        const candidateOffset = GetOffsetNanosecondsFor(timeZone, candidate);\n        const roundedCandidateOffset = JSBI.toNumber(RoundNumberToIncrement(JSBI.BigInt(candidateOffset), 60e9, 'halfExpand'));\n        if (candidateOffset === offsetNs || (matchMinute && roundedCandidateOffset === offsetNs)) {\n            return GetSlot(candidate, EPOCHNANOSECONDS);\n        }\n    }\n    // the user-provided offset doesn't match any instants for this time\n    // zone and date/time.\n    if (offsetOpt === 'reject') {\n        const offsetStr = FormatTimeZoneOffsetString(offsetNs);\n        const timeZoneString = IsTemporalTimeZone(timeZone) ? GetSlot(timeZone, TIMEZONE_ID) : 'time zone';\n        // The tsc emit for this line rewrites to invoke the PlainDateTime's valueOf method, NOT\n        // toString (which is invoked by Node when using template literals directly).\n        // See https://github.com/microsoft/TypeScript/issues/39744 for the proposed fix in tsc emit\n        throw new RangeError(`Offset ${offsetStr} is invalid for ${dt.toString()} in ${timeZoneString}`);\n    }\n    // fall through: offsetOpt === 'prefer', but the offset doesn't match\n    // so fall back to use the time zone instead.\n    const instant = DisambiguatePossibleInstants(possibleInstants, timeZone, dt, disambiguation);\n    return GetSlot(instant, EPOCHNANOSECONDS);\n}\nexport function ToTemporalZonedDateTime(item, options) {\n    let year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, timeZone, offset, calendar;\n    let matchMinute = false;\n    let offsetBehaviour = 'option';\n    if (IsObject(item)) {\n        if (IsTemporalZonedDateTime(item))\n            return item;\n        calendar = GetTemporalCalendarWithISODefault(item);\n        const fieldNames = CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fieldNamesWithTzAndOffset = ArrayPush(fieldNames, 'timeZone', 'offset');\n        const fields = PrepareTemporalFields(item, fieldNamesWithTzAndOffset, ['timeZone']);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = InterpretTemporalDateTimeFields(calendar, fields, options));\n        timeZone = ToTemporalTimeZone(fields.timeZone);\n        offset = fields.offset;\n        if (offset === undefined) {\n            offsetBehaviour = 'wall';\n        }\n        else {\n            offset = ToString(offset);\n        }\n    }\n    else {\n        ToTemporalOverflow(options); // validate and ignore\n        let ianaName, z;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, ianaName, offset, z, calendar } =\n            ParseTemporalZonedDateTimeString(ToString(item)));\n        if (!ianaName)\n            throw new RangeError('time zone ID required in brackets');\n        if (z) {\n            offsetBehaviour = 'exact';\n        }\n        else if (!offset) {\n            offsetBehaviour = 'wall';\n        }\n        const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n        timeZone = new TemporalTimeZone(ianaName);\n        if (!calendar)\n            calendar = GetISO8601Calendar();\n        calendar = ToTemporalCalendar(calendar);\n        matchMinute = true; // ISO strings may specify offset with less precision\n    }\n    let offsetNs = 0;\n    // The code above guarantees that if offsetBehaviour === 'option', then\n    // `offset` is not undefined.\n    if (offsetBehaviour === 'option')\n        offsetNs = ParseTimeZoneOffsetString(offset);\n    const disambiguation = ToTemporalDisambiguation(options);\n    const offsetOpt = ToTemporalOffset(options, 'reject');\n    const epochNanoseconds = InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, offsetBehaviour, offsetNs, timeZone, disambiguation, offsetOpt, matchMinute);\n    return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\nexport function CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar) {\n    RejectISODate(isoYear, isoMonth, isoDay);\n    RejectDateRange(isoYear, isoMonth, isoDay);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, DATE_BRAND, true);\n    if (DEBUG) {\n        ObjectDefineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalDateToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalDate(isoYear, isoMonth, isoDay, calendar = GetISO8601Calendar()) {\n    const TemporalPlainDate = GetIntrinsic('%Temporal.PlainDate%');\n    const result = ObjectCreate(TemporalPlainDate.prototype);\n    CreateTemporalDateSlots(result, isoYear, isoMonth, isoDay, calendar);\n    return result;\n}\nexport function CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns, calendar) {\n    RejectDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns);\n    RejectDateTimeRange(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, ISO_HOUR, h);\n    SetSlot(result, ISO_MINUTE, min);\n    SetSlot(result, ISO_SECOND, s);\n    SetSlot(result, ISO_MILLISECOND, ms);\n    SetSlot(result, ISO_MICROSECOND, µs);\n    SetSlot(result, ISO_NANOSECOND, ns);\n    SetSlot(result, CALENDAR, calendar);\n    if (DEBUG) {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalDateTimeToString(result, 'auto')}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalDateTime(isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns, calendar = GetISO8601Calendar()) {\n    const TemporalPlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    const result = ObjectCreate(TemporalPlainDateTime.prototype);\n    CreateTemporalDateTimeSlots(result, isoYear, isoMonth, isoDay, h, min, s, ms, µs, ns, calendar);\n    return result;\n}\nexport function CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear) {\n    RejectISODate(referenceISOYear, isoMonth, isoDay);\n    RejectDateRange(referenceISOYear, isoMonth, isoDay);\n    CreateSlots(result);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, isoDay);\n    SetSlot(result, ISO_YEAR, referenceISOYear);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, MONTH_DAY_BRAND, true);\n    if (DEBUG) {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalMonthDayToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalMonthDay(isoMonth, isoDay, calendar = GetISO8601Calendar(), referenceISOYear = 1972) {\n    const TemporalPlainMonthDay = GetIntrinsic('%Temporal.PlainMonthDay%');\n    const result = ObjectCreate(TemporalPlainMonthDay.prototype);\n    CreateTemporalMonthDaySlots(result, isoMonth, isoDay, calendar, referenceISOYear);\n    return result;\n}\nexport function CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay) {\n    RejectISODate(isoYear, isoMonth, referenceISODay);\n    RejectYearMonthRange(isoYear, isoMonth);\n    CreateSlots(result);\n    SetSlot(result, ISO_YEAR, isoYear);\n    SetSlot(result, ISO_MONTH, isoMonth);\n    SetSlot(result, ISO_DAY, referenceISODay);\n    SetSlot(result, CALENDAR, calendar);\n    SetSlot(result, YEAR_MONTH_BRAND, true);\n    if (DEBUG) {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalYearMonthToString(result)}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalYearMonth(isoYear, isoMonth, calendar = GetISO8601Calendar(), referenceISODay = 1) {\n    const TemporalPlainYearMonth = GetIntrinsic('%Temporal.PlainYearMonth%');\n    const result = ObjectCreate(TemporalPlainYearMonth.prototype);\n    CreateTemporalYearMonthSlots(result, isoYear, isoMonth, calendar, referenceISODay);\n    return result;\n}\nexport function CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar) {\n    ValidateEpochNanoseconds(epochNanoseconds);\n    CreateSlots(result);\n    SetSlot(result, EPOCHNANOSECONDS, epochNanoseconds);\n    SetSlot(result, TIME_ZONE, timeZone);\n    SetSlot(result, CALENDAR, calendar);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const instant = new TemporalInstant(GetSlot(result, EPOCHNANOSECONDS));\n    SetSlot(result, INSTANT, instant);\n    if (DEBUG) {\n        Object.defineProperty(result, '_repr_', {\n            value: `${result[Symbol.toStringTag]} <${TemporalZonedDateTimeToString(result, 'auto')}>`,\n            writable: false,\n            enumerable: false,\n            configurable: false\n        });\n    }\n}\nexport function CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar = GetISO8601Calendar()) {\n    const TemporalZonedDateTime = GetIntrinsic('%Temporal.ZonedDateTime%');\n    const result = ObjectCreate(TemporalZonedDateTime.prototype);\n    CreateTemporalZonedDateTimeSlots(result, epochNanoseconds, timeZone, calendar);\n    return result;\n}\nexport function GetISO8601Calendar() {\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    return new TemporalCalendar('iso8601');\n}\n// TODO: should (can?) we make this generic so the field names are checked\n// against the type that the calendar is a property of?\nexport function CalendarFields(calendar, fieldNamesParam) {\n    let fieldNames = fieldNamesParam;\n    if (calendar.fields) {\n        fieldNames = calendar.fields(fieldNames);\n    }\n    const result = [];\n    for (const name of fieldNames) {\n        if (typeof name !== 'string')\n            throw new TypeError('bad return from calendar.fields()');\n        ArrayPrototypePush.call(result, name);\n    }\n    return result;\n}\nexport function CalendarMergeFields(calendar, fields, additionalFields) {\n    const calMergeFields = calendar.mergeFields;\n    if (!calMergeFields) {\n        return { ...fields, ...additionalFields };\n    }\n    const result = Reflect.apply(calMergeFields, calendar, [fields, additionalFields]);\n    if (!IsObject(result))\n        throw new TypeError('bad return from calendar.mergeFields()');\n    return result;\n}\nexport function CalendarDateAdd(calendar, date, duration, options, dateAddParam) {\n    let dateAdd = dateAddParam;\n    if (dateAdd === undefined) {\n        dateAdd = calendar.dateAdd;\n    }\n    const result = ReflectApply(dateAdd, calendar, [date, duration, options]);\n    if (!IsTemporalDate(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nfunction CalendarDateUntil(calendar, date, otherDate, options, dateUntilParam) {\n    let dateUntil = dateUntilParam;\n    if (dateUntil === undefined) {\n        dateUntil = calendar.dateUntil;\n    }\n    const result = ReflectApply(dateUntil, calendar, [date, otherDate, options]);\n    if (!IsTemporalDuration(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function CalendarYear(calendar, dateLike) {\n    const result = calendar.year(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar year result must be an integer');\n    }\n    return ToIntegerThrowOnInfinity(result);\n}\nexport function CalendarMonth(calendar, dateLike) {\n    const result = calendar.month(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar month result must be a positive integer');\n    }\n    return ToPositiveInteger(result);\n}\nexport function CalendarMonthCode(calendar, dateLike) {\n    const result = calendar.monthCode(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar monthCode result must be a string');\n    }\n    return ToString(result);\n}\nexport function CalendarDay(calendar, dateLike) {\n    const result = calendar.day(dateLike);\n    if (result === undefined) {\n        throw new RangeError('calendar day result must be a positive integer');\n    }\n    return ToPositiveInteger(result);\n}\nexport function CalendarEra(calendar, dateLike) {\n    let result = calendar.era(dateLike);\n    if (result !== undefined) {\n        result = ToString(result);\n    }\n    return result;\n}\nexport function CalendarEraYear(calendar, dateLike) {\n    let result = calendar.eraYear(dateLike);\n    if (result !== undefined) {\n        result = ToIntegerThrowOnInfinity(result);\n    }\n    return result;\n}\nexport function CalendarDayOfWeek(calendar, dateLike) {\n    return calendar.dayOfWeek(dateLike);\n}\nexport function CalendarDayOfYear(calendar, dateLike) {\n    return calendar.dayOfYear(dateLike);\n}\nexport function CalendarWeekOfYear(calendar, dateLike) {\n    return calendar.weekOfYear(dateLike);\n}\nexport function CalendarDaysInWeek(calendar, dateLike) {\n    return calendar.daysInWeek(dateLike);\n}\nexport function CalendarDaysInMonth(calendar, dateLike) {\n    return calendar.daysInMonth(dateLike);\n}\nexport function CalendarDaysInYear(calendar, dateLike) {\n    return calendar.daysInYear(dateLike);\n}\nexport function CalendarMonthsInYear(calendar, dateLike) {\n    return calendar.monthsInYear(dateLike);\n}\nexport function CalendarInLeapYear(calendar, dateLike) {\n    return calendar.inLeapYear(dateLike);\n}\nexport function ToTemporalCalendar(calendarLikeParam) {\n    let calendarLike = calendarLikeParam;\n    if (IsObject(calendarLike)) {\n        if (HasSlot(calendarLike, CALENDAR))\n            return GetSlot(calendarLike, CALENDAR);\n        if (!('calendar' in calendarLike))\n            return calendarLike;\n        calendarLike = calendarLike.calendar;\n        if (IsObject(calendarLike) && !('calendar' in calendarLike))\n            return calendarLike;\n    }\n    const identifier = ToString(calendarLike);\n    const TemporalCalendar = GetIntrinsic('%Temporal.Calendar%');\n    if (IsBuiltinCalendar(identifier))\n        return new TemporalCalendar(identifier);\n    let calendar;\n    try {\n        ({ calendar } = ParseISODateTime(identifier));\n    }\n    catch {\n        throw new RangeError(`Invalid calendar: ${identifier}`);\n    }\n    if (!calendar)\n        calendar = 'iso8601';\n    return new TemporalCalendar(calendar);\n}\nfunction GetTemporalCalendarWithISODefault(item) {\n    if (HasSlot(item, CALENDAR))\n        return GetSlot(item, CALENDAR);\n    const { calendar } = item;\n    if (calendar === undefined)\n        return GetISO8601Calendar();\n    return ToTemporalCalendar(calendar);\n}\nexport function CalendarEquals(one, two) {\n    if (one === two)\n        return true;\n    const cal1 = ToString(one);\n    const cal2 = ToString(two);\n    return cal1 === cal2;\n}\nexport function ConsolidateCalendars(one, two) {\n    if (one === two)\n        return two;\n    const sOne = ToString(one);\n    const sTwo = ToString(two);\n    if (sOne === sTwo || sOne === 'iso8601') {\n        return two;\n    }\n    else if (sTwo === 'iso8601') {\n        return one;\n    }\n    else {\n        throw new RangeError('irreconcilable calendars');\n    }\n}\nexport function CalendarDateFromFields(calendar, fields, options) {\n    const result = calendar.dateFromFields(fields, options);\n    if (!IsTemporalDate(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function CalendarYearMonthFromFields(calendar, fields, options) {\n    const result = calendar.yearMonthFromFields(fields, options);\n    if (!IsTemporalYearMonth(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function CalendarMonthDayFromFields(calendar, fields, options) {\n    const result = calendar.monthDayFromFields(fields, options);\n    if (!IsTemporalMonthDay(result))\n        throw new TypeError('invalid result');\n    return result;\n}\nexport function ToTemporalTimeZone(temporalTimeZoneLikeParam) {\n    let temporalTimeZoneLike = temporalTimeZoneLikeParam;\n    if (IsObject(temporalTimeZoneLike)) {\n        if (IsTemporalZonedDateTime(temporalTimeZoneLike))\n            return GetSlot(temporalTimeZoneLike, TIME_ZONE);\n        if (!('timeZone' in temporalTimeZoneLike))\n            return temporalTimeZoneLike;\n        temporalTimeZoneLike = temporalTimeZoneLike.timeZone;\n        if (IsObject(temporalTimeZoneLike) && !('timeZone' in temporalTimeZoneLike)) {\n            return temporalTimeZoneLike;\n        }\n    }\n    const identifier = ToString(temporalTimeZoneLike);\n    const timeZone = ParseTemporalTimeZone(identifier);\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    return new TemporalTimeZone(timeZone);\n}\nexport function TimeZoneEquals(one, two) {\n    if (one === two)\n        return true;\n    const tz1 = ToString(one);\n    const tz2 = ToString(two);\n    return tz1 === tz2;\n}\nexport function TemporalDateTimeToDate(dateTime) {\n    return CreateTemporalDate(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, CALENDAR));\n}\nexport function TemporalDateTimeToTime(dateTime) {\n    const Time = GetIntrinsic('%Temporal.PlainTime%');\n    return new Time(GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n}\nexport function GetOffsetNanosecondsFor(timeZone, instant) {\n    let getOffsetNanosecondsFor = timeZone.getOffsetNanosecondsFor;\n    if (typeof getOffsetNanosecondsFor !== 'function') {\n        throw new TypeError('getOffsetNanosecondsFor not callable');\n    }\n    const offsetNs = Reflect.apply(getOffsetNanosecondsFor, timeZone, [instant]);\n    if (typeof offsetNs !== 'number') {\n        throw new TypeError('bad return from getOffsetNanosecondsFor');\n    }\n    if (!IsInteger(offsetNs) || MathAbs(offsetNs) > 86400e9) {\n        throw new RangeError('out-of-range return from getOffsetNanosecondsFor');\n    }\n    return offsetNs;\n}\nexport function BuiltinTimeZoneGetOffsetStringFor(timeZone, instant) {\n    const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n    return FormatTimeZoneOffsetString(offsetNs);\n}\nexport function BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar) {\n    const ns = GetSlot(instant, EPOCHNANOSECONDS);\n    const offsetNs = GetOffsetNanosecondsFor(timeZone, instant);\n    let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(ns);\n    ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond + offsetNs));\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\nexport function BuiltinTimeZoneGetInstantFor(timeZone, dateTime, disambiguation) {\n    const possibleInstants = GetPossibleInstantsFor(timeZone, dateTime);\n    return DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation);\n}\nfunction DisambiguatePossibleInstants(possibleInstants, timeZone, dateTime, disambiguation) {\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    const numInstants = possibleInstants.length;\n    if (numInstants === 1)\n        return possibleInstants[0];\n    if (numInstants) {\n        switch (disambiguation) {\n            case 'compatible':\n            // fall through because 'compatible' means 'earlier' for \"fall back\" transitions\n            case 'earlier':\n                return possibleInstants[0];\n            case 'later':\n                return possibleInstants[numInstants - 1];\n            case 'reject': {\n                throw new RangeError('multiple instants found');\n            }\n        }\n    }\n    const year = GetSlot(dateTime, ISO_YEAR);\n    const month = GetSlot(dateTime, ISO_MONTH);\n    const day = GetSlot(dateTime, ISO_DAY);\n    const hour = GetSlot(dateTime, ISO_HOUR);\n    const minute = GetSlot(dateTime, ISO_MINUTE);\n    const second = GetSlot(dateTime, ISO_SECOND);\n    const millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n    const microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n    const nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n    const utcns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (utcns === null)\n        throw new RangeError('DateTime outside of supported range');\n    const dayBefore = new Instant(JSBI.subtract(utcns, DAY_NANOS));\n    const dayAfter = new Instant(JSBI.add(utcns, DAY_NANOS));\n    const offsetBefore = GetOffsetNanosecondsFor(timeZone, dayBefore);\n    const offsetAfter = GetOffsetNanosecondsFor(timeZone, dayAfter);\n    const nanoseconds = offsetAfter - offsetBefore;\n    switch (disambiguation) {\n        case 'earlier': {\n            const calendar = GetSlot(dateTime, CALENDAR);\n            const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n            const earlier = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, -nanoseconds, undefined);\n            const earlierPlainDateTime = new PlainDateTime(earlier.year, earlier.month, earlier.day, earlier.hour, earlier.minute, earlier.second, earlier.millisecond, earlier.microsecond, earlier.nanosecond, calendar);\n            return GetPossibleInstantsFor(timeZone, earlierPlainDateTime)[0];\n        }\n        case 'compatible':\n        // fall through because 'compatible' means 'later' for \"spring forward\" transitions\n        case 'later': {\n            const calendar = GetSlot(dateTime, CALENDAR);\n            const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n            const later = AddDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar, 0, 0, 0, 0, 0, 0, 0, 0, 0, nanoseconds, undefined);\n            const laterPlainDateTime = new PlainDateTime(later.year, later.month, later.day, later.hour, later.minute, later.second, later.millisecond, later.microsecond, later.nanosecond, calendar);\n            const possible = GetPossibleInstantsFor(timeZone, laterPlainDateTime);\n            return possible[possible.length - 1];\n        }\n        case 'reject': {\n            throw new RangeError('no such instant found');\n        }\n    }\n}\nfunction GetPossibleInstantsFor(timeZone, dateTime) {\n    const possibleInstants = timeZone.getPossibleInstantsFor(dateTime);\n    const result = [];\n    for (const instant of possibleInstants) {\n        if (!IsTemporalInstant(instant)) {\n            throw new TypeError('bad return from getPossibleInstantsFor');\n        }\n        ArrayPrototypePush.call(result, instant);\n    }\n    return result;\n}\nexport function ISOYearString(year) {\n    let yearString;\n    if (year < 0 || year > 9999) {\n        const sign = year < 0 ? '-' : '+';\n        const yearNumber = MathAbs(year);\n        yearString = sign + `000000${yearNumber}`.slice(-6);\n    }\n    else {\n        yearString = `0000${year}`.slice(-4);\n    }\n    return yearString;\n}\nexport function ISODateTimePartString(part) {\n    return `00${part}`.slice(-2);\n}\nexport function FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision) {\n    if (precision === 'minute')\n        return '';\n    const secs = `:${ISODateTimePartString(second)}`;\n    let fractionNumber = millisecond * 1e6 + microsecond * 1e3 + nanosecond;\n    let fraction;\n    if (precision === 'auto') {\n        if (fractionNumber === 0)\n            return secs;\n        fraction = `${fractionNumber}`.padStart(9, '0');\n        while (fraction[fraction.length - 1] === '0')\n            fraction = fraction.slice(0, -1);\n    }\n    else {\n        if (precision === 0)\n            return secs;\n        fraction = `${fractionNumber}`.padStart(9, '0').slice(0, precision);\n    }\n    return `${secs}.${fraction}`;\n}\nexport function TemporalInstantToString(instant, timeZone, precision) {\n    let outputTimeZone = timeZone;\n    if (outputTimeZone === undefined) {\n        const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n        outputTimeZone = new TemporalTimeZone('UTC');\n    }\n    const iso = GetISO8601Calendar();\n    const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(outputTimeZone, instant, iso);\n    const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n    const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n    const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n    const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n    let timeZoneString = 'Z';\n    if (timeZone !== undefined) {\n        const offsetNs = GetOffsetNanosecondsFor(outputTimeZone, instant);\n        timeZoneString = FormatISOTimeZoneOffsetString(offsetNs);\n    }\n    return `${year}-${month}-${day}T${hour}:${minute}${seconds}${timeZoneString}`;\n}\nexport function TemporalDurationToString(duration, precision = 'auto', options = undefined) {\n    function formatNumber(num) {\n        if (num <= NumberMaxSafeInteger)\n            return num.toString(10);\n        return JSBI.BigInt(num).toString(10);\n    }\n    const years = GetSlot(duration, YEARS);\n    const months = GetSlot(duration, MONTHS);\n    const weeks = GetSlot(duration, WEEKS);\n    const days = GetSlot(duration, DAYS);\n    const hours = GetSlot(duration, HOURS);\n    const minutes = GetSlot(duration, MINUTES);\n    let seconds = GetSlot(duration, SECONDS);\n    let ms = GetSlot(duration, MILLISECONDS);\n    let µs = GetSlot(duration, MICROSECONDS);\n    let ns = GetSlot(duration, NANOSECONDS);\n    const sign = DurationSign(years, months, weeks, days, hours, minutes, seconds, ms, µs, ns);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({\n            seconds,\n            milliseconds: ms,\n            microseconds: µs,\n            nanoseconds: ns\n        } = RoundDuration(0, 0, 0, 0, 0, 0, seconds, ms, µs, ns, increment, unit, roundingMode));\n    }\n    const dateParts = [];\n    if (years)\n        dateParts.push(`${formatNumber(MathAbs(years))}Y`);\n    if (months)\n        dateParts.push(`${formatNumber(MathAbs(months))}M`);\n    if (weeks)\n        dateParts.push(`${formatNumber(MathAbs(weeks))}W`);\n    if (days)\n        dateParts.push(`${formatNumber(MathAbs(days))}D`);\n    const timeParts = [];\n    if (hours)\n        timeParts.push(`${formatNumber(MathAbs(hours))}H`);\n    if (minutes)\n        timeParts.push(`${formatNumber(MathAbs(minutes))}M`);\n    const secondParts = [];\n    let total = TotalDurationNanoseconds(0, 0, 0, seconds, ms, µs, ns, 0);\n    let nsBigInt, µsBigInt, msBigInt, secondsBigInt;\n    ({ quotient: total, remainder: nsBigInt } = divmod(total, THOUSAND));\n    ({ quotient: total, remainder: µsBigInt } = divmod(total, THOUSAND));\n    ({ quotient: secondsBigInt, remainder: msBigInt } = divmod(total, THOUSAND));\n    const fraction = MathAbs(JSBI.toNumber(msBigInt)) * 1e6 + MathAbs(JSBI.toNumber(µsBigInt)) * 1e3 + MathAbs(JSBI.toNumber(nsBigInt));\n    let decimalPart;\n    if (precision === 'auto') {\n        if (fraction !== 0) {\n            decimalPart = `${fraction}`.padStart(9, '0');\n            while (decimalPart[decimalPart.length - 1] === '0') {\n                decimalPart = decimalPart.slice(0, -1);\n            }\n        }\n    }\n    else if (precision !== 0) {\n        decimalPart = `${fraction}`.padStart(9, '0').slice(0, precision);\n    }\n    if (decimalPart)\n        secondParts.unshift('.', decimalPart);\n    if (!JSBI.equal(secondsBigInt, ZERO) || secondParts.length || precision !== 'auto') {\n        secondParts.unshift(abs(secondsBigInt).toString());\n    }\n    if (secondParts.length)\n        timeParts.push(`${secondParts.join('')}S`);\n    if (timeParts.length)\n        timeParts.unshift('T');\n    if (!dateParts.length && !timeParts.length)\n        return 'PT0S';\n    return `${sign < 0 ? '-' : ''}P${dateParts.join('')}${timeParts.join('')}`;\n}\nexport function TemporalDateToString(date, showCalendar = 'auto') {\n    const year = ISOYearString(GetSlot(date, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(date, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(date, ISO_DAY));\n    const calendarID = ToString(GetSlot(date, CALENDAR));\n    const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n    return `${year}-${month}-${day}${calendar}`;\n}\nexport function TemporalDateTimeToString(dateTime, precision, showCalendar = 'auto', options = undefined) {\n    let year = GetSlot(dateTime, ISO_YEAR);\n    let month = GetSlot(dateTime, ISO_MONTH);\n    let day = GetSlot(dateTime, ISO_DAY);\n    let hour = GetSlot(dateTime, ISO_HOUR);\n    let minute = GetSlot(dateTime, ISO_MINUTE);\n    let second = GetSlot(dateTime, ISO_SECOND);\n    let millisecond = GetSlot(dateTime, ISO_MILLISECOND);\n    let microsecond = GetSlot(dateTime, ISO_MICROSECOND);\n    let nanosecond = GetSlot(dateTime, ISO_NANOSECOND);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n    }\n    const yearString = ISOYearString(year);\n    const monthString = ISODateTimePartString(month);\n    const dayString = ISODateTimePartString(day);\n    const hourString = ISODateTimePartString(hour);\n    const minuteString = ISODateTimePartString(minute);\n    const secondsString = FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n    const calendarID = ToString(GetSlot(dateTime, CALENDAR));\n    const calendar = FormatCalendarAnnotation(calendarID, showCalendar);\n    return `${yearString}-${monthString}-${dayString}T${hourString}:${minuteString}${secondsString}${calendar}`;\n}\nexport function TemporalMonthDayToString(monthDay, showCalendar = 'auto') {\n    const month = ISODateTimePartString(GetSlot(monthDay, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(monthDay, ISO_DAY));\n    let resultString = `${month}-${day}`;\n    const calendar = GetSlot(monthDay, CALENDAR);\n    const calendarID = ToString(calendar);\n    if (showCalendar === 'always' || calendarID !== 'iso8601') {\n        const year = ISOYearString(GetSlot(monthDay, ISO_YEAR));\n        resultString = `${year}-${resultString}`;\n    }\n    const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n    if (calendarString)\n        resultString += calendarString;\n    return resultString;\n}\nexport function TemporalYearMonthToString(yearMonth, showCalendar = 'auto') {\n    const year = ISOYearString(GetSlot(yearMonth, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(yearMonth, ISO_MONTH));\n    let resultString = `${year}-${month}`;\n    const calendar = GetSlot(yearMonth, CALENDAR);\n    const calendarID = ToString(calendar);\n    if (showCalendar === 'always' || calendarID !== 'iso8601') {\n        const day = ISODateTimePartString(GetSlot(yearMonth, ISO_DAY));\n        resultString += `-${day}`;\n    }\n    const calendarString = FormatCalendarAnnotation(calendarID, showCalendar);\n    if (calendarString)\n        resultString += calendarString;\n    return resultString;\n}\nexport function TemporalZonedDateTimeToString(zdt, precision, showCalendar = 'auto', showTimeZone = 'auto', showOffset = 'auto', options = undefined) {\n    let instant = GetSlot(zdt, INSTANT);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        const ns = RoundInstant(GetSlot(zdt, EPOCHNANOSECONDS), increment, unit, roundingMode);\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        instant = new TemporalInstant(ns);\n    }\n    const tz = GetSlot(zdt, TIME_ZONE);\n    const iso = GetISO8601Calendar();\n    const dateTime = BuiltinTimeZoneGetPlainDateTimeFor(tz, instant, iso);\n    const year = ISOYearString(GetSlot(dateTime, ISO_YEAR));\n    const month = ISODateTimePartString(GetSlot(dateTime, ISO_MONTH));\n    const day = ISODateTimePartString(GetSlot(dateTime, ISO_DAY));\n    const hour = ISODateTimePartString(GetSlot(dateTime, ISO_HOUR));\n    const minute = ISODateTimePartString(GetSlot(dateTime, ISO_MINUTE));\n    const seconds = FormatSecondsStringPart(GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), precision);\n    let result = `${year}-${month}-${day}T${hour}:${minute}${seconds}`;\n    if (showOffset !== 'never') {\n        const offsetNs = GetOffsetNanosecondsFor(tz, instant);\n        result += FormatISOTimeZoneOffsetString(offsetNs);\n    }\n    if (showTimeZone !== 'never')\n        result += `[${tz}]`;\n    const calendarID = ToString(GetSlot(zdt, CALENDAR));\n    result += FormatCalendarAnnotation(calendarID, showCalendar);\n    return result;\n}\nexport function TestTimeZoneOffsetString(string) {\n    return OFFSET.test(StringCtor(string));\n}\nexport function ParseTimeZoneOffsetString(string) {\n    const match = OFFSET.exec(StringCtor(string));\n    if (!match) {\n        throw new RangeError(`invalid time zone offset: ${string}`);\n    }\n    const sign = match[1] === '-' || match[1] === '\\u2212' ? -1 : +1;\n    const hours = +match[2];\n    const minutes = +(match[3] || 0);\n    const seconds = +(match[4] || 0);\n    const nanoseconds = +((match[5] || 0) + '000000000').slice(0, 9);\n    return sign * (((hours * 60 + minutes) * 60 + seconds) * 1e9 + nanoseconds);\n}\nexport function GetCanonicalTimeZoneIdentifier(timeZoneIdentifier) {\n    if (TestTimeZoneOffsetString(timeZoneIdentifier)) {\n        const offsetNs = ParseTimeZoneOffsetString(timeZoneIdentifier);\n        return FormatTimeZoneOffsetString(offsetNs);\n    }\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(StringCtor(timeZoneIdentifier));\n    return formatter.resolvedOptions().timeZone;\n}\nexport function GetIANATimeZoneOffsetNanoseconds(epochNanoseconds, id) {\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n    const utc = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (utc === null)\n        throw new RangeError('Date outside of supported range');\n    return JSBI.toNumber(JSBI.subtract(utc, epochNanoseconds));\n}\nfunction FormatTimeZoneOffsetString(offsetNanosecondsParam) {\n    const sign = offsetNanosecondsParam < 0 ? '-' : '+';\n    const offsetNanoseconds = MathAbs(offsetNanosecondsParam);\n    const nanoseconds = offsetNanoseconds % 1e9;\n    const seconds = MathFloor(offsetNanoseconds / 1e9) % 60;\n    const minutes = MathFloor(offsetNanoseconds / 60e9) % 60;\n    const hours = MathFloor(offsetNanoseconds / 3600e9);\n    const hourString = ISODateTimePartString(hours);\n    const minuteString = ISODateTimePartString(minutes);\n    const secondString = ISODateTimePartString(seconds);\n    let post = '';\n    if (nanoseconds) {\n        let fraction = `${nanoseconds}`.padStart(9, '0');\n        while (fraction[fraction.length - 1] === '0')\n            fraction = fraction.slice(0, -1);\n        post = `:${secondString}.${fraction}`;\n    }\n    else if (seconds) {\n        post = `:${secondString}`;\n    }\n    return `${sign}${hourString}:${minuteString}${post}`;\n}\nfunction FormatISOTimeZoneOffsetString(offsetNanosecondsParam) {\n    let offsetNanoseconds = JSBI.toNumber(RoundNumberToIncrement(JSBI.BigInt(offsetNanosecondsParam), 60e9, 'halfExpand'));\n    const sign = offsetNanoseconds < 0 ? '-' : '+';\n    offsetNanoseconds = MathAbs(offsetNanoseconds);\n    const minutes = (offsetNanoseconds / 60e9) % 60;\n    const hours = MathFloor(offsetNanoseconds / 3600e9);\n    const hourString = ISODateTimePartString(hours);\n    const minuteString = ISODateTimePartString(minutes);\n    return `${sign}${hourString}:${minuteString}`;\n}\nexport function GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    // Note: Date.UTC() interprets one and two-digit years as being in the\n    // 20th century, so don't use it\n    const legacyDate = new Date();\n    legacyDate.setUTCHours(hour, minute, second, millisecond);\n    legacyDate.setUTCFullYear(year, month - 1, day);\n    const ms = legacyDate.getTime();\n    if (NumberIsNaN(ms))\n        return null;\n    let ns = JSBI.multiply(JSBI.BigInt(ms), MILLION);\n    ns = JSBI.add(ns, JSBI.multiply(JSBI.BigInt(microsecond), THOUSAND));\n    ns = JSBI.add(ns, JSBI.BigInt(nanosecond));\n    if (JSBI.lessThan(ns, NS_MIN) || JSBI.greaterThan(ns, NS_MAX))\n        return null;\n    return ns;\n}\nfunction GetISOPartsFromEpoch(epochNanoseconds) {\n    const { quotient, remainder } = divmod(epochNanoseconds, MILLION);\n    let epochMilliseconds = JSBI.toNumber(quotient);\n    let nanos = JSBI.toNumber(remainder);\n    if (nanos < 0) {\n        nanos += 1e6;\n        epochMilliseconds -= 1;\n    }\n    const microsecond = MathFloor(nanos / 1e3) % 1e3;\n    const nanosecond = nanos % 1e3;\n    const item = new Date(epochMilliseconds);\n    const year = item.getUTCFullYear();\n    const month = item.getUTCMonth() + 1;\n    const day = item.getUTCDate();\n    const hour = item.getUTCHours();\n    const minute = item.getUTCMinutes();\n    const second = item.getUTCSeconds();\n    const millisecond = item.getUTCMilliseconds();\n    return { epochMilliseconds, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetIANATimeZoneDateTimeParts(epochNanoseconds, id) {\n    const { epochMilliseconds, millisecond, microsecond, nanosecond } = GetISOPartsFromEpoch(epochNanoseconds);\n    const { year, month, day, hour, minute, second } = GetFormatterParts(id, epochMilliseconds);\n    return BalanceISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction maxJSBI(one, two) {\n    return JSBI.lessThan(one, two) ? two : one;\n}\n/**\n * Our best guess at how far in advance new rules will be put into the TZDB for\n * future offset transitions. We'll pick 10 years but can always revise it if\n * we find that countries are being unusually proactive in their announcing\n * of offset changes.\n */\nfunction afterLatestPossibleTzdbRuleChange() {\n    return JSBI.add(SystemUTCEpochNanoSeconds(), ABOUT_TEN_YEARS_NANOS);\n}\nexport function GetIANATimeZoneNextTransition(epochNanoseconds, id) {\n    // Decide how far in the future after `epochNanoseconds` we'll look for an\n    // offset change. There are two cases:\n    // 1. If it's a past date (or a date in the near future) then it's possible\n    //    that the time zone may have newly added DST in the next few years. So\n    //    we'll have to look from the provided time until a few years after the\n    //    current system time. (Changes to DST policy are usually announced a few\n    //    years in the future.) Note that the first DST anywhere started in 1847,\n    //    so we'll start checks in 1847 instead of wasting cycles on years where\n    //    there will never be transitions.\n    // 2. If it's a future date beyond the next few years, then we'll just assume\n    //    that the latest DST policy in TZDB will still be in effect.  In this\n    //    case, we only need to look one year in the future to see if there are\n    //    any DST transitions.  We actually only need to look 9-10 months because\n    //    DST has two transitions per year, but we'll use a year just to be safe.\n    const oneYearLater = JSBI.add(epochNanoseconds, ABOUT_ONE_YEAR_NANOS);\n    const uppercap = maxJSBI(afterLatestPossibleTzdbRuleChange(), oneYearLater);\n    // The first transition (in any timezone) recorded in the TZDB was in 1847, so\n    // start there if an earlier date is supplied.\n    let leftNanos = maxJSBI(BEFORE_FIRST_OFFSET_TRANSITION, epochNanoseconds);\n    const leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n    let rightNanos = leftNanos;\n    let rightOffsetNs = leftOffsetNs;\n    while (leftOffsetNs === rightOffsetNs && JSBI.lessThan(JSBI.BigInt(leftNanos), uppercap)) {\n        rightNanos = JSBI.add(leftNanos, TWO_WEEKS_NANOS);\n        rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n        if (leftOffsetNs === rightOffsetNs) {\n            leftNanos = rightNanos;\n        }\n    }\n    if (leftOffsetNs === rightOffsetNs)\n        return null;\n    const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n}\nexport function GetIANATimeZonePreviousTransition(epochNanoseconds, id) {\n    // If a time zone uses DST (at the time of `epochNanoseconds`), then we only\n    // have to look back one year to find a transition. But if it doesn't use DST,\n    // then we need to look all the way back to 1847 (the earliest rule in the\n    // TZDB) to see if it had other offset transitions in the past. Looping back\n    // from a far-future date to 1847 is very slow (minutes of 100% CPU!), and is\n    // also unnecessary because DST rules aren't put into the TZDB more than a few\n    // years in the future because the political changes in time zones happen with\n    // only a few years' warning. Therefore, if a far-future date is provided,\n    // then we'll run the check in two parts:\n    // 1. First, we'll look back for up to one year to see if the latest TZDB\n    //    rules have DST.\n    // 2. If not, then we'll \"fast-reverse\" back to a few years later than the\n    //    current system time, and then look back to 1847. This reduces the\n    //    worst-case loop from 273K years to 175 years, for a ~1500x improvement\n    //    in worst-case perf.\n    const afterLatestRule = afterLatestPossibleTzdbRuleChange();\n    const isFarFuture = JSBI.greaterThan(epochNanoseconds, afterLatestRule);\n    const lowercap = isFarFuture ? JSBI.subtract(epochNanoseconds, ABOUT_ONE_YEAR_NANOS) : BEFORE_FIRST_OFFSET_TRANSITION;\n    let rightNanos = JSBI.subtract(epochNanoseconds, ONE);\n    const rightOffsetNs = GetIANATimeZoneOffsetNanoseconds(rightNanos, id);\n    let leftNanos = rightNanos;\n    let leftOffsetNs = rightOffsetNs;\n    while (rightOffsetNs === leftOffsetNs && JSBI.greaterThan(rightNanos, lowercap)) {\n        leftNanos = JSBI.subtract(rightNanos, TWO_WEEKS_NANOS);\n        leftOffsetNs = GetIANATimeZoneOffsetNanoseconds(leftNanos, id);\n        if (rightOffsetNs === leftOffsetNs) {\n            rightNanos = leftNanos;\n        }\n    }\n    if (rightOffsetNs === leftOffsetNs) {\n        if (isFarFuture) {\n            // There was no DST after looking back one year, which means that the most\n            // recent TZDB rules don't have any recurring transitions. To check for\n            // transitions in older rules, back up to a few years after the current\n            // date and then look all the way back to 1847. Note that we move back one\n            // day from the latest possible rule so that when the recursion runs it\n            // won't consider the new time to be \"far future\" because the system clock\n            // has advanced in the meantime.\n            const newTimeToCheck = JSBI.subtract(afterLatestRule, DAY_NANOS);\n            return GetIANATimeZonePreviousTransition(newTimeToCheck, id);\n        }\n        return null;\n    }\n    const result = bisect((epochNs) => GetIANATimeZoneOffsetNanoseconds(epochNs, id), leftNanos, rightNanos, leftOffsetNs, rightOffsetNs);\n    return result;\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function parseFromEnUsFormat(datetime) {\n    const parts = datetime.split(/[^\\w]+/);\n    if (parts.length !== 7) {\n        throw new RangeError(`expected 7 parts in \"${datetime}`);\n    }\n    const month = +parts[0];\n    const day = +parts[1];\n    let year = +parts[2];\n    const era = parts[3].toUpperCase();\n    if (era === 'B' || era === 'BC') {\n        year = -year + 1;\n    }\n    else if (era !== 'A' && era !== 'AD') {\n        throw new RangeError(`Unknown era ${era} in \"${datetime}`);\n    }\n    let hour = +parts[4];\n    if (hour === 24) {\n        // bugs.chromium.org/p/chromium/issues/detail?id=1045791\n        hour = 0;\n    }\n    const minute = +parts[5];\n    const second = +parts[6];\n    if (!NumberIsFinite(year) ||\n        !NumberIsFinite(month) ||\n        !NumberIsFinite(day) ||\n        !NumberIsFinite(hour) ||\n        !NumberIsFinite(minute) ||\n        !NumberIsFinite(second)) {\n        throw new RangeError(`Invalid number in \"${datetime}`);\n    }\n    return { year, month, day, hour, minute, second };\n}\n// ts-prune-ignore-next TODO: remove this after tests are converted to TS\nexport function GetFormatterParts(timeZone, epochMilliseconds) {\n    const formatter = getIntlDateTimeFormatEnUsForTimeZone(timeZone);\n    // Using `format` instead of `formatToParts` for compatibility with older clients\n    const datetime = formatter.format(new Date(epochMilliseconds));\n    return parseFromEnUsFormat(datetime);\n}\nexport function GetIANATimeZoneEpochValue(id, year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    const ns = GetEpochFromISOParts(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond);\n    if (ns === null)\n        throw new RangeError('DateTime outside of supported range');\n    let nsEarlier = JSBI.subtract(ns, DAY_NANOS);\n    if (JSBI.lessThan(nsEarlier, NS_MIN))\n        nsEarlier = ns;\n    let nsLater = JSBI.add(ns, DAY_NANOS);\n    if (JSBI.greaterThan(nsLater, NS_MAX))\n        nsLater = ns;\n    const earliest = GetIANATimeZoneOffsetNanoseconds(nsEarlier, id);\n    const latest = GetIANATimeZoneOffsetNanoseconds(nsLater, id);\n    const found = earliest === latest ? [earliest] : [earliest, latest];\n    return found\n        .map((offsetNanoseconds) => {\n        const epochNanoseconds = JSBI.subtract(ns, JSBI.BigInt(offsetNanoseconds));\n        const parts = GetIANATimeZoneDateTimeParts(epochNanoseconds, id);\n        if (year !== parts.year ||\n            month !== parts.month ||\n            day !== parts.day ||\n            hour !== parts.hour ||\n            minute !== parts.minute ||\n            second !== parts.second ||\n            millisecond !== parts.millisecond ||\n            microsecond !== parts.microsecond ||\n            nanosecond !== parts.nanosecond) {\n            return undefined;\n        }\n        return epochNanoseconds;\n    })\n        .filter((x) => x !== undefined);\n}\nexport function LeapYear(year) {\n    if (undefined === year)\n        return false;\n    const isDiv4 = year % 4 === 0;\n    const isDiv100 = year % 100 === 0;\n    const isDiv400 = year % 400 === 0;\n    return isDiv4 && (!isDiv100 || isDiv400);\n}\nexport function ISODaysInMonth(year, month) {\n    const DoM = {\n        standard: [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],\n        leapyear: [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]\n    };\n    return DoM[LeapYear(year) ? 'leapyear' : 'standard'][month - 1];\n}\nexport function DayOfWeek(year, month, day) {\n    const m = month + (month < 3 ? 10 : -2);\n    const Y = year - (month < 3 ? 1 : 0);\n    const c = MathFloor(Y / 100);\n    const y = Y - c * 100;\n    const d = day;\n    const pD = d;\n    const pM = MathFloor(2.6 * m - 0.2);\n    const pY = y + MathFloor(y / 4);\n    const pC = MathFloor(c / 4) - 2 * c;\n    const dow = (pD + pM + pY + pC) % 7;\n    return dow + (dow <= 0 ? 7 : 0);\n}\nexport function DayOfYear(year, month, day) {\n    let days = day;\n    for (let m = month - 1; m > 0; m--) {\n        days += ISODaysInMonth(year, m);\n    }\n    return days;\n}\nexport function WeekOfYear(year, month, day) {\n    const doy = DayOfYear(year, month, day);\n    const dow = DayOfWeek(year, month, day) || 7;\n    const doj = DayOfWeek(year, 1, 1);\n    const week = MathFloor((doy - dow + 10) / 7);\n    if (week < 1) {\n        if (doj === 5 || (doj === 6 && LeapYear(year - 1))) {\n            return 53;\n        }\n        else {\n            return 52;\n        }\n    }\n    if (week === 53) {\n        if ((LeapYear(year) ? 366 : 365) - doy < 4 - dow) {\n            return 1;\n        }\n    }\n    return week;\n}\nexport function DurationSign(y, mon, w, d, h, min, s, ms, µs, ns) {\n    for (const prop of [y, mon, w, d, h, min, s, ms, µs, ns]) {\n        if (prop !== 0)\n            return prop < 0 ? -1 : 1;\n    }\n    return 0;\n}\nfunction BalanceISOYearMonth(yearParam, monthParam) {\n    let year = yearParam;\n    let month = monthParam;\n    if (!NumberIsFinite(year) || !NumberIsFinite(month))\n        throw new RangeError('infinity is out of range');\n    month -= 1;\n    year += MathFloor(month / 12);\n    month %= 12;\n    if (month < 0)\n        month += 12;\n    month += 1;\n    return { year, month };\n}\nfunction BalanceISODate(yearParam, monthParam, dayParam) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    if (!NumberIsFinite(day))\n        throw new RangeError('infinity is out of range');\n    ({ year, month } = BalanceISOYearMonth(year, month));\n    let daysInYear = 0;\n    let testYear = month > 2 ? year : year - 1;\n    while (((daysInYear = LeapYear(testYear) ? 366 : 365), day < -daysInYear)) {\n        year -= 1;\n        testYear -= 1;\n        day += daysInYear;\n    }\n    testYear += 1;\n    while (((daysInYear = LeapYear(testYear) ? 366 : 365), day > daysInYear)) {\n        year += 1;\n        testYear += 1;\n        day -= daysInYear;\n    }\n    while (day < 1) {\n        ({ year, month } = BalanceISOYearMonth(year, month - 1));\n        day += ISODaysInMonth(year, month);\n    }\n    while (day > ISODaysInMonth(year, month)) {\n        day -= ISODaysInMonth(year, month);\n        ({ year, month } = BalanceISOYearMonth(year, month + 1));\n    }\n    return { year, month, day };\n}\nfunction BalanceISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam);\n    const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction BalanceTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    if (!NumberIsFinite(hour) ||\n        !NumberIsFinite(minute) ||\n        !NumberIsFinite(second) ||\n        !NumberIsFinite(millisecond) ||\n        !NumberIsFinite(microsecond) ||\n        !NumberIsFinite(nanosecond)) {\n        throw new RangeError('infinity is out of range');\n    }\n    microsecond += MathFloor(nanosecond / 1000);\n    nanosecond = NonNegativeModulo(nanosecond, 1000);\n    millisecond += MathFloor(microsecond / 1000);\n    microsecond = NonNegativeModulo(microsecond, 1000);\n    second += MathFloor(millisecond / 1000);\n    millisecond = NonNegativeModulo(millisecond, 1000);\n    minute += MathFloor(second / 60);\n    second = NonNegativeModulo(second, 60);\n    hour += MathFloor(minute / 60);\n    minute = NonNegativeModulo(minute, 60);\n    const deltaDays = MathFloor(hour / 24);\n    hour = NonNegativeModulo(hour, 24);\n    return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function TotalDurationNanoseconds(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, offsetShift) {\n    const days = JSBI.BigInt(daysParam);\n    let nanoseconds = JSBI.BigInt(nanosecondsParam);\n    if (daysParam !== 0)\n        nanoseconds = JSBI.subtract(JSBI.BigInt(nanosecondsParam), JSBI.BigInt(offsetShift));\n    const hours = JSBI.add(JSBI.BigInt(hoursParam), JSBI.multiply(days, JSBI.BigInt(24)));\n    const minutes = JSBI.add(JSBI.BigInt(minutesParam), JSBI.multiply(hours, SIXTY));\n    const seconds = JSBI.add(JSBI.BigInt(secondsParam), JSBI.multiply(minutes, SIXTY));\n    const milliseconds = JSBI.add(JSBI.BigInt(millisecondsParam), JSBI.multiply(seconds, THOUSAND));\n    const microseconds = JSBI.add(JSBI.BigInt(microsecondsParam), JSBI.multiply(milliseconds, THOUSAND));\n    return JSBI.add(JSBI.BigInt(nanoseconds), JSBI.multiply(microseconds, THOUSAND));\n}\nfunction NanosecondsToDays(nanosecondsParam, relativeTo) {\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const sign = MathSign(JSBI.toNumber(nanosecondsParam));\n    let nanoseconds = JSBI.BigInt(nanosecondsParam);\n    let dayLengthNs = 86400e9;\n    if (sign === 0)\n        return { days: 0, nanoseconds: ZERO, dayLengthNs };\n    if (!IsTemporalZonedDateTime(relativeTo)) {\n        let days;\n        ({ quotient: days, remainder: nanoseconds } = divmod(nanoseconds, JSBI.BigInt(dayLengthNs)));\n        return { days: JSBI.toNumber(days), nanoseconds, dayLengthNs };\n    }\n    const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n    const start = GetSlot(relativeTo, INSTANT);\n    const endNs = JSBI.add(startNs, nanoseconds);\n    const end = new TemporalInstant(endNs);\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    // Find the difference in days only.\n    const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n    const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n    let { days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, 'day', ObjectCreate(null));\n    let intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);\n    // may disambiguate\n    // If clock time after addition was in the middle of a skipped period, the\n    // endpoint was disambiguated to a later clock time. So it's possible that\n    // the resulting disambiguated result is later than endNs. If so, then back\n    // up one day and try again. Repeat if necessary (some transitions are\n    // > 24 hours) until either there's zero days left or the date duration is\n    // back inside the period where it belongs. Note that this case only can\n    // happen for positive durations because the only direction that\n    // `disambiguation: 'compatible'` can change clock time is forwards.\n    if (sign === 1) {\n        while (days > 0 && JSBI.greaterThan(intermediateNs, endNs)) {\n            --days;\n            intermediateNs = AddZonedDateTime(start, timeZone, calendar, 0, 0, 0, days, 0, 0, 0, 0, 0, 0);\n            // may do disambiguation\n        }\n    }\n    nanoseconds = JSBI.subtract(endNs, intermediateNs);\n    let isOverflow = false;\n    let relativeInstant = new TemporalInstant(intermediateNs);\n    do {\n        // calculate length of the next day (day that contains the time remainder)\n        const oneDayFartherNs = AddZonedDateTime(relativeInstant, timeZone, calendar, 0, 0, 0, sign, 0, 0, 0, 0, 0, 0);\n        const relativeNs = GetSlot(relativeInstant, EPOCHNANOSECONDS);\n        dayLengthNs = JSBI.toNumber(JSBI.subtract(oneDayFartherNs, relativeNs));\n        isOverflow = JSBI.greaterThan(JSBI.multiply(JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs)), JSBI.BigInt(sign)), ZERO);\n        if (isOverflow) {\n            nanoseconds = JSBI.subtract(nanoseconds, JSBI.BigInt(dayLengthNs));\n            relativeInstant = new TemporalInstant(oneDayFartherNs);\n            days += sign;\n        }\n    } while (isOverflow);\n    return { days, nanoseconds, dayLengthNs: MathAbs(dayLengthNs) };\n}\nexport function BalanceDuration(daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, largestUnit, relativeTo = undefined) {\n    let days = daysParam;\n    let nanosecondsBigInt, microsecondsBigInt, millisecondsBigInt, secondsBigInt, minutesBigInt, hoursBigInt;\n    if (IsTemporalZonedDateTime(relativeTo)) {\n        const endNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), GetSlot(relativeTo, TIME_ZONE), GetSlot(relativeTo, CALENDAR), 0, 0, 0, days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam);\n        const startNs = GetSlot(relativeTo, EPOCHNANOSECONDS);\n        nanosecondsBigInt = JSBI.subtract(endNs, startNs);\n    }\n    else {\n        nanosecondsBigInt = TotalDurationNanoseconds(days, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, 0);\n    }\n    if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week' || largestUnit === 'day') {\n        ({ days, nanoseconds: nanosecondsBigInt } = NanosecondsToDays(nanosecondsBigInt, relativeTo));\n    }\n    else {\n        days = 0;\n    }\n    const sign = JSBI.lessThan(nanosecondsBigInt, ZERO) ? -1 : 1;\n    nanosecondsBigInt = abs(nanosecondsBigInt);\n    microsecondsBigInt = millisecondsBigInt = secondsBigInt = minutesBigInt = hoursBigInt = ZERO;\n    switch (largestUnit) {\n        case 'year':\n        case 'month':\n        case 'week':\n        case 'day':\n        case 'hour':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n            ({ quotient: hoursBigInt, remainder: minutesBigInt } = divmod(minutesBigInt, SIXTY));\n            break;\n        case 'minute':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            ({ quotient: minutesBigInt, remainder: secondsBigInt } = divmod(secondsBigInt, SIXTY));\n            break;\n        case 'second':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            ({ quotient: secondsBigInt, remainder: millisecondsBigInt } = divmod(millisecondsBigInt, THOUSAND));\n            break;\n        case 'millisecond':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            ({ quotient: millisecondsBigInt, remainder: microsecondsBigInt } = divmod(microsecondsBigInt, THOUSAND));\n            break;\n        case 'microsecond':\n            ({ quotient: microsecondsBigInt, remainder: nanosecondsBigInt } = divmod(nanosecondsBigInt, THOUSAND));\n            break;\n        case 'nanosecond':\n            break;\n        default:\n            throw new Error('assert not reached');\n    }\n    const hours = JSBI.toNumber(hoursBigInt) * sign;\n    const minutes = JSBI.toNumber(minutesBigInt) * sign;\n    const seconds = JSBI.toNumber(secondsBigInt) * sign;\n    const milliseconds = JSBI.toNumber(millisecondsBigInt) * sign;\n    const microseconds = JSBI.toNumber(microsecondsBigInt) * sign;\n    const nanoseconds = JSBI.toNumber(nanosecondsBigInt) * sign;\n    return { days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function UnbalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    let calendar;\n    let relativeTo;\n    if (relativeToParam) {\n        relativeTo = ToTemporalDate(relativeToParam);\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    const oneYear = new TemporalDuration(sign);\n    const oneMonth = new TemporalDuration(0, sign);\n    const oneWeek = new TemporalDuration(0, 0, sign);\n    switch (largestUnit) {\n        case 'year':\n            // no-op\n            break;\n        case 'month':\n            {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for months balancing');\n                // balance years down to months\n                const dateAdd = calendar.dateAdd;\n                const dateUntil = calendar.dateUntil;\n                let relativeToDateOnly = relativeTo;\n                while (MathAbs(years) > 0) {\n                    const newRelativeTo = CalendarDateAdd(calendar, relativeToDateOnly, oneYear, undefined, dateAdd);\n                    const untilOptions = ObjectCreate(null);\n                    untilOptions.largestUnit = 'month';\n                    const untilResult = CalendarDateUntil(calendar, relativeToDateOnly, newRelativeTo, untilOptions, dateUntil);\n                    const oneYearMonths = GetSlot(untilResult, MONTHS);\n                    relativeToDateOnly = newRelativeTo;\n                    months += oneYearMonths;\n                    years -= sign;\n                }\n            }\n            break;\n        case 'week':\n            if (!calendar)\n                throw new RangeError('a starting point is required for weeks balancing');\n            // balance years down to days\n            while (MathAbs(years) > 0) {\n                let oneYearDays;\n                ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n                days += oneYearDays;\n                years -= sign;\n            }\n            // balance months down to days\n            while (MathAbs(months) > 0) {\n                let oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n                days += oneMonthDays;\n                months -= sign;\n            }\n            break;\n        default:\n            // balance years down to days\n            while (MathAbs(years) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneYearDays;\n                ({ relativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n                days += oneYearDays;\n                years -= sign;\n            }\n            // balance months down to days\n            while (MathAbs(months) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n                days += oneMonthDays;\n                months -= sign;\n            }\n            // balance weeks down to days\n            while (MathAbs(weeks) > 0) {\n                if (!calendar)\n                    throw new RangeError('a starting point is required for balancing calendar units');\n                let oneWeekDays;\n                ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n                days += oneWeekDays;\n                weeks -= sign;\n            }\n            break;\n    }\n    return { years, months, weeks, days };\n}\nexport function BalanceDurationRelative(yearsParam, monthsParam, weeksParam, daysParam, largestUnit, relativeToParam) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    if (sign === 0)\n        return { years, months, weeks, days };\n    let calendar;\n    let relativeTo;\n    if (relativeToParam) {\n        relativeTo = ToTemporalDate(relativeToParam);\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    const oneYear = new TemporalDuration(sign);\n    const oneMonth = new TemporalDuration(0, sign);\n    const oneWeek = new TemporalDuration(0, 0, sign);\n    switch (largestUnit) {\n        case 'year': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for years balancing');\n            // balance days up to years\n            let newRelativeTo, oneYearDays;\n            ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n            while (MathAbs(days) >= MathAbs(oneYearDays)) {\n                days -= oneYearDays;\n                years += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear));\n            }\n            // balance days up to months\n            let oneMonthDays;\n            ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                days -= oneMonthDays;\n                months += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            // balance months up to years\n            const dateAdd = calendar.dateAdd;\n            newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, undefined, dateAdd);\n            const dateUntil = calendar.dateUntil;\n            const untilOptions = ObjectCreate(null);\n            untilOptions.largestUnit = 'month';\n            let untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n            let oneYearMonths = GetSlot(untilResult, MONTHS);\n            while (MathAbs(months) >= MathAbs(oneYearMonths)) {\n                months -= oneYearMonths;\n                years += sign;\n                relativeTo = newRelativeTo;\n                newRelativeTo = CalendarDateAdd(calendar, relativeTo, oneYear, undefined, dateAdd);\n                const untilOptions = ObjectCreate(null);\n                untilOptions.largestUnit = 'month';\n                untilResult = CalendarDateUntil(calendar, relativeTo, newRelativeTo, untilOptions, dateUntil);\n                oneYearMonths = GetSlot(untilResult, MONTHS);\n            }\n            break;\n        }\n        case 'month': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for months balancing');\n            // balance days up to months\n            let newRelativeTo, oneMonthDays;\n            ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                days -= oneMonthDays;\n                months += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            break;\n        }\n        case 'week': {\n            if (!calendar)\n                throw new RangeError('a starting point is required for weeks balancing');\n            // balance days up to weeks\n            let newRelativeTo, oneWeekDays;\n            ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n                days -= oneWeekDays;\n                weeks += sign;\n                relativeTo = newRelativeTo;\n                ({ relativeTo: newRelativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            }\n            break;\n        }\n        default:\n            // no-op\n            break;\n    }\n    return { years, months, weeks, days };\n}\nexport function CalculateOffsetShift(relativeTo, y, mon, w, d) {\n    if (IsTemporalZonedDateTime(relativeTo)) {\n        const instant = GetSlot(relativeTo, INSTANT);\n        const timeZone = GetSlot(relativeTo, TIME_ZONE);\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const offsetBefore = GetOffsetNanosecondsFor(timeZone, instant);\n        const after = AddZonedDateTime(instant, timeZone, calendar, y, mon, w, d, 0, 0, 0, 0, 0, 0);\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        const instantAfter = new TemporalInstant(after);\n        const offsetAfter = GetOffsetNanosecondsFor(timeZone, instantAfter);\n        return offsetAfter - offsetBefore;\n    }\n    return 0;\n}\nexport function CreateNegatedTemporalDuration(duration) {\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    return new TemporalDuration(-GetSlot(duration, YEARS), -GetSlot(duration, MONTHS), -GetSlot(duration, WEEKS), -GetSlot(duration, DAYS), -GetSlot(duration, HOURS), -GetSlot(duration, MINUTES), -GetSlot(duration, SECONDS), -GetSlot(duration, MILLISECONDS), -GetSlot(duration, MICROSECONDS), -GetSlot(duration, NANOSECONDS));\n}\nexport function ConstrainToRange(value, min, max) {\n    // Math.Max accepts undefined values and returns NaN. Undefined values are\n    // used for optional params in the method below.\n    return MathMin(max, MathMax(min, value));\n}\nfunction ConstrainISODate(year, monthParam, dayParam) {\n    const month = ConstrainToRange(monthParam, 1, 12);\n    const day = ConstrainToRange(dayParam, 1, ISODaysInMonth(year, month));\n    return { year, month, day };\n}\nfunction ConstrainTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam) {\n    const hour = ConstrainToRange(hourParam, 0, 23);\n    const minute = ConstrainToRange(minuteParam, 0, 59);\n    const second = ConstrainToRange(secondParam, 0, 59);\n    const millisecond = ConstrainToRange(millisecondParam, 0, 999);\n    const microsecond = ConstrainToRange(microsecondParam, 0, 999);\n    const nanosecond = ConstrainToRange(nanosecondParam, 0, 999);\n    return { hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function RejectToRange(value, min, max) {\n    if (value < min || value > max)\n        throw new RangeError(`value out of range: ${min} <= ${value} <= ${max}`);\n}\nfunction RejectISODate(year, month, day) {\n    RejectToRange(month, 1, 12);\n    RejectToRange(day, 1, ISODaysInMonth(year, month));\n}\nfunction RejectDateRange(year, month, day) {\n    // Noon avoids trouble at edges of DateTime range (excludes midnight)\n    RejectDateTimeRange(year, month, day, 12, 0, 0, 0, 0, 0);\n}\nexport function RejectTime(hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectToRange(hour, 0, 23);\n    RejectToRange(minute, 0, 59);\n    RejectToRange(second, 0, 59);\n    RejectToRange(millisecond, 0, 999);\n    RejectToRange(microsecond, 0, 999);\n    RejectToRange(nanosecond, 0, 999);\n}\nfunction RejectDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectISODate(year, month, day);\n    RejectTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\nfunction RejectDateTimeRange(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond) {\n    RejectToRange(year, YEAR_MIN, YEAR_MAX);\n    // Reject any DateTime 24 hours or more outside the Instant range\n    if ((year === YEAR_MIN &&\n        null ==\n            GetEpochFromISOParts(year, month, day + 1, hour, minute, second, millisecond, microsecond, nanosecond - 1)) ||\n        (year === YEAR_MAX &&\n            null ==\n                GetEpochFromISOParts(year, month, day - 1, hour, minute, second, millisecond, microsecond, nanosecond + 1))) {\n        throw new RangeError('DateTime outside of supported range');\n    }\n}\nexport function ValidateEpochNanoseconds(epochNanoseconds) {\n    if (JSBI.lessThan(epochNanoseconds, NS_MIN) || JSBI.greaterThan(epochNanoseconds, NS_MAX)) {\n        throw new RangeError('Instant outside of supported range');\n    }\n}\nfunction RejectYearMonthRange(year, month) {\n    RejectToRange(year, YEAR_MIN, YEAR_MAX);\n    if (year === YEAR_MIN) {\n        RejectToRange(month, 4, 12);\n    }\n    else if (year === YEAR_MAX) {\n        RejectToRange(month, 1, 9);\n    }\n}\nexport function RejectDuration(y, mon, w, d, h, min, s, ms, µs, ns) {\n    const sign = DurationSign(y, mon, w, d, h, min, s, ms, µs, ns);\n    for (const prop of [y, mon, w, d, h, min, s, ms, µs, ns]) {\n        if (!NumberIsFinite(prop))\n            throw new RangeError('infinite values not allowed as duration fields');\n        const propSign = MathSign(prop);\n        if (propSign !== 0 && propSign !== sign)\n            throw new RangeError('mixed-sign values not allowed as duration fields');\n    }\n}\nexport function DifferenceISODate(y1, m1, d1, y2, m2, d2, largestUnit) {\n    switch (largestUnit) {\n        case 'year':\n        case 'month': {\n            const sign = -CompareISODate(y1, m1, d1, y2, m2, d2);\n            if (sign === 0)\n                return { years: 0, months: 0, weeks: 0, days: 0 };\n            const start = { year: y1, month: m1, day: d1 };\n            const end = { year: y2, month: m2, day: d2 };\n            let years = end.year - start.year;\n            let mid = AddISODate(y1, m1, d1, years, 0, 0, 0, 'constrain');\n            let midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n            if (midSign === 0) {\n                return largestUnit === 'year'\n                    ? { years, months: 0, weeks: 0, days: 0 }\n                    : { years: 0, months: years * 12, weeks: 0, days: 0 };\n            }\n            let months = end.month - start.month;\n            if (midSign !== sign) {\n                years -= sign;\n                months += sign * 12;\n            }\n            mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n            midSign = -CompareISODate(mid.year, mid.month, mid.day, y2, m2, d2);\n            if (midSign === 0) {\n                return largestUnit === 'year'\n                    ? { years, months, weeks: 0, days: 0 }\n                    : { years: 0, months: months + years * 12, weeks: 0, days: 0 };\n            }\n            if (midSign !== sign) {\n                // The end date is later in the month than mid date (or earlier for\n                // negative durations). Back up one month.\n                months -= sign;\n                if (months === -sign) {\n                    years -= sign;\n                    months = 11 * sign;\n                }\n                mid = AddISODate(y1, m1, d1, years, months, 0, 0, 'constrain');\n            }\n            let days = 0;\n            // If we get here, months and years are correct (no overflow), and `mid`\n            // is within the range from `start` to `end`. To count the days between\n            // `mid` and `end`, there are 3 cases:\n            // 1) same month: use simple subtraction\n            // 2) end is previous month from intermediate (negative duration)\n            // 3) end is next month from intermediate (positive duration)\n            if (mid.month === end.month) {\n                // 1) same month: use simple subtraction\n                days = end.day - mid.day;\n            }\n            else if (sign < 0) {\n                // 2) end is previous month from intermediate (negative duration)\n                // Example: intermediate: Feb 1, end: Jan 30, DaysInMonth = 31, days = -2\n                days = -mid.day - (ISODaysInMonth(end.year, end.month) - end.day);\n            }\n            else {\n                // 3) end is next month from intermediate (positive duration)\n                // Example: intermediate: Jan 29, end: Feb 1, DaysInMonth = 31, days = 3\n                days = end.day + (ISODaysInMonth(mid.year, mid.month) - mid.day);\n            }\n            if (largestUnit === 'month') {\n                months += years * 12;\n                years = 0;\n            }\n            return { years, months, weeks: 0, days };\n        }\n        case 'week':\n        case 'day': {\n            let larger, smaller, sign;\n            if (CompareISODate(y1, m1, d1, y2, m2, d2) < 0) {\n                smaller = { year: y1, month: m1, day: d1 };\n                larger = { year: y2, month: m2, day: d2 };\n                sign = 1;\n            }\n            else {\n                smaller = { year: y2, month: m2, day: d2 };\n                larger = { year: y1, month: m1, day: d1 };\n                sign = -1;\n            }\n            let days = DayOfYear(larger.year, larger.month, larger.day) - DayOfYear(smaller.year, smaller.month, smaller.day);\n            for (let year = smaller.year; year < larger.year; ++year) {\n                days += LeapYear(year) ? 366 : 365;\n            }\n            let weeks = 0;\n            if (largestUnit === 'week') {\n                weeks = MathFloor(days / 7);\n                days %= 7;\n            }\n            weeks *= sign;\n            days *= sign;\n            return { years: 0, months: 0, weeks, days };\n        }\n        default:\n            throw new Error('assert not reached');\n    }\n}\nfunction DifferenceTime(h1, min1, s1, ms1, µs1, ns1, h2, min2, s2, ms2, µs2, ns2) {\n    let hours = h2 - h1;\n    let minutes = min2 - min1;\n    let seconds = s2 - s1;\n    let milliseconds = ms2 - ms1;\n    let microseconds = µs2 - µs1;\n    let nanoseconds = ns2 - ns1;\n    const sign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    hours *= sign;\n    minutes *= sign;\n    seconds *= sign;\n    milliseconds *= sign;\n    microseconds *= sign;\n    nanoseconds *= sign;\n    let deltaDays = 0;\n    ({\n        deltaDays,\n        hour: hours,\n        minute: minutes,\n        second: seconds,\n        millisecond: milliseconds,\n        microsecond: microseconds,\n        nanosecond: nanoseconds\n    } = BalanceTime(hours, minutes, seconds, milliseconds, microseconds, nanoseconds));\n    if (deltaDays != 0)\n        throw new Error('assertion failure in DifferenceTime: _bt_.[[Days]] should be 0');\n    hours *= sign;\n    minutes *= sign;\n    seconds *= sign;\n    milliseconds *= sign;\n    microseconds *= sign;\n    nanoseconds *= sign;\n    return { hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction DifferenceInstant(ns1, ns2, increment, unit, roundingMode) {\n    const diff = JSBI.subtract(ns2, ns1);\n    const remainder = JSBI.remainder(diff, JSBI.BigInt(86400e9));\n    const wholeDays = JSBI.subtract(diff, remainder);\n    const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n    const roundedDiff = JSBI.add(wholeDays, roundedRemainder);\n    const nanoseconds = JSBI.toNumber(JSBI.remainder(roundedDiff, THOUSAND));\n    const microseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(roundedDiff, THOUSAND), THOUSAND));\n    const milliseconds = JSBI.toNumber(JSBI.remainder(JSBI.divide(roundedDiff, MILLION), THOUSAND));\n    const seconds = JSBI.toNumber(JSBI.divide(roundedDiff, BILLION));\n    return { seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction DifferenceISODateTime(y1Param, mon1Param, d1Param, h1, min1, s1, ms1, µs1, ns1, y2, mon2, d2, h2, min2, s2, ms2, µs2, ns2, calendar, largestUnit, options) {\n    let y1 = y1Param;\n    let mon1 = mon1Param;\n    let d1 = d1Param;\n    let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(h1, min1, s1, ms1, µs1, ns1, h2, min2, s2, ms2, µs2, ns2);\n    const timeSign = DurationSign(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    const dateSign = CompareISODate(y2, mon2, d2, y1, mon1, d1);\n    if (dateSign === -timeSign) {\n        ({ year: y1, month: mon1, day: d1 } = BalanceISODate(y1, mon1, d1 - timeSign));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(-timeSign, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    }\n    const date1 = CreateTemporalDate(y1, mon1, d1, calendar);\n    const date2 = CreateTemporalDate(y2, mon2, d2, calendar);\n    const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n    const untilOptions = MergeLargestUnitOption(options, dateLargestUnit);\n    // TODO untilOptions doesn't want to compile as it seems that smallestUnit is not clamped?\n    // Type 'SmallestUnit<DateTimeUnit> | undefined' is not assignable to type\n    //      'SmallestUnit<\"year\" | \"month\" | \"day\" | \"week\"> | undefined'.\n    // Type '\"hour\"' is not assignable to type\n    //      'SmallestUnit<\"year\" | \"month\" | \"day\" | \"week\"> | undefined'.ts(2345)\n    let { years, months, weeks, days } = CalendarDateUntil(calendar, date1, date2, untilOptions);\n    // Signs of date part and time part may not agree; balance them together\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, options) {\n    const nsDiff = JSBI.subtract(ns2, ns1);\n    if (JSBI.equal(nsDiff, ZERO)) {\n        return {\n            years: 0,\n            months: 0,\n            weeks: 0,\n            days: 0,\n            hours: 0,\n            minutes: 0,\n            seconds: 0,\n            milliseconds: 0,\n            microseconds: 0,\n            nanoseconds: 0\n        };\n    }\n    // Find the difference in dates only.\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const start = new TemporalInstant(ns1);\n    const end = new TemporalInstant(ns2);\n    const dtStart = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, start, calendar);\n    const dtEnd = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, end, calendar);\n    let { years, months, weeks, days } = DifferenceISODateTime(GetSlot(dtStart, ISO_YEAR), GetSlot(dtStart, ISO_MONTH), GetSlot(dtStart, ISO_DAY), GetSlot(dtStart, ISO_HOUR), GetSlot(dtStart, ISO_MINUTE), GetSlot(dtStart, ISO_SECOND), GetSlot(dtStart, ISO_MILLISECOND), GetSlot(dtStart, ISO_MICROSECOND), GetSlot(dtStart, ISO_NANOSECOND), GetSlot(dtEnd, ISO_YEAR), GetSlot(dtEnd, ISO_MONTH), GetSlot(dtEnd, ISO_DAY), GetSlot(dtEnd, ISO_HOUR), GetSlot(dtEnd, ISO_MINUTE), GetSlot(dtEnd, ISO_SECOND), GetSlot(dtEnd, ISO_MILLISECOND), GetSlot(dtEnd, ISO_MICROSECOND), GetSlot(dtEnd, ISO_NANOSECOND), calendar, largestUnit, options);\n    const intermediateNs = AddZonedDateTime(start, timeZone, calendar, years, months, weeks, 0, 0, 0, 0, 0, 0, 0);\n    // may disambiguate\n    let timeRemainderNs = JSBI.subtract(ns2, intermediateNs);\n    const intermediate = CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n    ({ nanoseconds: timeRemainderNs, days } = NanosecondsToDays(timeRemainderNs, intermediate));\n    // Finally, merge the date and time durations and return the merged result.\n    const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, JSBI.toNumber(timeRemainderNs), 'hour');\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\n// TODO: does it make sense to explicitly union the other and options types for each operation?\nexport function DifferenceTemporalInstant(operation, instant, otherParam, optionsParam) {\n    const other = ToTemporalInstant(otherParam);\n    let first, second;\n    if (operation === 'until') {\n        [first, second] = [instant, other];\n    }\n    else {\n        [first, second] = [other, instant];\n    }\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = GetTemporalUnit(options, 'smallestUnit', 'time', 'nanosecond');\n    const defaultLargestUnit = LargerOfTwoTemporalUnits('second', smallestUnit);\n    let largestUnit = GetTemporalUnit(options, 'largestUnit', 'time', 'auto');\n    if (largestUnit === 'auto')\n        largestUnit = defaultLargestUnit;\n    if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n        throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n    const roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    const MAX_DIFFERENCE_INCREMENTS = {\n        hour: 24,\n        minute: 60,\n        second: 60,\n        millisecond: 1000,\n        microsecond: 1000,\n        nanosecond: 1000\n    };\n    const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_DIFFERENCE_INCREMENTS[smallestUnit], false);\n    const onens = GetSlot(first, EPOCHNANOSECONDS);\n    const twons = GetSlot(second, EPOCHNANOSECONDS);\n    let { seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(onens, twons, roundingIncrement, smallestUnit, roundingMode);\n    let hours, minutes;\n    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n}\nexport function DifferenceTemporalPlainDate(operation, plainDate, otherParam, optionsParam) {\n    const sign = operation === 'since' ? -1 : 1;\n    const other = ToTemporalDate(otherParam);\n    const calendar = GetSlot(plainDate, CALENDAR);\n    const otherCalendar = GetSlot(other, CALENDAR);\n    const calendarId = ToString(calendar);\n    const otherCalendarId = ToString(otherCalendar);\n    if (calendarId !== otherCalendarId) {\n        throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n    }\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = GetTemporalUnit(options, 'smallestUnit', 'date', 'day');\n    const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n    let largestUnit = GetTemporalUnit(options, 'largestUnit', 'date', 'auto');\n    if (largestUnit === 'auto')\n        largestUnit = defaultLargestUnit;\n    if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n        throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n    let roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    if (operation === 'since')\n        roundingMode = NegateTemporalRoundingMode(roundingMode);\n    const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n    const untilOptions = MergeLargestUnitOption(options, largestUnit);\n    let { years, months, weeks, days } = CalendarDateUntil(calendar, plainDate, other, untilOptions);\n    if (smallestUnit !== 'day' || roundingIncrement !== 1) {\n        ({ years, months, weeks, days } = RoundDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, plainDate));\n    }\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(sign * years, sign * months, sign * weeks, sign * days, 0, 0, 0, 0, 0, 0);\n}\nexport function DifferenceTemporalPlainDateTime(operation, plainDateTime, otherParam, optionsParam) {\n    const sign = operation === 'since' ? -1 : 1;\n    const other = ToTemporalDateTime(otherParam);\n    const calendar = GetSlot(plainDateTime, CALENDAR);\n    const otherCalendar = GetSlot(other, CALENDAR);\n    const calendarId = ToString(calendar);\n    const otherCalendarId = ToString(otherCalendar);\n    if (calendarId !== otherCalendarId) {\n        throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n    }\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = GetTemporalUnit(options, 'smallestUnit', 'datetime', 'nanosecond');\n    const defaultLargestUnit = LargerOfTwoTemporalUnits('day', smallestUnit);\n    let largestUnit = GetTemporalUnit(options, 'largestUnit', 'datetime', 'auto');\n    if (largestUnit === 'auto')\n        largestUnit = defaultLargestUnit;\n    if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n        throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n    let roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    if (operation === 'since')\n        roundingMode = NegateTemporalRoundingMode(roundingMode);\n    const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n    let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceISODateTime(GetSlot(plainDateTime, ISO_YEAR), GetSlot(plainDateTime, ISO_MONTH), GetSlot(plainDateTime, ISO_DAY), GetSlot(plainDateTime, ISO_HOUR), GetSlot(plainDateTime, ISO_MINUTE), GetSlot(plainDateTime, ISO_SECOND), GetSlot(plainDateTime, ISO_MILLISECOND), GetSlot(plainDateTime, ISO_MICROSECOND), GetSlot(plainDateTime, ISO_NANOSECOND), GetSlot(other, ISO_YEAR), GetSlot(other, ISO_MONTH), GetSlot(other, ISO_DAY), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND), calendar, largestUnit, options);\n    const relativeTo = TemporalDateTimeToDate(plainDateTime);\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n    ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(sign * years, sign * months, sign * weeks, sign * days, sign * hours, sign * minutes, sign * seconds, sign * milliseconds, sign * microseconds, sign * nanoseconds);\n}\nexport function DifferenceTemporalPlainTime(operation, plainTime, otherParam, optionsParam) {\n    const sign = operation === 'since' ? -1 : 1;\n    const other = ToTemporalTime(otherParam);\n    const options = GetOptionsObject(optionsParam);\n    let largestUnit = GetTemporalUnit(options, 'largestUnit', 'time', 'auto');\n    if (largestUnit === 'auto')\n        largestUnit = 'hour';\n    const smallestUnit = GetTemporalUnit(options, 'smallestUnit', 'time', 'nanosecond');\n    if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n        throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n    let roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    if (operation === 'since')\n        roundingMode = NegateTemporalRoundingMode(roundingMode);\n    const MAX_INCREMENTS = {\n        hour: 24,\n        minute: 60,\n        second: 60,\n        millisecond: 1000,\n        microsecond: 1000,\n        nanosecond: 1000\n    };\n    const roundingIncrement = ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n    let { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = DifferenceTime(GetSlot(plainTime, ISO_HOUR), GetSlot(plainTime, ISO_MINUTE), GetSlot(plainTime, ISO_SECOND), GetSlot(plainTime, ISO_MILLISECOND), GetSlot(plainTime, ISO_MICROSECOND), GetSlot(plainTime, ISO_NANOSECOND), GetSlot(other, ISO_HOUR), GetSlot(other, ISO_MINUTE), GetSlot(other, ISO_SECOND), GetSlot(other, ISO_MILLISECOND), GetSlot(other, ISO_MICROSECOND), GetSlot(other, ISO_NANOSECOND));\n    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(0, 0, 0, 0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode));\n    ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(0, 0, 0, 0, sign * hours, sign * minutes, sign * seconds, sign * milliseconds, sign * microseconds, sign * nanoseconds);\n}\nexport function DifferenceTemporalPlainYearMonth(operation, yearMonth, otherParam, optionsParam) {\n    const sign = operation === 'since' ? -1 : 1;\n    const other = ToTemporalYearMonth(otherParam);\n    const calendar = GetSlot(yearMonth, CALENDAR);\n    const otherCalendar = GetSlot(other, CALENDAR);\n    const calendarID = ToString(calendar);\n    const otherCalendarID = ToString(otherCalendar);\n    if (calendarID !== otherCalendarID) {\n        throw new RangeError(`cannot compute difference between months of ${calendarID} and ${otherCalendarID} calendars`);\n    }\n    const options = GetOptionsObject(optionsParam);\n    const ALLOWED_UNITS = SINGULAR_PLURAL_UNITS.reduce((allowed, [p, s, c]) => {\n        if (c === 'date' && s !== 'week' && s !== 'day')\n            allowed.push(s, p);\n        return allowed;\n    }, []);\n    const smallestUnit = GetTemporalUnit(options, 'smallestUnit', 'date', 'month');\n    if (smallestUnit === 'week' || smallestUnit === 'day') {\n        throw new RangeError(`smallestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${smallestUnit}`);\n    }\n    let largestUnit = GetTemporalUnit(options, 'largestUnit', 'date', 'auto');\n    if (largestUnit === 'week' || largestUnit === 'day') {\n        throw new RangeError(`largestUnit must be one of ${ALLOWED_UNITS.join(', ')}, not ${largestUnit}`);\n    }\n    if (largestUnit === 'auto')\n        largestUnit = 'year';\n    if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n        throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n    let roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    if (operation === 'since')\n        roundingMode = NegateTemporalRoundingMode(roundingMode);\n    const roundingIncrement = ToTemporalRoundingIncrement(options, undefined, false);\n    const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n    const otherFields = PrepareTemporalFields(other, fieldNames, []);\n    otherFields.day = 1;\n    const thisFields = PrepareTemporalFields(yearMonth, fieldNames, []);\n    thisFields.day = 1;\n    // The calls to PrepareTemporalFields don't mark day as a required property,\n    // and TS doesn't automatically narrow the type of the object because of the\n    // assignments above, so we must \"cast\" the inputs.\n    const otherDate = CalendarDateFromFields(calendar, otherFields);\n    const thisDate = CalendarDateFromFields(calendar, thisFields);\n    const untilOptions = MergeLargestUnitOption(options, largestUnit);\n    let { years, months } = CalendarDateUntil(calendar, thisDate, otherDate, untilOptions);\n    if (smallestUnit !== 'month' || roundingIncrement !== 1) {\n        ({ years, months } = RoundDuration(years, months, 0, 0, 0, 0, 0, 0, 0, 0, roundingIncrement, smallestUnit, roundingMode, thisDate));\n    }\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(sign * years, sign * months, 0, 0, 0, 0, 0, 0, 0, 0);\n}\nexport function DifferenceTemporalZonedDateTime(operation, zonedDateTime, otherParam, optionsParam) {\n    const sign = operation === 'since' ? -1 : 1;\n    const other = ToTemporalZonedDateTime(otherParam);\n    const calendar = GetSlot(zonedDateTime, CALENDAR);\n    const otherCalendar = GetSlot(other, CALENDAR);\n    const calendarId = ToString(calendar);\n    const otherCalendarId = ToString(otherCalendar);\n    if (calendarId !== otherCalendarId) {\n        throw new RangeError(`cannot compute difference between dates of ${calendarId} and ${otherCalendarId} calendars`);\n    }\n    const options = GetOptionsObject(optionsParam);\n    const smallestUnit = GetTemporalUnit(options, 'smallestUnit', 'datetime', 'nanosecond');\n    const defaultLargestUnit = LargerOfTwoTemporalUnits('hour', smallestUnit);\n    let largestUnit = GetTemporalUnit(options, 'largestUnit', 'datetime', 'auto');\n    if (largestUnit === 'auto')\n        largestUnit = defaultLargestUnit;\n    if (LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n        throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n    }\n    let roundingMode = ToTemporalRoundingMode(options, 'trunc');\n    if (operation === 'since')\n        roundingMode = NegateTemporalRoundingMode(roundingMode);\n    const roundingIncrement = ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n    const ns1 = GetSlot(zonedDateTime, EPOCHNANOSECONDS);\n    const ns2 = GetSlot(other, EPOCHNANOSECONDS);\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n    if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n        // The user is only asking for a time difference, so return difference of instants.\n        years = 0;\n        months = 0;\n        weeks = 0;\n        days = 0;\n        ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(ns1, ns2, roundingIncrement, \n        // TODO this doesn't type-check as it includes >= day-size units\n        // This is probably safe as the typing for ToSmallestTemporalUnit isn't\n        // very good.\n        smallestUnit, roundingMode));\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n    }\n    else {\n        const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\n        if (!TimeZoneEquals(timeZone, GetSlot(other, TIME_ZONE))) {\n            throw new RangeError(\"When calculating difference between time zones, largestUnit must be 'hours' \" +\n                'or smaller because day lengths can vary between time zones due to DST or time zone offset changes.');\n        }\n        const untilOptions = MergeLargestUnitOption(options, largestUnit);\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            DifferenceZonedDateTime(ns1, ns2, timeZone, calendar, largestUnit, untilOptions));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, zonedDateTime));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, zonedDateTime));\n    }\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(sign * years, sign * months, sign * weeks, sign * days, sign * hours, sign * minutes, sign * seconds, sign * milliseconds, sign * microseconds, sign * nanoseconds);\n}\nexport function AddISODate(yearParam, monthParam, dayParam, yearsParam, monthsParam, weeksParam, daysParam, overflow) {\n    let year = yearParam;\n    let month = monthParam;\n    let day = dayParam;\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    year += years;\n    month += months;\n    ({ year, month } = BalanceISOYearMonth(year, month));\n    ({ year, month, day } = RegulateISODate(year, month, day, overflow));\n    days += 7 * weeks;\n    day += days;\n    ({ year, month, day } = BalanceISODate(year, month, day));\n    return { year, month, day };\n}\nfunction AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds) {\n    let hour = hourParam;\n    let minute = minuteParam;\n    let second = secondParam;\n    let millisecond = millisecondParam;\n    let microsecond = microsecondParam;\n    let nanosecond = nanosecondParam;\n    hour += hours;\n    minute += minutes;\n    second += seconds;\n    millisecond += milliseconds;\n    microsecond += microseconds;\n    nanosecond += nanoseconds;\n    let deltaDays = 0;\n    ({ deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = BalanceTime(hour, minute, second, millisecond, microsecond, nanosecond));\n    return { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nfunction AddDuration(y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1, y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2, relativeTo) {\n    const largestUnit1 = DefaultTemporalLargestUnit(y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1);\n    const largestUnit2 = DefaultTemporalLargestUnit(y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2);\n    const largestUnit = LargerOfTwoTemporalUnits(largestUnit1, largestUnit2);\n    let years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds;\n    if (!relativeTo) {\n        if (largestUnit === 'year' || largestUnit === 'month' || largestUnit === 'week') {\n            throw new RangeError('relativeTo is required for years, months, or weeks arithmetic');\n        }\n        years = months = weeks = 0;\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(d1 + d2, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, µs1 + µs2, ns1 + ns2, largestUnit));\n    }\n    else if (IsTemporalDate(relativeTo)) {\n        const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const dateDuration1 = new TemporalDuration(y1, mon1, w1, d1, 0, 0, 0, 0, 0, 0);\n        const dateDuration2 = new TemporalDuration(y2, mon2, w2, d2, 0, 0, 0, 0, 0, 0);\n        const dateAdd = calendar.dateAdd;\n        const intermediate = CalendarDateAdd(calendar, relativeTo, dateDuration1, undefined, dateAdd);\n        const end = CalendarDateAdd(calendar, intermediate, dateDuration2, undefined, dateAdd);\n        const dateLargestUnit = LargerOfTwoTemporalUnits('day', largestUnit);\n        const differenceOptions = ObjectCreate(null);\n        differenceOptions.largestUnit = dateLargestUnit;\n        ({ years, months, weeks, days } = CalendarDateUntil(calendar, relativeTo, end, differenceOptions));\n        // Signs of date part and time part may not agree; balance them together\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(days, h1 + h2, min1 + min2, s1 + s2, ms1 + ms2, µs1 + µs2, ns1 + ns2, largestUnit));\n    }\n    else {\n        // relativeTo is a ZonedDateTime\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        const timeZone = GetSlot(relativeTo, TIME_ZONE);\n        const calendar = GetSlot(relativeTo, CALENDAR);\n        const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, y1, mon1, w1, d1, h1, min1, s1, ms1, µs1, ns1);\n        const endNs = AddZonedDateTime(new TemporalInstant(intermediateNs), timeZone, calendar, y2, mon2, w2, d2, h2, min2, s2, ms2, µs2, ns2);\n        if (largestUnit !== 'year' && largestUnit !== 'month' && largestUnit !== 'week' && largestUnit !== 'day') {\n            // The user is only asking for a time difference, so return difference of instants.\n            years = 0;\n            months = 0;\n            weeks = 0;\n            days = 0;\n            ({ seconds, milliseconds, microseconds, nanoseconds } = DifferenceInstant(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, 1, 'nanosecond', 'halfExpand'));\n            ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, seconds, milliseconds, microseconds, nanoseconds, largestUnit));\n        }\n        else {\n            ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n                DifferenceZonedDateTime(GetSlot(relativeTo, EPOCHNANOSECONDS), endNs, timeZone, calendar, largestUnit, ObjectCreate(null)));\n        }\n    }\n    RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nfunction AddInstant(epochNanoseconds, h, min, s, ms, µs, ns) {\n    let sum = ZERO;\n    sum = JSBI.add(sum, JSBI.BigInt(ns));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(µs), THOUSAND));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(ms), MILLION));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(s), BILLION));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(min), JSBI.BigInt(60 * 1e9)));\n    sum = JSBI.add(sum, JSBI.multiply(JSBI.BigInt(h), JSBI.BigInt(60 * 60 * 1e9)));\n    const result = JSBI.add(epochNanoseconds, sum);\n    ValidateEpochNanoseconds(result);\n    return result;\n}\nfunction AddDateTime(year, month, day, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, calendar, years, months, weeks, daysParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, options) {\n    let days = daysParam;\n    // Add the time part\n    let { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    days += deltaDays;\n    // Delegate the date part addition to the calendar\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    const datePart = CreateTemporalDate(year, month, day, calendar);\n    const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n    return {\n        year: GetSlot(addedDate, ISO_YEAR),\n        month: GetSlot(addedDate, ISO_MONTH),\n        day: GetSlot(addedDate, ISO_DAY),\n        hour,\n        minute,\n        second,\n        millisecond,\n        microsecond,\n        nanosecond\n    };\n}\nexport function AddZonedDateTime(instant, timeZone, calendar, years, months, weeks, days, h, min, s, ms, µs, ns, options) {\n    // If only time is to be added, then use Instant math. It's not OK to fall\n    // through to the date/time code below because compatible disambiguation in\n    // the PlainDateTime=>Instant conversion will change the offset of any\n    // ZonedDateTime in the repeated clock time after a backwards transition.\n    // When adding/subtracting time units and not dates, this disambiguation is\n    // not expected and so is avoided below via a fast path for time-only\n    // arithmetic.\n    // BTW, this behavior is similar in spirit to offset: 'prefer' in `with`.\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    if (DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0) === 0) {\n        return AddInstant(GetSlot(instant, EPOCHNANOSECONDS), h, min, s, ms, µs, ns);\n    }\n    // RFC 5545 requires the date portion to be added in calendar days and the\n    // time portion to be added in exact time.\n    const dt = BuiltinTimeZoneGetPlainDateTimeFor(timeZone, instant, calendar);\n    const datePart = CreateTemporalDate(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), calendar);\n    const dateDuration = new TemporalDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const addedDate = CalendarDateAdd(calendar, datePart, dateDuration, options);\n    const dtIntermediate = CreateTemporalDateTime(GetSlot(addedDate, ISO_YEAR), GetSlot(addedDate, ISO_MONTH), GetSlot(addedDate, ISO_DAY), GetSlot(dt, ISO_HOUR), GetSlot(dt, ISO_MINUTE), GetSlot(dt, ISO_SECOND), GetSlot(dt, ISO_MILLISECOND), GetSlot(dt, ISO_MICROSECOND), GetSlot(dt, ISO_NANOSECOND), calendar);\n    // Note that 'compatible' is used below because this disambiguation behavior\n    // is required by RFC 5545.\n    const instantIntermediate = BuiltinTimeZoneGetInstantFor(timeZone, dtIntermediate, 'compatible');\n    return AddInstant(GetSlot(instantIntermediate, EPOCHNANOSECONDS), h, min, s, ms, µs, ns);\n}\nexport function AddDurationToOrSubtractDurationFromDuration(operation, duration, other, optionsParam) {\n    const sign = operation === 'subtract' ? -1 : 1;\n    let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToTemporalDurationRecord(other);\n    const options = GetOptionsObject(optionsParam);\n    const relativeTo = ToRelativeTemporalObject(options);\n    ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = AddDuration(GetSlot(duration, YEARS), GetSlot(duration, MONTHS), GetSlot(duration, WEEKS), GetSlot(duration, DAYS), GetSlot(duration, HOURS), GetSlot(duration, MINUTES), GetSlot(duration, SECONDS), GetSlot(duration, MILLISECONDS), GetSlot(duration, MICROSECONDS), GetSlot(duration, NANOSECONDS), sign * years, sign * months, sign * weeks, sign * days, sign * hours, sign * minutes, sign * seconds, sign * milliseconds, sign * microseconds, sign * nanoseconds, relativeTo));\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n}\nexport function AddDurationToOrSubtractDurationFromInstant(operation, instant, durationLike) {\n    const sign = operation === 'subtract' ? -1 : 1;\n    const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToLimitedTemporalDuration(durationLike, [\n        'years',\n        'months',\n        'weeks',\n        'days'\n    ]);\n    const ns = AddInstant(GetSlot(instant, EPOCHNANOSECONDS), sign * hours, sign * minutes, sign * seconds, sign * milliseconds, sign * microseconds, sign * nanoseconds);\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    return new Instant(ns);\n}\nexport function AddDurationToOrSubtractDurationFromPlainDateTime(operation, dateTime, durationLike, optionsParam) {\n    const sign = operation === 'subtract' ? -1 : 1;\n    const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToTemporalDurationRecord(durationLike);\n    const options = GetOptionsObject(optionsParam);\n    const calendar = GetSlot(dateTime, CALENDAR);\n    const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = AddDateTime(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND), calendar, sign * years, sign * months, sign * weeks, sign * days, sign * hours, sign * minutes, sign * seconds, sign * milliseconds, sign * microseconds, sign * nanoseconds, options);\n    return CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n}\nexport function AddDurationToOrSubtractDurationFromPlainTime(operation, temporalTime, durationLike) {\n    const sign = operation === 'subtract' ? -1 : 1;\n    const { hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToTemporalDurationRecord(durationLike);\n    let { hour, minute, second, millisecond, microsecond, nanosecond } = AddTime(GetSlot(temporalTime, ISO_HOUR), GetSlot(temporalTime, ISO_MINUTE), GetSlot(temporalTime, ISO_SECOND), GetSlot(temporalTime, ISO_MILLISECOND), GetSlot(temporalTime, ISO_MICROSECOND), GetSlot(temporalTime, ISO_NANOSECOND), sign * hours, sign * minutes, sign * seconds, sign * milliseconds, sign * microseconds, sign * nanoseconds);\n    ({ hour, minute, second, millisecond, microsecond, nanosecond } = RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, 'reject'));\n    const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n    return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n}\nexport function AddDurationToOrSubtractDurationFromPlainYearMonth(operation, yearMonth, durationLike, optionsParam) {\n    let duration = ToTemporalDurationRecord(durationLike);\n    if (operation === 'subtract') {\n        duration = {\n            years: -duration.years,\n            months: -duration.months,\n            weeks: -duration.weeks,\n            days: -duration.days,\n            hours: -duration.hours,\n            minutes: -duration.minutes,\n            seconds: -duration.seconds,\n            milliseconds: -duration.milliseconds,\n            microseconds: -duration.microseconds,\n            nanoseconds: -duration.nanoseconds\n        };\n    }\n    let { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = duration;\n    ({ days } = BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 'day'));\n    const options = GetOptionsObject(optionsParam);\n    const calendar = GetSlot(yearMonth, CALENDAR);\n    const fieldNames = CalendarFields(calendar, ['monthCode', 'year']);\n    const fields = PrepareTemporalFields(yearMonth, fieldNames, []);\n    const sign = DurationSign(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    fields.day = sign < 0 ? ToPositiveInteger(CalendarDaysInMonth(calendar, yearMonth)) : 1;\n    // PrepareTemporalFields returns a type where 'day' is potentially undefined,\n    // and TS doesn't narrow the type as a result of the assignment above, so we\n    // cast the fields input to the new type.\n    const startDate = CalendarDateFromFields(calendar, fields);\n    const Duration = GetIntrinsic('%Temporal.Duration%');\n    const durationToAdd = new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const optionsCopy = ObjectAssign(ObjectCreate(null), options);\n    const addedDate = CalendarDateAdd(calendar, startDate, durationToAdd, options);\n    const addedDateFields = PrepareTemporalFields(addedDate, fieldNames, []);\n    return CalendarYearMonthFromFields(calendar, addedDateFields, optionsCopy);\n}\nexport function AddDurationToOrSubtractDurationFromZonedDateTime(operation, zonedDateTime, durationLike, optionsParam) {\n    const sign = operation === 'subtract' ? -1 : 1;\n    const { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ToTemporalDurationRecord(durationLike);\n    const options = GetOptionsObject(optionsParam);\n    const timeZone = GetSlot(zonedDateTime, TIME_ZONE);\n    const calendar = GetSlot(zonedDateTime, CALENDAR);\n    const epochNanoseconds = AddZonedDateTime(GetSlot(zonedDateTime, INSTANT), timeZone, calendar, sign * years, sign * months, sign * weeks, sign * days, sign * hours, sign * minutes, sign * seconds, sign * milliseconds, sign * microseconds, sign * nanoseconds, options);\n    return CreateTemporalZonedDateTime(epochNanoseconds, timeZone, calendar);\n}\nfunction RoundNumberToIncrement(quantity, increment, mode) {\n    if (increment === 1)\n        return quantity;\n    let { quotient, remainder } = divmod(quantity, JSBI.BigInt(increment));\n    if (JSBI.equal(remainder, ZERO))\n        return quantity;\n    const sign = JSBI.lessThan(remainder, ZERO) ? -1 : 1;\n    switch (mode) {\n        case 'ceil':\n            if (sign > 0)\n                quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n            break;\n        case 'floor':\n            if (sign < 0)\n                quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n            break;\n        case 'trunc':\n            // no change needed, because divmod is a truncation\n            break;\n        case 'halfExpand':\n            // \"half up away from zero\"\n            if (JSBI.toNumber(abs(JSBI.multiply(remainder, JSBI.BigInt(2)))) >= increment) {\n                quotient = JSBI.add(quotient, JSBI.BigInt(sign));\n            }\n            break;\n    }\n    return JSBI.multiply(quotient, JSBI.BigInt(increment));\n}\nexport function RoundInstant(epochNs, increment, unit, roundingMode) {\n    // Note: NonNegativeModulo, but with BigInt\n    let remainder = JSBI.remainder(epochNs, JSBI.BigInt(86400e9));\n    if (JSBI.lessThan(remainder, ZERO))\n        remainder = JSBI.add(remainder, JSBI.BigInt(86400e9));\n    const wholeDays = JSBI.subtract(epochNs, remainder);\n    const roundedRemainder = RoundNumberToIncrement(remainder, nsPerTimeUnit[unit] * increment, roundingMode);\n    return JSBI.add(wholeDays, roundedRemainder);\n}\nexport function RoundISODateTime(yearParam, monthParam, dayParam, hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n    const { deltaDays, hour, minute, second, millisecond, microsecond, nanosecond } = RoundTime(hourParam, minuteParam, secondParam, millisecondParam, microsecondParam, nanosecondParam, increment, unit, roundingMode, dayLengthNs);\n    const { year, month, day } = BalanceISODate(yearParam, monthParam, dayParam + deltaDays);\n    return { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond };\n}\nexport function RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode, dayLengthNs = 86400e9) {\n    let quantity = ZERO;\n    switch (unit) {\n        case 'day':\n        case 'hour':\n            quantity = JSBI.BigInt(hour);\n        // fall through\n        case 'minute':\n            quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(minute));\n        // fall through\n        case 'second':\n            quantity = JSBI.add(JSBI.multiply(quantity, SIXTY), JSBI.BigInt(second));\n        // fall through\n        case 'millisecond':\n            quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(millisecond));\n        // fall through\n        case 'microsecond':\n            quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(microsecond));\n        // fall through\n        case 'nanosecond':\n            quantity = JSBI.add(JSBI.multiply(quantity, THOUSAND), JSBI.BigInt(nanosecond));\n    }\n    const nsPerUnit = unit === 'day' ? dayLengthNs : nsPerTimeUnit[unit];\n    const rounded = RoundNumberToIncrement(quantity, nsPerUnit * increment, roundingMode);\n    const result = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(nsPerUnit)));\n    switch (unit) {\n        case 'day':\n            return { deltaDays: result, hour: 0, minute: 0, second: 0, millisecond: 0, microsecond: 0, nanosecond: 0 };\n        case 'hour':\n            return BalanceTime(result, 0, 0, 0, 0, 0);\n        case 'minute':\n            return BalanceTime(hour, result, 0, 0, 0, 0);\n        case 'second':\n            return BalanceTime(hour, minute, result, 0, 0, 0);\n        case 'millisecond':\n            return BalanceTime(hour, minute, second, result, 0, 0);\n        case 'microsecond':\n            return BalanceTime(hour, minute, second, millisecond, result, 0);\n        case 'nanosecond':\n            return BalanceTime(hour, minute, second, millisecond, microsecond, result);\n        default:\n            throw new Error(`Invalid unit ${unit}`);\n    }\n}\nfunction DaysUntil(earlier, later) {\n    return DifferenceISODate(GetSlot(earlier, ISO_YEAR), GetSlot(earlier, ISO_MONTH), GetSlot(earlier, ISO_DAY), GetSlot(later, ISO_YEAR), GetSlot(later, ISO_MONTH), GetSlot(later, ISO_DAY), 'day').days;\n}\nfunction MoveRelativeDate(calendar, relativeToParam, duration) {\n    const later = CalendarDateAdd(calendar, relativeToParam, duration, undefined);\n    const days = DaysUntil(relativeToParam, later);\n    return { relativeTo: later, days };\n}\nexport function MoveRelativeZonedDateTime(relativeTo, years, months, weeks, days) {\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const intermediateNs = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    return CreateTemporalZonedDateTime(intermediateNs, timeZone, calendar);\n}\nexport function AdjustRoundedDurationDays(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeTo) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    let hours = hoursParam;\n    let minutes = minutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = nanosecondsParam;\n    if (!IsTemporalZonedDateTime(relativeTo) ||\n        unit === 'year' ||\n        unit === 'month' ||\n        unit === 'week' ||\n        unit === 'day' ||\n        (unit === 'nanosecond' && increment === 1)) {\n        return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n    }\n    // There's one more round of rounding possible: if relativeTo is a\n    // ZonedDateTime, the time units could have rounded up into enough hours\n    // to exceed the day length. If this happens, grow the date part by a\n    // single day and re-run exact time rounding on the smaller remainder. DO\n    // NOT RECURSE, because once the extra hours are sucked up into the date\n    // duration, there's no way for another full day to come from the next\n    // round of rounding. And if it were possible (e.g. contrived calendar\n    // with 30-minute-long \"days\") then it'd risk an infinite loop.\n    let timeRemainderNs = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 0);\n    const direction = MathSign(JSBI.toNumber(timeRemainderNs));\n    const timeZone = GetSlot(relativeTo, TIME_ZONE);\n    const calendar = GetSlot(relativeTo, CALENDAR);\n    const dayStart = AddZonedDateTime(GetSlot(relativeTo, INSTANT), timeZone, calendar, years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n    const dayEnd = AddZonedDateTime(new TemporalInstant(dayStart), timeZone, calendar, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0);\n    const dayLengthNs = JSBI.subtract(dayEnd, dayStart);\n    if (JSBI.greaterThanOrEqual(JSBI.multiply(JSBI.subtract(timeRemainderNs, dayLengthNs), JSBI.BigInt(direction)), ZERO)) {\n        ({ years, months, weeks, days } = AddDuration(years, months, weeks, days, 0, 0, 0, 0, 0, 0, 0, 0, 0, direction, 0, 0, 0, 0, 0, 0, relativeTo));\n        timeRemainderNs = RoundInstant(JSBI.subtract(timeRemainderNs, dayLengthNs), increment, unit, roundingMode);\n        ({ hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = BalanceDuration(0, 0, 0, 0, 0, 0, JSBI.toNumber(timeRemainderNs), 'hour'));\n    }\n    return { years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds };\n}\nexport function RoundDuration(yearsParam, monthsParam, weeksParam, daysParam, hoursParam, minutesParam, secondsParam, millisecondsParam, microsecondsParam, nanosecondsParam, increment, unit, roundingMode, relativeToParam = undefined) {\n    let years = yearsParam;\n    let months = monthsParam;\n    let weeks = weeksParam;\n    let days = daysParam;\n    let hours = hoursParam;\n    let minutes = minutesParam;\n    let seconds = secondsParam;\n    let milliseconds = millisecondsParam;\n    let microseconds = microsecondsParam;\n    let nanoseconds = JSBI.BigInt(nanosecondsParam);\n    const TemporalDuration = GetIntrinsic('%Temporal.Duration%');\n    let calendar, zdtRelative;\n    // A cast is used below because relativeTo will be either PlainDate or\n    // undefined for the rest of this long method (after any ZDT=>PlainDate\n    // conversion below), and TS isn't smart enough to know that the type has\n    // changed. See https://github.com/microsoft/TypeScript/issues/27706.\n    let relativeTo = relativeToParam;\n    if (relativeTo) {\n        if (IsTemporalZonedDateTime(relativeTo)) {\n            zdtRelative = relativeTo;\n            relativeTo = ToTemporalDate(relativeTo);\n        }\n        else if (!IsTemporalDate(relativeTo)) {\n            throw new TypeError('starting point must be PlainDate or ZonedDateTime');\n        }\n        calendar = GetSlot(relativeTo, CALENDAR);\n    }\n    // First convert time units up to days, if rounding to days or higher units.\n    // If rounding relative to a ZonedDateTime, then some days may not be 24h.\n    // TS doesn't know that `dayLengthNs` is only used if the unit is day or\n    // larger. We'll cast away `undefined` when it's used lower down below.\n    let dayLengthNs;\n    if (unit === 'year' || unit === 'month' || unit === 'week' || unit === 'day') {\n        nanoseconds = TotalDurationNanoseconds(0, hours, minutes, seconds, milliseconds, microseconds, nanosecondsParam, 0);\n        let intermediate;\n        if (zdtRelative) {\n            intermediate = MoveRelativeZonedDateTime(zdtRelative, years, months, weeks, days);\n        }\n        let deltaDays;\n        let dayLength;\n        ({ days: deltaDays, nanoseconds, dayLengthNs: dayLength } = NanosecondsToDays(nanoseconds, intermediate));\n        dayLengthNs = JSBI.BigInt(dayLength);\n        days += deltaDays;\n        hours = minutes = seconds = milliseconds = microseconds = 0;\n    }\n    let total;\n    switch (unit) {\n        case 'year': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for years rounding');\n            // convert months and weeks to days by calculating difference(\n            // relativeTo + years, relativeTo + { years, months, weeks })\n            const yearsDuration = new TemporalDuration(years);\n            const dateAdd = calendar.dateAdd;\n            const yearsLater = CalendarDateAdd(calendar, relativeTo, yearsDuration, undefined, dateAdd);\n            const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n            const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, undefined, dateAdd);\n            const monthsWeeksInDays = DaysUntil(yearsLater, yearsMonthsWeeksLater);\n            relativeTo = yearsLater;\n            days += monthsWeeksInDays;\n            const daysLater = CalendarDateAdd(calendar, relativeTo, { days }, undefined, dateAdd);\n            const untilOptions = ObjectCreate(null);\n            untilOptions.largestUnit = 'year';\n            const yearsPassed = CalendarDateUntil(calendar, relativeTo, daysLater, untilOptions).years;\n            years += yearsPassed;\n            const oldRelativeTo = relativeTo;\n            relativeTo = CalendarDateAdd(calendar, relativeTo, { years: yearsPassed }, undefined, dateAdd);\n            const daysPassed = DaysUntil(oldRelativeTo, relativeTo);\n            days -= daysPassed;\n            const oneYear = new TemporalDuration(days < 0 ? -1 : 1);\n            let { days: oneYearDays } = MoveRelativeDate(calendar, relativeTo, oneYear);\n            // Note that `nanoseconds` below (here and in similar code for months,\n            // weeks, and days further below) isn't actually nanoseconds for the\n            // full date range.  Instead, it's a BigInt representation of total\n            // days multiplied by the number of nanoseconds in the last day of\n            // the duration. This lets us do days-or-larger rounding using BigInt\n            // math which reduces precision loss.\n            oneYearDays = MathAbs(oneYearDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = JSBI.multiply(JSBI.BigInt(oneYearDays), dayLengthNs);\n            nanoseconds = JSBI.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(years)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n            total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n            years = JSBI.toNumber(JSBI.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            months = weeks = days = 0;\n            break;\n        }\n        case 'month': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for months rounding');\n            // convert weeks to days by calculating difference(relativeTo +\n            //   { years, months }, relativeTo + { years, months, weeks })\n            const yearsMonths = new TemporalDuration(years, months);\n            const dateAdd = calendar.dateAdd;\n            const yearsMonthsLater = CalendarDateAdd(calendar, relativeTo, yearsMonths, undefined, dateAdd);\n            const yearsMonthsWeeks = new TemporalDuration(years, months, weeks);\n            const yearsMonthsWeeksLater = CalendarDateAdd(calendar, relativeTo, yearsMonthsWeeks, undefined, dateAdd);\n            const weeksInDays = DaysUntil(yearsMonthsLater, yearsMonthsWeeksLater);\n            relativeTo = yearsMonthsLater;\n            days += weeksInDays;\n            // Months may be different lengths of days depending on the calendar,\n            // convert days to months in a loop as described above under 'years'.\n            const sign = MathSign(days);\n            const oneMonth = new TemporalDuration(0, days < 0 ? -1 : 1);\n            let oneMonthDays;\n            ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            while (MathAbs(days) >= MathAbs(oneMonthDays)) {\n                months += sign;\n                days -= oneMonthDays;\n                ({ relativeTo, days: oneMonthDays } = MoveRelativeDate(calendar, relativeTo, oneMonth));\n            }\n            oneMonthDays = MathAbs(oneMonthDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = JSBI.multiply(JSBI.BigInt(oneMonthDays), dayLengthNs);\n            nanoseconds = JSBI.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(months)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n            total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n            months = JSBI.toNumber(JSBI.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            weeks = days = 0;\n            break;\n        }\n        case 'week': {\n            if (!calendar)\n                throw new RangeError('A starting point is required for weeks rounding');\n            // Weeks may be different lengths of days depending on the calendar,\n            // convert days to weeks in a loop as described above under 'years'.\n            const sign = MathSign(days);\n            const oneWeek = new TemporalDuration(0, 0, days < 0 ? -1 : 1);\n            let oneWeekDays;\n            ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            while (MathAbs(days) >= MathAbs(oneWeekDays)) {\n                weeks += sign;\n                days -= oneWeekDays;\n                ({ relativeTo, days: oneWeekDays } = MoveRelativeDate(calendar, relativeTo, oneWeek));\n            }\n            oneWeekDays = MathAbs(oneWeekDays);\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = JSBI.multiply(JSBI.BigInt(oneWeekDays), dayLengthNs);\n            nanoseconds = JSBI.add(\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(weeks)), JSBI.multiply(JSBI.BigInt(days), dayLengthNs)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n            total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n            weeks = JSBI.toNumber(JSBI.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            days = 0;\n            break;\n        }\n        case 'day': {\n            // dayLengthNs is never undefined if unit is `day` or larger.\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            const divisor = dayLengthNs;\n            nanoseconds = JSBI.add(JSBI.multiply(divisor, JSBI.BigInt(days)), nanoseconds);\n            const rounded = RoundNumberToIncrement(nanoseconds, JSBI.toNumber(JSBI.multiply(divisor, JSBI.BigInt(increment))), roundingMode);\n            total = JSBI.toNumber(nanoseconds) / JSBI.toNumber(divisor);\n            days = JSBI.toNumber(JSBI.divide(rounded, divisor));\n            nanoseconds = ZERO;\n            break;\n        }\n        case 'hour': {\n            const divisor = 3600e9;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(hours), JSBI.BigInt(3600e9));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9)));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            hours = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            minutes = seconds = milliseconds = microseconds = 0;\n            break;\n        }\n        case 'minute': {\n            const divisor = 60e9;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(minutes), JSBI.BigInt(60e9));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(seconds), BILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            minutes = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            seconds = milliseconds = microseconds = 0;\n            break;\n        }\n        case 'second': {\n            const divisor = 1e9;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(seconds), BILLION);\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(milliseconds), MILLION));\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            seconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            milliseconds = microseconds = 0;\n            break;\n        }\n        case 'millisecond': {\n            const divisor = 1e6;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(milliseconds), MILLION);\n            allNanoseconds = JSBI.add(allNanoseconds, JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND));\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            milliseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            microseconds = 0;\n            break;\n        }\n        case 'microsecond': {\n            const divisor = 1e3;\n            let allNanoseconds = JSBI.multiply(JSBI.BigInt(microseconds), THOUSAND);\n            allNanoseconds = JSBI.add(allNanoseconds, nanoseconds);\n            total = JSBI.toNumber(allNanoseconds) / divisor;\n            const rounded = RoundNumberToIncrement(allNanoseconds, divisor * increment, roundingMode);\n            microseconds = JSBI.toNumber(JSBI.divide(rounded, JSBI.BigInt(divisor)));\n            nanoseconds = ZERO;\n            break;\n        }\n        case 'nanosecond': {\n            total = JSBI.toNumber(nanoseconds);\n            nanoseconds = RoundNumberToIncrement(nanoseconds, increment, roundingMode);\n            break;\n        }\n    }\n    return {\n        years,\n        months,\n        weeks,\n        days,\n        hours,\n        minutes,\n        seconds,\n        milliseconds,\n        microseconds,\n        nanoseconds: JSBI.toNumber(nanoseconds),\n        total\n    };\n}\nexport function CompareISODate(y1, m1, d1, y2, m2, d2) {\n    for (const [x, y] of [\n        [y1, y2],\n        [m1, m2],\n        [d1, d2]\n    ]) {\n        if (x !== y)\n            return ComparisonResult(x - y);\n    }\n    return 0;\n}\nfunction NonNegativeModulo(x, y) {\n    let result = x % y;\n    if (ObjectIs(result, -0))\n        return 0;\n    if (result < 0)\n        result += y;\n    return result;\n}\nexport function ToBigIntExternal(arg) {\n    const jsbiBI = ToBigInt(arg);\n    if (typeof globalThis.BigInt !== 'undefined')\n        return globalThis.BigInt(jsbiBI.toString(10));\n    return jsbiBI;\n}\nexport function ToBigInt(arg) {\n    if (arg instanceof JSBI) {\n        return arg;\n    }\n    let prim = arg;\n    if (typeof arg === 'object') {\n        const toPrimFn = arg[Symbol.toPrimitive];\n        if (toPrimFn && typeof toPrimFn === 'function') {\n            prim = ReflectApply(toPrimFn, arg, ['number']);\n        }\n    }\n    switch (typeof prim) {\n        case 'undefined':\n        case 'object':\n        case 'number':\n        case 'symbol':\n        default:\n            throw new TypeError(`cannot convert ${typeof arg} to bigint`);\n        case 'string':\n            if (!prim.match(/^\\s*(?:[+-]?\\d+\\s*)?$/)) {\n                throw new SyntaxError('invalid BigInt syntax');\n            }\n        // eslint: no-fallthrough: false\n        case 'bigint':\n            try {\n                return JSBI.BigInt(prim.toString());\n            }\n            catch (e) {\n                if (e instanceof Error && e.message.startsWith('Invalid integer'))\n                    throw new SyntaxError(e.message);\n                throw e;\n            }\n        case 'boolean':\n            if (prim) {\n                return ONE;\n            }\n            else {\n                return ZERO;\n            }\n    }\n}\n// Note: This method returns values with bogus nanoseconds based on the previous iteration's\n// milliseconds. That way there is a guarantee that the full nanoseconds are always going to be\n// increasing at least and that the microsecond and nanosecond fields are likely to be non-zero.\nexport const SystemUTCEpochNanoSeconds = (() => {\n    let ns = JSBI.BigInt(Date.now() % 1e6);\n    return () => {\n        const ms = JSBI.BigInt(Date.now());\n        const result = JSBI.add(JSBI.multiply(ms, MILLION), ns);\n        ns = JSBI.remainder(ms, MILLION);\n        if (JSBI.greaterThan(result, NS_MAX))\n            return NS_MAX;\n        if (JSBI.lessThan(result, NS_MIN))\n            return NS_MIN;\n        return result;\n    };\n})();\nexport function SystemTimeZone() {\n    const fmt = new IntlDateTimeFormat('en-us');\n    const TemporalTimeZone = GetIntrinsic('%Temporal.TimeZone%');\n    return new TemporalTimeZone(ParseTemporalTimeZone(fmt.resolvedOptions().timeZone));\n}\nexport function ComparisonResult(value) {\n    return value < 0 ? -1 : value > 0 ? 1 : value;\n}\nexport function GetOptionsObject(options) {\n    if (options === undefined)\n        return ObjectCreate(null);\n    if (IsObject(options) && options !== null)\n        return options;\n    throw new TypeError(`Options parameter must be an object, not ${options === null ? 'null' : `${typeof options}`}`);\n}\nexport function CreateOnePropObject(propName, propValue) {\n    const o = ObjectCreate(null);\n    o[propName] = propValue;\n    return o;\n}\nfunction GetOption(options, property, allowedValues, fallback) {\n    let value = options[property];\n    if (value !== undefined) {\n        value = ToString(value);\n        if (!allowedValues.includes(value)) {\n            throw new RangeError(`${property} must be one of ${allowedValues.join(', ')}, not ${value}`);\n        }\n        return value;\n    }\n    return fallback;\n}\nfunction GetNumberOption(options, property, minimum, maximum, fallback) {\n    let valueRaw = options[property];\n    if (valueRaw === undefined)\n        return fallback;\n    const value = ToNumber(valueRaw);\n    if (NumberIsNaN(value) || value < minimum || value > maximum) {\n        throw new RangeError(`${String(property)} must be between ${minimum} and ${maximum}, not ${value}`);\n    }\n    return MathFloor(value);\n}\nexport function IsBuiltinCalendar(id) {\n    return ArrayIncludes.call(BUILTIN_CALENDAR_IDS, id);\n}\nconst OFFSET = new RegExp(`^${PARSE.offset.source}$`);\nfunction bisect(getState, leftParam, rightParam, lstateParam = getState(leftParam), rstateParam = getState(rightParam)) {\n    // This doesn't make much sense - why do these get converted unnecessarily?\n    let left = JSBI.BigInt(leftParam);\n    let right = JSBI.BigInt(rightParam);\n    let lstate = lstateParam;\n    let rstate = rstateParam;\n    while (JSBI.greaterThan(JSBI.subtract(right, left), ONE)) {\n        const middle = JSBI.divide(JSBI.add(left, right), JSBI.BigInt(2));\n        const mstate = getState(middle);\n        if (mstate === lstate) {\n            left = middle;\n            lstate = mstate;\n        }\n        else if (mstate === rstate) {\n            right = middle;\n            rstate = mstate;\n        }\n        else {\n            throw new Error(`invalid state in bisection ${lstate} - ${mstate} - ${rstate}`);\n        }\n    }\n    return right;\n}\nconst nsPerTimeUnit = {\n    hour: 3600e9,\n    minute: 60e9,\n    second: 1e9,\n    millisecond: 1e6,\n    microsecond: 1e3,\n    nanosecond: 1\n};\n//# sourceMappingURL=ecmascript.js.map","import * as ES from './ecmascript';\nimport { GetIntrinsic } from './intrinsicclass';\nimport { GetSlot, INSTANT, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CALENDAR, TIME_ZONE } from './slots';\nconst DATE = Symbol('date');\nconst YM = Symbol('ym');\nconst MD = Symbol('md');\nconst TIME = Symbol('time');\nconst DATETIME = Symbol('datetime');\nconst ZONED = Symbol('zoneddatetime');\nconst INST = Symbol('instant');\nconst ORIGINAL = Symbol('original');\nconst TZ_RESOLVED = Symbol('timezone');\nconst TZ_GIVEN = Symbol('timezone-id-given');\nconst CAL_ID = Symbol('calendar-id');\nconst LOCALE = Symbol('locale');\nconst OPTIONS = Symbol('options');\nconst descriptor = (value) => {\n    return {\n        value,\n        enumerable: true,\n        writable: false,\n        configurable: true\n    };\n};\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ObjectAssign = Object.assign;\nconst ObjectHasOwnProperty = Object.prototype.hasOwnProperty;\nconst ReflectApply = Reflect.apply;\n// Construction of built-in Intl.DateTimeFormat objects is sloooooow,\n// so we'll only create those instances when we need them.\n// See https://bugs.chromium.org/p/v8/issues/detail?id=6528\nfunction getPropLazy(obj, prop) {\n    let val = obj[prop];\n    if (typeof val === 'function') {\n        // If we get here, `val` is an \"amender function\". It will take the user's\n        // options and transform them into suitable options to be passed into the\n        // built-in (non-polyfill) Intl.DateTimeFormat constructor. These options\n        // will vary depending on the Temporal type, so that's why we store separate\n        // formatters in separate props on the polyfill's DateTimeFormat instances.\n        // The efficiency happens because we don't create an (expensive) formatter\n        // until the user calls toLocaleString for that Temporal type.\n        val = new IntlDateTimeFormat(obj[LOCALE], val(obj[OPTIONS]));\n        // TODO: can this be typed more cleanly?\n        obj[prop] = val;\n    }\n    return val;\n}\n// Similarly, lazy-init TimeZone instances.\nfunction getResolvedTimeZoneLazy(obj) {\n    let val = obj[TZ_RESOLVED];\n    if (typeof val === 'string') {\n        val = ES.ToTemporalTimeZone(val);\n        obj[TZ_RESOLVED] = val;\n    }\n    return val;\n}\nfunction DateTimeFormatImpl(locale = undefined, optionsParam = {}) {\n    if (!(this instanceof DateTimeFormatImpl)) {\n        return new DateTimeFormatImpl(locale, optionsParam);\n    }\n    const hasOptions = typeof optionsParam !== 'undefined';\n    const options = hasOptions ? ObjectAssign({}, optionsParam) : {};\n    // TODO: remove type assertion after Temporal types land in TS lib types\n    const original = new IntlDateTimeFormat(locale, options);\n    const ro = original.resolvedOptions();\n    // DateTimeFormat instances are very expensive to create. Therefore, they will\n    // be lazily created only when needed, using the locale and options provided.\n    // But it's possible for callers to mutate those inputs before lazy creation\n    // happens. For this reason, we clone the inputs instead of caching the\n    // original objects. To avoid the complexity of deep cloning any inputs that\n    // are themselves objects (e.g. the locales array, or options property values\n    // that will be coerced to strings), we rely on `resolvedOptions()` to do the\n    // coercion and cloning for us. Unfortunately, we can't just use the resolved\n    // options as-is because our options-amending logic adds additional fields if\n    // the user doesn't supply any unit fields like year, month, day, hour, etc.\n    // Therefore, we limit the properties in the clone to properties that were\n    // present in the original input.\n    if (hasOptions) {\n        const clonedResolved = ObjectAssign({}, ro);\n        for (const prop in clonedResolved) {\n            if (!ReflectApply(ObjectHasOwnProperty, options, [prop])) {\n                delete clonedResolved[prop];\n            }\n        }\n        this[OPTIONS] = clonedResolved;\n    }\n    else {\n        this[OPTIONS] = options;\n    }\n    this[TZ_GIVEN] = options.timeZone ? options.timeZone : null;\n    this[LOCALE] = ro.locale;\n    this[ORIGINAL] = original;\n    this[TZ_RESOLVED] = ro.timeZone;\n    this[CAL_ID] = ro.calendar;\n    this[DATE] = dateAmend;\n    this[YM] = yearMonthAmend;\n    this[MD] = monthDayAmend;\n    this[TIME] = timeAmend;\n    this[DATETIME] = datetimeAmend;\n    this[ZONED] = zonedDateTimeAmend;\n    this[INST] = instantAmend;\n    return undefined; // TODO: I couldn't satisfy TS without adding this. Is there another way?\n}\nObject.defineProperty(DateTimeFormatImpl, 'name', {\n    writable: true,\n    value: 'DateTimeFormat'\n});\nDateTimeFormatImpl.supportedLocalesOf = function (locales, options) {\n    return IntlDateTimeFormat.supportedLocalesOf(locales, options);\n};\nconst propertyDescriptors = {\n    resolvedOptions: descriptor(resolvedOptions),\n    format: descriptor(format),\n    formatRange: descriptor(formatRange)\n};\nif ('formatToParts' in IntlDateTimeFormat.prototype) {\n    propertyDescriptors.formatToParts = descriptor(formatToParts);\n}\nif ('formatRangeToParts' in IntlDateTimeFormat.prototype) {\n    propertyDescriptors.formatRangeToParts = descriptor(formatRangeToParts);\n}\nDateTimeFormatImpl.prototype = Object.create(IntlDateTimeFormat.prototype, propertyDescriptors);\n// Ensure that the prototype isn't writeable.\nObject.defineProperty(DateTimeFormatImpl, 'prototype', {\n    writable: false,\n    enumerable: false,\n    configurable: false\n});\nexport const DateTimeFormat = DateTimeFormatImpl;\nfunction resolvedOptions() {\n    return this[ORIGINAL].resolvedOptions();\n}\nfunction adjustFormatterTimeZone(formatter, timeZone) {\n    if (!timeZone)\n        return formatter;\n    const options = formatter.resolvedOptions();\n    if (options.timeZone === timeZone)\n        return formatter;\n    // Existing Intl isn't typed to accept Temporal-specific options and the lib\n    // types for resolved options are less restrictive than the types for options.\n    // For example, `weekday` is\n    // `'long' | 'short' | 'narrow'` in options but `string` in resolved options.\n    // TODO: investigate why, and file an issue against TS if it's a bug.\n    if (options['dateStyle'] || options['timeStyle']) {\n        // Unfortunately, Safari's resolvedOptions include parameters that will\n        // cause errors at runtime if passed along with\n        // dateStyle or timeStyle options as per\n        // https://tc39.es/proposal-intl-datetime-style/#table-datetimeformat-components.\n        // This has been fixed in newer versions of Safari:\n        // https://bugs.webkit.org/show_bug.cgi?id=231041\n        delete options['weekday'];\n        delete options['era'];\n        delete options['year'];\n        delete options['month'];\n        delete options['day'];\n        delete options['hour'];\n        delete options['minute'];\n        delete options['second'];\n        delete options['timeZoneName'];\n        delete options['hourCycle'];\n        delete options['hour12'];\n        delete options['dayPeriod'];\n    }\n    return new IntlDateTimeFormat(options.locale, { ...options, timeZone });\n}\n// TODO: investigate why there's a rest parameter here. Does this function really need to accept extra params?\n// And if so, why doesn't formatRange also accept extra params?\nfunction format(datetime, ...rest) {\n    let { instant, formatter, timeZone } = extractOverrides(datetime, this);\n    if (instant && formatter) {\n        formatter = adjustFormatterTimeZone(formatter, timeZone);\n        return formatter.format(instant.epochMilliseconds);\n    }\n    return this[ORIGINAL].format(datetime, ...rest);\n}\nfunction formatToParts(datetime, ...rest) {\n    let { instant, formatter, timeZone } = extractOverrides(datetime, this);\n    if (instant && formatter) {\n        formatter = adjustFormatterTimeZone(formatter, timeZone);\n        return formatter.formatToParts(instant.epochMilliseconds);\n    }\n    return this[ORIGINAL].formatToParts(datetime, ...rest);\n}\nfunction formatRange(a, b) {\n    if (isTemporalObject(a) || isTemporalObject(b)) {\n        if (!sameTemporalType(a, b)) {\n            throw new TypeError('Intl.DateTimeFormat.formatRange accepts two values of the same type');\n        }\n        const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);\n        const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);\n        if (atz && btz && atz !== btz) {\n            throw new RangeError('cannot format range between different time zones');\n        }\n        if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n            const formatter = adjustFormatterTimeZone(aformatter, atz);\n            // TODO: Remove type assertion after this method lands in TS lib types\n            return formatter.formatRange(aa.epochMilliseconds, bb.epochMilliseconds);\n        }\n    }\n    // TODO: Remove type assertion after this method lands in TS lib types\n    return this[ORIGINAL].formatRange(a, b);\n}\nfunction formatRangeToParts(a, b) {\n    if (isTemporalObject(a) || isTemporalObject(b)) {\n        if (!sameTemporalType(a, b)) {\n            throw new TypeError('Intl.DateTimeFormat.formatRangeToParts accepts two values of the same type');\n        }\n        const { instant: aa, formatter: aformatter, timeZone: atz } = extractOverrides(a, this);\n        const { instant: bb, formatter: bformatter, timeZone: btz } = extractOverrides(b, this);\n        if (atz && btz && atz !== btz) {\n            throw new RangeError('cannot format range between different time zones');\n        }\n        if (aa && bb && aformatter && bformatter && aformatter === bformatter) {\n            const formatter = adjustFormatterTimeZone(aformatter, atz);\n            // TODO: Remove type assertion after this method lands in TS lib types\n            return formatter.formatRangeToParts(aa.epochMilliseconds, bb.epochMilliseconds);\n        }\n    }\n    // TODO: Remove type assertion after this method lands in TS lib types\n    return this[ORIGINAL].formatRangeToParts(a, b);\n}\nfunction amend(optionsParam = {}, amended = {}) {\n    const options = ObjectAssign({}, optionsParam);\n    for (const opt of [\n        'year',\n        'month',\n        'day',\n        'hour',\n        'minute',\n        'second',\n        'weekday',\n        'dayPeriod',\n        'timeZoneName',\n        'dateStyle',\n        'timeStyle'\n    ]) {\n        options[opt] = opt in amended ? amended[opt] : options[opt];\n        if (options[opt] === false || options[opt] === undefined)\n            delete options[opt];\n    }\n    return options;\n}\nfunction timeAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        year: false,\n        month: false,\n        day: false,\n        weekday: false,\n        timeZoneName: false,\n        dateStyle: false\n    });\n    if (!hasTimeOptions(options)) {\n        options = ObjectAssign({}, options, {\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction yearMonthAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        day: false,\n        hour: false,\n        minute: false,\n        second: false,\n        weekday: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        dateStyle: false,\n        timeStyle: false\n    });\n    if (!('year' in options || 'month' in options)) {\n        options = ObjectAssign(options, { year: 'numeric', month: 'numeric' });\n    }\n    return options;\n}\nfunction monthDayAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        year: false,\n        hour: false,\n        minute: false,\n        second: false,\n        weekday: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        dateStyle: false,\n        timeStyle: false\n    });\n    if (!('month' in options || 'day' in options)) {\n        options = ObjectAssign({}, options, { month: 'numeric', day: 'numeric' });\n    }\n    return options;\n}\nfunction dateAmend(optionsParam) {\n    let options = amend(optionsParam, {\n        hour: false,\n        minute: false,\n        second: false,\n        dayPeriod: false,\n        timeZoneName: false,\n        timeStyle: false\n    });\n    if (!hasDateOptions(options)) {\n        options = ObjectAssign({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric'\n        });\n    }\n    return options;\n}\nfunction datetimeAmend(optionsParam) {\n    let options = amend(optionsParam, { timeZoneName: false });\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction zonedDateTimeAmend(optionsParam) {\n    let options = optionsParam;\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n        if (options.timeZoneName === undefined)\n            options.timeZoneName = 'short';\n    }\n    return options;\n}\nfunction instantAmend(optionsParam) {\n    let options = optionsParam;\n    if (!hasTimeOptions(options) && !hasDateOptions(options)) {\n        options = ObjectAssign({}, options, {\n            year: 'numeric',\n            month: 'numeric',\n            day: 'numeric',\n            hour: 'numeric',\n            minute: 'numeric',\n            second: 'numeric'\n        });\n    }\n    return options;\n}\nfunction hasDateOptions(options) {\n    return 'year' in options || 'month' in options || 'day' in options || 'weekday' in options || 'dateStyle' in options;\n}\nfunction hasTimeOptions(options) {\n    return ('hour' in options || 'minute' in options || 'second' in options || 'timeStyle' in options || 'dayPeriod' in options);\n}\nfunction isTemporalObject(obj) {\n    return (ES.IsTemporalDate(obj) ||\n        ES.IsTemporalTime(obj) ||\n        ES.IsTemporalDateTime(obj) ||\n        ES.IsTemporalZonedDateTime(obj) ||\n        ES.IsTemporalYearMonth(obj) ||\n        ES.IsTemporalMonthDay(obj) ||\n        ES.IsTemporalInstant(obj));\n}\nfunction sameTemporalType(x, y) {\n    if (!isTemporalObject(x) || !isTemporalObject(y))\n        return false;\n    if (ES.IsTemporalTime(x) && !ES.IsTemporalTime(y))\n        return false;\n    if (ES.IsTemporalDate(x) && !ES.IsTemporalDate(y))\n        return false;\n    if (ES.IsTemporalDateTime(x) && !ES.IsTemporalDateTime(y))\n        return false;\n    if (ES.IsTemporalZonedDateTime(x) && !ES.IsTemporalZonedDateTime(y))\n        return false;\n    if (ES.IsTemporalYearMonth(x) && !ES.IsTemporalYearMonth(y))\n        return false;\n    if (ES.IsTemporalMonthDay(x) && !ES.IsTemporalMonthDay(y))\n        return false;\n    if (ES.IsTemporalInstant(x) && !ES.IsTemporalInstant(y))\n        return false;\n    return true;\n}\nfunction extractOverrides(temporalObj, main) {\n    const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n    if (ES.IsTemporalTime(temporalObj)) {\n        const hour = GetSlot(temporalObj, ISO_HOUR);\n        const minute = GetSlot(temporalObj, ISO_MINUTE);\n        const second = GetSlot(temporalObj, ISO_SECOND);\n        const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n        const datetime = new DateTime(1970, 1, 1, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, TIME)\n        };\n    }\n    if (ES.IsTemporalYearMonth(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const referenceISODay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainYearMonth with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(isoYear, isoMonth, referenceISODay, 12, 0, 0, 0, 0, 0, calendar);\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, YM)\n        };\n    }\n    if (ES.IsTemporalMonthDay(temporalObj)) {\n        const referenceISOYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainMonthDay with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(referenceISOYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, calendar);\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, MD)\n        };\n    }\n    if (ES.IsTemporalDate(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainDate with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const datetime = new DateTime(isoYear, isoMonth, isoDay, 12, 0, 0, 0, 0, 0, main[CAL_ID]);\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, DATE)\n        };\n    }\n    if (ES.IsTemporalDateTime(temporalObj)) {\n        const isoYear = GetSlot(temporalObj, ISO_YEAR);\n        const isoMonth = GetSlot(temporalObj, ISO_MONTH);\n        const isoDay = GetSlot(temporalObj, ISO_DAY);\n        const hour = GetSlot(temporalObj, ISO_HOUR);\n        const minute = GetSlot(temporalObj, ISO_MINUTE);\n        const second = GetSlot(temporalObj, ISO_SECOND);\n        const millisecond = GetSlot(temporalObj, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalObj, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalObj, ISO_NANOSECOND);\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format PlainDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        let datetime = temporalObj;\n        if (calendar === 'iso8601') {\n            datetime = new DateTime(isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, main[CAL_ID]);\n        }\n        return {\n            instant: ES.BuiltinTimeZoneGetInstantFor(getResolvedTimeZoneLazy(main), datetime, 'compatible'),\n            formatter: getPropLazy(main, DATETIME)\n        };\n    }\n    if (ES.IsTemporalZonedDateTime(temporalObj)) {\n        const calendar = ES.ToString(GetSlot(temporalObj, CALENDAR));\n        if (calendar !== 'iso8601' && calendar !== main[CAL_ID]) {\n            throw new RangeError(`cannot format ZonedDateTime with calendar ${calendar} in locale with calendar ${main[CAL_ID]}`);\n        }\n        const timeZone = GetSlot(temporalObj, TIME_ZONE);\n        const objTimeZone = ES.ToString(timeZone);\n        if (main[TZ_GIVEN] && main[TZ_GIVEN] !== objTimeZone) {\n            throw new RangeError(`timeZone option ${main[TZ_GIVEN]} doesn't match actual time zone ${objTimeZone}`);\n        }\n        return {\n            instant: GetSlot(temporalObj, INSTANT),\n            formatter: getPropLazy(main, ZONED),\n            timeZone: objTimeZone\n        };\n    }\n    if (ES.IsTemporalInstant(temporalObj)) {\n        return {\n            instant: temporalObj,\n            formatter: getPropLazy(main, INST)\n        };\n    }\n    return {};\n}\n//# sourceMappingURL=intl.js.map","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { EPOCHNANOSECONDS, CreateSlots, GetSlot, SetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nimport JSBI from 'jsbi';\nimport { BILLION, MILLION, THOUSAND } from './ecmascript';\nexport class Instant {\n    constructor(epochNanoseconds) {\n        // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n        //       to improve the error message.\n        if (arguments.length < 1) {\n            throw new TypeError('missing argument: epochNanoseconds is required');\n        }\n        const ns = ES.ToBigInt(epochNanoseconds);\n        ES.ValidateEpochNanoseconds(ns);\n        CreateSlots(this);\n        SetSlot(this, EPOCHNANOSECONDS, ns);\n        if (DEBUG) {\n            const repr = ES.TemporalInstantToString(this, undefined, 'auto');\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${repr}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get epochSeconds() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return JSBI.toNumber(JSBI.divide(value, BILLION));\n    }\n    get epochMilliseconds() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n        return JSBI.toNumber(JSBI.divide(value, MILLION));\n    }\n    get epochMicroseconds() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const value = JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS));\n        return ES.ToBigIntExternal(JSBI.divide(value, THOUSAND));\n    }\n    get epochNanoseconds() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToBigIntExternal(JSBI.BigInt(GetSlot(this, EPOCHNANOSECONDS)));\n    }\n    add(temporalDurationLike) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return ES.AddDurationToOrSubtractDurationFromInstant('add', this, temporalDurationLike);\n    }\n    subtract(temporalDurationLike) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return ES.AddDurationToOrSubtractDurationFromInstant('subtract', this, temporalDurationLike);\n    }\n    until(other, options = undefined) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return ES.DifferenceTemporalInstant('until', this, other, options);\n    }\n    since(other, options = undefined) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return ES.DifferenceTemporalInstant('since', this, other, options);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', ES.REQUIRED);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            hour: 24,\n            minute: 1440,\n            second: 86400,\n            millisecond: 86400e3,\n            microsecond: 86400e6,\n            nanosecond: 86400e9\n        };\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], true);\n        const ns = GetSlot(this, EPOCHNANOSECONDS);\n        const roundedNs = ES.RoundInstant(ns, roundingIncrement, smallestUnit, roundingMode);\n        return new Instant(roundedNs);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalInstant(otherParam);\n        const one = GetSlot(this, EPOCHNANOSECONDS);\n        const two = GetSlot(other, EPOCHNANOSECONDS);\n        return JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        let timeZone = options.timeZone;\n        if (timeZone !== undefined)\n            timeZone = ES.ToTemporalTimeZone(timeZone);\n        // Although TS doesn't acknowledge it, below here `timeZone` is a Temporal.TimeZoneProtocol\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const ns = GetSlot(this, EPOCHNANOSECONDS);\n        const roundedNs = ES.RoundInstant(ns, increment, unit, roundingMode);\n        const roundedInstant = new Instant(roundedNs);\n        return ES.TemporalInstantToString(roundedInstant, timeZone, precision);\n    }\n    toJSON() {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalInstantToString(this, undefined, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.Instant');\n    }\n    toZonedDateTime(item) {\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(item)) {\n            throw new TypeError('invalid argument in toZonedDateTime');\n        }\n        const calendarLike = item.calendar;\n        if (calendarLike === undefined) {\n            throw new TypeError('missing calendar property in toZonedDateTime');\n        }\n        const calendar = ES.ToTemporalCalendar(calendarLike);\n        const temporalTimeZoneLike = item.timeZone;\n        if (temporalTimeZoneLike === undefined) {\n            throw new TypeError('missing timeZone property in toZonedDateTime');\n        }\n        const timeZone = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n        return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toZonedDateTimeISO(itemParam) {\n        let item = itemParam;\n        if (!ES.IsTemporalInstant(this))\n            throw new TypeError('invalid receiver');\n        if (ES.IsObject(item)) {\n            const timeZoneProperty = item.timeZone;\n            if (timeZoneProperty !== undefined) {\n                item = timeZoneProperty;\n            }\n        }\n        const timeZone = ES.ToTemporalTimeZone(item);\n        const calendar = ES.GetISO8601Calendar();\n        return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    static fromEpochSeconds(epochSecondsParam) {\n        const epochSeconds = ES.ToNumber(epochSecondsParam);\n        const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochSeconds), BILLION);\n        ES.ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochMilliseconds(epochMillisecondsParam) {\n        const epochMilliseconds = ES.ToNumber(epochMillisecondsParam);\n        const epochNanoseconds = JSBI.multiply(JSBI.BigInt(epochMilliseconds), MILLION);\n        ES.ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochMicroseconds(epochMicrosecondsParam) {\n        const epochMicroseconds = ES.ToBigInt(epochMicrosecondsParam);\n        const epochNanoseconds = JSBI.multiply(epochMicroseconds, THOUSAND);\n        ES.ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static fromEpochNanoseconds(epochNanosecondsParam) {\n        const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n        ES.ValidateEpochNanoseconds(epochNanoseconds);\n        return new Instant(epochNanoseconds);\n    }\n    static from(item) {\n        if (ES.IsTemporalInstant(item)) {\n            return new Instant(GetSlot(item, EPOCHNANOSECONDS));\n        }\n        return ES.ToTemporalInstant(item);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalInstant(oneParam);\n        const two = ES.ToTemporalInstant(twoParam);\n        const oneNs = GetSlot(one, EPOCHNANOSECONDS);\n        const twoNs = GetSlot(two, EPOCHNANOSECONDS);\n        if (JSBI.lessThan(oneNs, twoNs))\n            return -1;\n        if (JSBI.greaterThan(oneNs, twoNs))\n            return 1;\n        return 0;\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(Instant, 'Temporal.Instant');\n//# sourceMappingURL=instant.js.map","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass, DefineIntrinsic } from './intrinsicclass';\nimport { CALENDAR_ID, ISO_YEAR, ISO_MONTH, ISO_DAY, YEARS, MONTHS, WEEKS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS, CreateSlots, GetSlot, HasSlot, SetSlot } from './slots';\nconst ArrayIncludes = Array.prototype.includes;\nconst ArrayPrototypePush = Array.prototype.push;\nconst IntlDateTimeFormat = globalThis.Intl.DateTimeFormat;\nconst ArraySort = Array.prototype.sort;\nconst MathAbs = Math.abs;\nconst MathFloor = Math.floor;\nconst ObjectEntries = Object.entries;\nconst ObjectKeys = Object.keys;\n/**\n * Implementations for each calendar. Non-ISO calendars have an extra `helper`\n * property that provides additional per-calendar logic.\n */\nconst impl = {};\n/**\n * Thin wrapper around the implementation of each built-in calendar. This\n * class's methods follow a similar pattern:\n * 1. Validate parameters\n * 2. Fill in default options (for methods where options are present)\n * 3. Simplify and/or normalize parameters. For example, some methods accept\n *    PlainDate, PlainDateTime, ZonedDateTime, etc. and these are normalized to\n *    PlainDate.\n * 4. Look up the ID of the built-in calendar\n * 5. Fetch the implementation object for that ID.\n * 6. Call the corresponding method in the implementation object.\n */\nexport class Calendar {\n    constructor(idParam) {\n        // Note: if the argument is not passed, IsBuiltinCalendar(\"undefined\") will fail. This check\n        //       exists only to improve the error message.\n        if (arguments.length < 1) {\n            throw new RangeError('missing argument: id is required');\n        }\n        const id = ES.ToString(idParam);\n        if (!ES.IsBuiltinCalendar(id))\n            throw new RangeError(`invalid calendar identifier ${id}`);\n        CreateSlots(this);\n        SetSlot(this, CALENDAR_ID, id);\n        if (DEBUG) {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${id}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get id() {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(this);\n    }\n    dateFromFields(fields, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = ES.GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dateFromFields(fields, options, this);\n    }\n    yearMonthFromFields(fields, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = ES.GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].yearMonthFromFields(fields, options, this);\n    }\n    monthDayFromFields(fields, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(fields))\n            throw new TypeError('invalid fields');\n        const options = ES.GetOptionsObject(optionsParam);\n        return impl[GetSlot(this, CALENDAR_ID)].monthDayFromFields(fields, options, this);\n    }\n    fields(fields) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const fieldsArray = [];\n        const allowed = new Set([\n            'year',\n            'month',\n            'monthCode',\n            'day',\n            'hour',\n            'minute',\n            'second',\n            'millisecond',\n            'microsecond',\n            'nanosecond'\n        ]);\n        for (const name of fields) {\n            if (typeof name !== 'string')\n                throw new TypeError('invalid fields');\n            if (!allowed.has(name))\n                throw new RangeError(`invalid field name ${name}`);\n            allowed.delete(name);\n            ArrayPrototypePush.call(fieldsArray, name);\n        }\n        return impl[GetSlot(this, CALENDAR_ID)].fields(fieldsArray);\n    }\n    mergeFields(fields, additionalFields) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return impl[GetSlot(this, CALENDAR_ID)].mergeFields(fields, additionalFields);\n    }\n    dateAdd(dateParam, durationParam, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        const duration = ES.ToTemporalDuration(durationParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const overflow = ES.ToTemporalOverflow(options);\n        const { days } = ES.BalanceDuration(GetSlot(duration, DAYS), GetSlot(duration, HOURS), GetSlot(duration, MINUTES), GetSlot(duration, SECONDS), GetSlot(duration, MILLISECONDS), GetSlot(duration, MICROSECONDS), GetSlot(duration, NANOSECONDS), 'day');\n        return impl[GetSlot(this, CALENDAR_ID)].dateAdd(date, GetSlot(duration, YEARS), GetSlot(duration, MONTHS), GetSlot(duration, WEEKS), days, overflow, this);\n    }\n    dateUntil(oneParam, twoParam, optionsParam = undefined) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const one = ES.ToTemporalDate(oneParam);\n        const two = ES.ToTemporalDate(twoParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        let largestUnit = ES.GetTemporalUnit(options, 'largestUnit', 'date', 'auto');\n        if (largestUnit === 'auto')\n            largestUnit = 'day';\n        const { years, months, weeks, days } = impl[GetSlot(this, CALENDAR_ID)].dateUntil(one, two, largestUnit);\n        const Duration = GetIntrinsic('%Temporal.Duration%');\n        return new Duration(years, months, weeks, days, 0, 0, 0, 0, 0, 0);\n    }\n    year(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].year(date);\n    }\n    month(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (ES.IsTemporalMonthDay(date))\n            throw new TypeError('use monthCode on PlainMonthDay instead');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].month(date);\n    }\n    monthCode(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date) && !ES.IsTemporalMonthDay(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].monthCode(date);\n    }\n    day(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalMonthDay(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].day(date);\n    }\n    era(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].era(date);\n    }\n    eraYear(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].eraYear(date);\n    }\n    dayOfWeek(dateParam) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dayOfWeek(date);\n    }\n    dayOfYear(dateParam) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].dayOfYear(date);\n    }\n    weekOfYear(dateParam) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].weekOfYear(date);\n    }\n    daysInWeek(dateParam) {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        const date = ES.ToTemporalDate(dateParam);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInWeek(date);\n    }\n    daysInMonth(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInMonth(date);\n    }\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].daysInYear(date);\n    }\n    monthsInYear(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].monthsInYear(date);\n    }\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsTemporalYearMonth(date))\n            date = ES.ToTemporalDate(date);\n        return impl[GetSlot(this, CALENDAR_ID)].inLeapYear(date);\n    }\n    toString() {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR_ID);\n    }\n    toJSON() {\n        if (!ES.IsTemporalCalendar(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(this);\n    }\n    static from(item) {\n        return ES.ToTemporalCalendar(item);\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(Calendar, 'Temporal.Calendar');\nDefineIntrinsic('Temporal.Calendar.from', Calendar.from);\n/**\n * Implementation for the ISO 8601 calendar. This is the only calendar that's\n * guaranteed to be supported by all ECMAScript implementations, including those\n * without Intl (ECMA-402) support.\n */\nimpl['iso8601'] = {\n    dateFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        let fields = ES.PrepareTemporalFields(fieldsParam, ['day', 'month', 'monthCode', 'year'], ['year', 'day']);\n        fields = resolveNonLunisolarMonth(fields);\n        let { year, month, day } = fields;\n        ({ year, month, day } = ES.RegulateISODate(year, month, day, overflow));\n        return ES.CreateTemporalDate(year, month, day, calendar);\n    },\n    yearMonthFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        let fields = ES.PrepareTemporalFields(fieldsParam, ['month', 'monthCode', 'year'], ['year']);\n        fields = resolveNonLunisolarMonth(fields);\n        let { year, month } = fields;\n        ({ year, month } = ES.RegulateISOYearMonth(year, month, overflow));\n        return ES.CreateTemporalYearMonth(year, month, calendar, /* referenceISODay = */ 1);\n    },\n    monthDayFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        let fields = ES.PrepareTemporalFields(fieldsParam, ['day', 'month', 'monthCode', 'year'], ['day']);\n        if (fields.month !== undefined && fields.year === undefined && fields.monthCode === undefined) {\n            throw new TypeError('either year or monthCode required with month');\n        }\n        const useYear = fields.monthCode === undefined;\n        const referenceISOYear = 1972;\n        fields = resolveNonLunisolarMonth(fields);\n        let { month, day, year } = fields;\n        ({ month, day } = ES.RegulateISODate(useYear ? year : referenceISOYear, month, day, overflow));\n        return ES.CreateTemporalMonthDay(month, day, calendar, referenceISOYear);\n    },\n    fields(fields) {\n        return fields;\n    },\n    mergeFields(fields, additionalFields) {\n        const merged = {};\n        for (const nextKey of ObjectKeys(fields)) {\n            if (nextKey === 'month' || nextKey === 'monthCode')\n                continue;\n            merged[nextKey] = fields[nextKey];\n        }\n        const newKeys = ObjectKeys(additionalFields);\n        for (const nextKey of newKeys) {\n            merged[nextKey] = additionalFields[nextKey];\n        }\n        if (!ArrayIncludes.call(newKeys, 'month') && !ArrayIncludes.call(newKeys, 'monthCode')) {\n            const { month, monthCode } = fields;\n            if (month !== undefined)\n                merged.month = month;\n            if (monthCode !== undefined)\n                merged.monthCode = monthCode;\n        }\n        return merged;\n    },\n    dateAdd(date, years, months, weeks, days, overflow, calendar) {\n        let year = GetSlot(date, ISO_YEAR);\n        let month = GetSlot(date, ISO_MONTH);\n        let day = GetSlot(date, ISO_DAY);\n        ({ year, month, day } = ES.AddISODate(year, month, day, years, months, weeks, days, overflow));\n        return ES.CreateTemporalDate(year, month, day, calendar);\n    },\n    dateUntil(one, two, largestUnit) {\n        return ES.DifferenceISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY), largestUnit);\n    },\n    year(date) {\n        return GetSlot(date, ISO_YEAR);\n    },\n    era() {\n        return undefined;\n    },\n    eraYear() {\n        return undefined;\n    },\n    month(date) {\n        return GetSlot(date, ISO_MONTH);\n    },\n    monthCode(date) {\n        return buildMonthCode(GetSlot(date, ISO_MONTH));\n    },\n    day(date) {\n        return GetSlot(date, ISO_DAY);\n    },\n    dayOfWeek(date) {\n        return ES.DayOfWeek(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    dayOfYear(date) {\n        return ES.DayOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    weekOfYear(date) {\n        return ES.WeekOfYear(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH), GetSlot(date, ISO_DAY));\n    },\n    daysInWeek() {\n        return 7;\n    },\n    daysInMonth(date) {\n        return ES.ISODaysInMonth(GetSlot(date, ISO_YEAR), GetSlot(date, ISO_MONTH));\n    },\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ES.ToTemporalDate(date);\n        return ES.LeapYear(GetSlot(date, ISO_YEAR)) ? 366 : 365;\n    },\n    monthsInYear() {\n        return 12;\n    },\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ES.ToTemporalDate(date);\n        return ES.LeapYear(GetSlot(date, ISO_YEAR));\n    }\n};\nfunction monthCodeNumberPart(monthCode) {\n    if (!monthCode.startsWith('M')) {\n        throw new RangeError(`Invalid month code: ${monthCode}.  Month codes must start with M.`);\n    }\n    const month = +monthCode.slice(1);\n    if (isNaN(month))\n        throw new RangeError(`Invalid month code: ${monthCode}`);\n    return month;\n}\nfunction buildMonthCode(month, leap = false) {\n    return `M${month.toString().padStart(2, '0')}${leap ? 'L' : ''}`;\n}\n/**\n * Safely merge a month, monthCode pair into an integer month.\n * If both are present, make sure they match.\n * This logic doesn't work for lunisolar calendars!\n * */\nfunction resolveNonLunisolarMonth(calendarDate, overflow = undefined, monthsPerYear = 12) {\n    let { month, monthCode } = calendarDate;\n    if (monthCode === undefined) {\n        if (month === undefined)\n            throw new TypeError('Either month or monthCode are required');\n        // The ISO calendar uses the default (undefined) value because it does\n        // constrain/reject after this method returns. Non-ISO calendars, however,\n        // rely on this function to constrain/reject out-of-range `month` values.\n        if (overflow === 'reject')\n            ES.RejectToRange(month, 1, monthsPerYear);\n        if (overflow === 'constrain')\n            month = ES.ConstrainToRange(month, 1, monthsPerYear);\n        monthCode = buildMonthCode(month);\n    }\n    else {\n        const numberPart = monthCodeNumberPart(monthCode);\n        if (month !== undefined && month !== numberPart) {\n            throw new RangeError(`monthCode ${monthCode} and month ${month} must match if both are present`);\n        }\n        if (monthCode !== buildMonthCode(numberPart)) {\n            throw new RangeError(`Invalid month code: ${monthCode}`);\n        }\n        month = numberPart;\n        if (month < 1 || month > monthsPerYear)\n            throw new RangeError(`Invalid monthCode: ${monthCode}`);\n    }\n    return { ...calendarDate, month, monthCode };\n}\n/**\n * This prototype implementation of non-ISO calendars makes many repeated calls\n * to Intl APIs which may be slow (e.g. >0.2ms). This trivial cache will speed\n * up these repeat accesses. Each cache instance is associated (via a WeakMap)\n * to a specific Temporal object, which speeds up multiple calendar calls on the\n * same Temporal object instance.  No invalidation or pruning is necessary\n * because each object's cache is thrown away when the object is GC-ed.\n */\nclass OneObjectCache {\n    constructor(cacheToClone) {\n        this.map = new Map();\n        this.calls = 0;\n        this.hits = 0;\n        this.misses = 0;\n        this.now = globalThis.performance ? globalThis.performance.now() : Date.now();\n        if (cacheToClone !== undefined) {\n            let i = 0;\n            for (const entry of cacheToClone.map.entries()) {\n                if (++i > OneObjectCache.MAX_CACHE_ENTRIES)\n                    break;\n                this.map.set(...entry);\n            }\n        }\n    }\n    get(key) {\n        const result = this.map.get(key);\n        if (result) {\n            this.hits++;\n            this.report();\n        }\n        this.calls++;\n        return result;\n    }\n    set(key, value) {\n        this.map.set(key, value);\n        this.misses++;\n        this.report();\n    }\n    report() {\n        /*\n        if (this.calls === 0) return;\n        const ms = (globalThis.performance ? globalThis.performance.now() : Date.now()) - this.now;\n        const hitRate = ((100 * this.hits) / this.calls).toFixed(0);\n        console.log(`${this.calls} calls in ${ms.toFixed(2)}ms. Hits: ${this.hits} (${hitRate}%). Misses: ${this.misses}.`);\n        */\n    }\n    setObject(obj) {\n        if (OneObjectCache.objectMap.get(obj))\n            throw new RangeError('object already cached');\n        OneObjectCache.objectMap.set(obj, this);\n        this.report();\n    }\n    /**\n     * Returns a WeakMap-backed cache that's used to store expensive results\n     * that are associated with a particular Temporal object instance.\n     *\n     * @param obj - object to associate with the cache\n     */\n    static getCacheForObject(obj) {\n        let cache = OneObjectCache.objectMap.get(obj);\n        if (!cache) {\n            cache = new OneObjectCache();\n            OneObjectCache.objectMap.set(obj, cache);\n        }\n        return cache;\n    }\n}\nOneObjectCache.objectMap = new WeakMap();\nOneObjectCache.MAX_CACHE_ENTRIES = 1000;\nfunction toUtcIsoDateString({ isoYear, isoMonth, isoDay }) {\n    const yearString = ES.ISOYearString(isoYear);\n    const monthString = ES.ISODateTimePartString(isoMonth);\n    const dayString = ES.ISODateTimePartString(isoDay);\n    return `${yearString}-${monthString}-${dayString}T00:00Z`;\n}\nfunction simpleDateDiff(one, two) {\n    return {\n        years: one.year - two.year,\n        months: one.month - two.month,\n        days: one.day - two.day\n    };\n}\n/**\n * Implementation helper that's common to all non-ISO calendars\n */\nclass HelperBase {\n    constructor() {\n        // The short era format works for all calendars except Japanese, which will\n        // override.\n        this.eraLength = 'short';\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = true;\n    }\n    getFormatter() {\n        // `new Intl.DateTimeFormat()` is amazingly slow and chews up RAM. Per\n        // https://bugs.chromium.org/p/v8/issues/detail?id=6528#c4, we cache one\n        // DateTimeFormat instance per calendar. Caching is lazy so we only pay for\n        // calendars that are used. Note that the nonIsoHelperBase object is spread\n        // into each each calendar's implementation before any cache is created, so\n        // each calendar gets its own separate cached formatter.\n        if (typeof this.formatter === 'undefined') {\n            this.formatter = new IntlDateTimeFormat(`en-US-u-ca-${this.id}`, {\n                day: 'numeric',\n                month: 'numeric',\n                year: 'numeric',\n                era: this.eraLength,\n                timeZone: 'UTC'\n            });\n        }\n        return this.formatter;\n    }\n    isoToCalendarDate(isoDate, cache) {\n        const { year: isoYear, month: isoMonth, day: isoDay } = isoDate;\n        const key = JSON.stringify({ func: 'isoToCalendarDate', isoYear, isoMonth, isoDay, id: this.id });\n        const cached = cache.get(key);\n        if (cached)\n            return cached;\n        const dateTimeFormat = this.getFormatter();\n        let parts, isoString;\n        try {\n            isoString = toUtcIsoDateString({ isoYear, isoMonth, isoDay });\n            parts = dateTimeFormat.formatToParts(new Date(isoString));\n        }\n        catch (e) {\n            throw new RangeError(`Invalid ISO date: ${JSON.stringify({ isoYear, isoMonth, isoDay })}`);\n        }\n        const result = {};\n        for (let { type, value } of parts) {\n            if (type === 'year')\n                result.eraYear = +value;\n            // TODO: remove this type annotation when `relatedYear` gets into TS lib types\n            if (type === 'relatedYear')\n                result.eraYear = +value;\n            if (type === 'month') {\n                const matches = /^([0-9]*)(.*?)$/.exec(value);\n                if (!matches || matches.length != 3 || (!matches[1] && !matches[2])) {\n                    throw new RangeError(`Unexpected month: ${value}`);\n                }\n                // If the month has no numeric part (should only see this for the Hebrew\n                // calendar with newer FF / Chromium versions; see\n                // https://bugzilla.mozilla.org/show_bug.cgi?id=1751833) then set a\n                // placeholder month index of `1` and rely on the derived class to\n                // calculate the correct month index from the month name stored in\n                // `monthExtra`.\n                result.month = matches[1] ? +matches[1] : 1;\n                if (result.month < 1) {\n                    throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n                        ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10527)');\n                }\n                if (result.month > 13) {\n                    throw new RangeError(`Invalid month ${value} from ${isoString}[u-ca-${this.id}]` +\n                        ' (probably due to https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n                }\n                // The ICU formats for the Hebrew calendar no longer support a numeric\n                // month format. So we'll rely on the derived class to interpret it.\n                // `monthExtra` is also used on the Chinese calendar to handle a suffix\n                // \"bis\" indicating a leap month.\n                if (matches[2])\n                    result.monthExtra = matches[2];\n            }\n            if (type === 'day')\n                result.day = +value;\n            if (this.hasEra && type === 'era' && value != null && value !== '') {\n                // The convention for Temporal era values is lowercase, so following\n                // that convention in this prototype. Punctuation is removed, accented\n                // letters are normalized, and spaces are replaced with dashes.\n                // E.g.: \"ERA0\" => \"era0\", \"Before R.O.C.\" => \"before-roc\", \"En’ō\" => \"eno\"\n                // The call to normalize() and the replacement regex deals with era\n                // names that contain non-ASCII characters like Japanese eras. Also\n                // ignore extra content in parentheses like JPN era date ranges.\n                value = value.split(' (')[0];\n                result.era = value\n                    .normalize('NFD')\n                    .replace(/[^-0-9 \\p{L}]/gu, '')\n                    .replace(' ', '-')\n                    .toLowerCase();\n            }\n        }\n        if (result.eraYear === undefined) {\n            // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n            // output of Intl.DateTimeFormat.formatToParts.\n            throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n        }\n        // Translate eras that may be handled differently by Temporal vs. by Intl\n        // (e.g. Japanese pre-Meiji eras). See https://github.com/tc39/proposal-temporal/issues/526.\n        if (this.reviseIntlEra) {\n            const { era, eraYear } = this.reviseIntlEra(result, isoDate);\n            result.era = era;\n            result.eraYear = eraYear;\n        }\n        if (this.checkIcuBugs)\n            this.checkIcuBugs(isoDate);\n        const calendarDate = this.adjustCalendarDate(result, cache, 'constrain', true);\n        if (calendarDate.year === undefined)\n            throw new RangeError(`Missing year converting ${JSON.stringify(isoDate)}`);\n        if (calendarDate.month === undefined)\n            throw new RangeError(`Missing month converting ${JSON.stringify(isoDate)}`);\n        if (calendarDate.day === undefined)\n            throw new RangeError(`Missing day converting ${JSON.stringify(isoDate)}`);\n        cache.set(key, calendarDate);\n        // Also cache the reverse mapping\n        ['constrain', 'reject'].forEach((overflow) => {\n            const keyReverse = JSON.stringify({\n                func: 'calendarToIsoDate',\n                year: calendarDate.year,\n                month: calendarDate.month,\n                day: calendarDate.day,\n                overflow,\n                id: this.id\n            });\n            cache.set(keyReverse, isoDate);\n        });\n        return calendarDate;\n    }\n    validateCalendarDate(calendarDate) {\n        const { era, month, year, day, eraYear, monthCode, monthExtra } = calendarDate;\n        // When there's a suffix (e.g. \"5bis\" for a leap month in Chinese calendar)\n        // the derived class must deal with it.\n        if (monthExtra !== undefined)\n            throw new RangeError('Unexpected `monthExtra` value');\n        if (year === undefined && eraYear === undefined)\n            throw new TypeError('year or eraYear is required');\n        if (month === undefined && monthCode === undefined)\n            throw new TypeError('month or monthCode is required');\n        if (day === undefined)\n            throw new RangeError('Missing day');\n        if (monthCode !== undefined) {\n            if (typeof monthCode !== 'string') {\n                throw new RangeError(`monthCode must be a string, not ${typeof monthCode}`);\n            }\n            if (!/^M([01]?\\d)(L?)$/.test(monthCode))\n                throw new RangeError(`Invalid monthCode: ${monthCode}`);\n        }\n        if (this.constantEra) {\n            if (era !== undefined && era !== this.constantEra) {\n                throw new RangeError(`era must be ${this.constantEra}, not ${era}`);\n            }\n            if (eraYear !== undefined && year !== undefined && eraYear !== year) {\n                throw new RangeError(`eraYear ${eraYear} does not match year ${year}`);\n            }\n        }\n    }\n    /**\n     * Allows derived calendars to add additional fields and/or to make\n     * adjustments e.g. to set the era based on the date or to revise the month\n     * number in lunisolar calendars per\n     * https://github.com/tc39/proposal-temporal/issues/1203.\n     *\n     * The base implementation fills in missing values by assuming the simplest\n     * possible calendar:\n     * - no eras or a constant era defined in `.constantEra`\n     * - non-lunisolar calendar (no leap months)\n     * */\n    adjustCalendarDate(calendarDateParam, cache = undefined, overflow = 'constrain', \n    // This param is only used by derived classes\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    fromLegacyDate = false) {\n        if (this.calendarType === 'lunisolar')\n            throw new RangeError('Override required for lunisolar calendars');\n        let calendarDate = calendarDateParam;\n        this.validateCalendarDate(calendarDate);\n        // For calendars that always use the same era, set it here so that derived\n        // calendars won't need to implement this method simply to set the era.\n        if (this.constantEra) {\n            // year and eraYear always match when there's only one possible era\n            const { year, eraYear } = calendarDate;\n            calendarDate = {\n                ...calendarDate,\n                era: this.constantEra,\n                year: year !== undefined ? year : eraYear,\n                eraYear: eraYear !== undefined ? eraYear : year\n            };\n        }\n        const largestMonth = this.monthsInYear(calendarDate, cache);\n        let { month, monthCode } = calendarDate;\n        ({ month, monthCode } = resolveNonLunisolarMonth(calendarDate, overflow, largestMonth));\n        return { ...calendarDate, month, monthCode };\n    }\n    regulateMonthDayNaive(calendarDate, overflow, cache) {\n        const largestMonth = this.monthsInYear(calendarDate, cache);\n        let { month, day } = calendarDate;\n        if (overflow === 'reject') {\n            ES.RejectToRange(month, 1, largestMonth);\n            ES.RejectToRange(day, 1, this.maximumMonthLength(calendarDate));\n        }\n        else {\n            month = ES.ConstrainToRange(month, 1, largestMonth);\n            day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ ...calendarDate, month }));\n        }\n        return { ...calendarDate, month, day };\n    }\n    calendarToIsoDate(dateParam, overflow = 'constrain', cache) {\n        const originalDate = dateParam;\n        // First, normalize the calendar date to ensure that (year, month, day)\n        // are all present, converting monthCode and eraYear if needed.\n        let date = this.adjustCalendarDate(dateParam, cache, overflow, false);\n        // Fix obviously out-of-bounds values. Values that are valid generally, but\n        // not in this particular year, may not be caught here for some calendars.\n        // If so, these will be handled lower below.\n        date = this.regulateMonthDayNaive(date, overflow, cache);\n        const { year, month, day } = date;\n        const key = JSON.stringify({ func: 'calendarToIsoDate', year, month, day, overflow, id: this.id });\n        let cached = cache.get(key);\n        if (cached)\n            return cached;\n        // If YMD are present in the input but the input has been constrained\n        // already, then cache both the original value and the constrained value.\n        let keyOriginal;\n        if (originalDate.year !== undefined &&\n            originalDate.month !== undefined &&\n            originalDate.day !== undefined &&\n            (originalDate.year !== date.year || originalDate.month !== date.month || originalDate.day !== date.day)) {\n            keyOriginal = JSON.stringify({\n                func: 'calendarToIsoDate',\n                year: originalDate.year,\n                month: originalDate.month,\n                day: originalDate.day,\n                overflow,\n                id: this.id\n            });\n            cached = cache.get(keyOriginal);\n            if (cached)\n                return cached;\n        }\n        // First, try to roughly guess the result\n        let isoEstimate = this.estimateIsoDate({ year, month, day });\n        const calculateSameMonthResult = (diffDays) => {\n            // If the estimate is in the same year & month as the target, then we can\n            // calculate the result exactly and short-circuit any additional logic.\n            // This optimization assumes that months are continuous. It would break if\n            // a calendar skipped days, like the Julian->Gregorian switchover. But the\n            // only ICU calendars that currently skip days (japanese/roc/buddhist) is\n            // a bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n            // that's currently detected by `checkIcuBugs()` which will throw. So\n            // this optimization should be safe for all ICU calendars.\n            let testIsoEstimate = this.addDaysIso(isoEstimate, diffDays);\n            if (date.day > this.minimumMonthLength(date)) {\n                // There's a chance that the calendar date is out of range. Throw or\n                // constrain if so.\n                let testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n                while (testCalendarDate.month !== month || testCalendarDate.year !== year) {\n                    if (overflow === 'reject') {\n                        throw new RangeError(`day ${day} does not exist in month ${month} of year ${year}`);\n                    }\n                    // Back up a day at a time until we're not hanging over the month end\n                    testIsoEstimate = this.addDaysIso(testIsoEstimate, -1);\n                    testCalendarDate = this.isoToCalendarDate(testIsoEstimate, cache);\n                }\n            }\n            return testIsoEstimate;\n        };\n        let sign = 0;\n        let roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n        let diff = simpleDateDiff(date, roundtripEstimate);\n        if (diff.years !== 0 || diff.months !== 0 || diff.days !== 0) {\n            const diffTotalDaysEstimate = diff.years * 365 + diff.months * 30 + diff.days;\n            isoEstimate = this.addDaysIso(isoEstimate, diffTotalDaysEstimate);\n            roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n            diff = simpleDateDiff(date, roundtripEstimate);\n            if (diff.years === 0 && diff.months === 0) {\n                isoEstimate = calculateSameMonthResult(diff.days);\n            }\n            else {\n                sign = this.compareCalendarDates(date, roundtripEstimate);\n            }\n        }\n        // If the initial guess is not in the same month, then then bisect the\n        // distance to the target, starting with 8 days per step.\n        let increment = 8;\n        let maybeConstrained = false;\n        while (sign) {\n            isoEstimate = this.addDaysIso(isoEstimate, sign * increment);\n            const oldRoundtripEstimate = roundtripEstimate;\n            roundtripEstimate = this.isoToCalendarDate(isoEstimate, cache);\n            const oldSign = sign;\n            sign = this.compareCalendarDates(date, roundtripEstimate);\n            if (sign) {\n                diff = simpleDateDiff(date, roundtripEstimate);\n                if (diff.years === 0 && diff.months === 0) {\n                    isoEstimate = calculateSameMonthResult(diff.days);\n                    // Signal the loop condition that there's a match.\n                    sign = 0;\n                    // If the calendar day is larger than the minimal length for this\n                    // month, then it might be larger than the actual length of the month.\n                    // So we won't cache it as the correct calendar date for this ISO\n                    // date.\n                    maybeConstrained = date.day > this.minimumMonthLength(date);\n                }\n                else if (oldSign && sign !== oldSign) {\n                    if (increment > 1) {\n                        // If the estimate overshot the target, try again with a smaller increment\n                        // in the reverse direction.\n                        increment /= 2;\n                    }\n                    else {\n                        // Increment is 1, and neither the previous estimate nor the new\n                        // estimate is correct. The only way that can happen is if the\n                        // original date was an invalid value that will be constrained or\n                        // rejected here.\n                        if (overflow === 'reject') {\n                            throw new RangeError(`Can't find ISO date from calendar date: ${JSON.stringify({ ...originalDate })}`);\n                        }\n                        else {\n                            // To constrain, pick the earliest value\n                            const order = this.compareCalendarDates(roundtripEstimate, oldRoundtripEstimate);\n                            // If current value is larger, then back up to the previous value.\n                            if (order > 0)\n                                isoEstimate = this.addDaysIso(isoEstimate, -1);\n                            maybeConstrained = true;\n                            sign = 0;\n                        }\n                    }\n                }\n            }\n        }\n        cache.set(key, isoEstimate);\n        if (keyOriginal)\n            cache.set(keyOriginal, isoEstimate);\n        if (date.year === undefined ||\n            date.month === undefined ||\n            date.day === undefined ||\n            date.monthCode === undefined ||\n            (this.hasEra && (date.era === undefined || date.eraYear === undefined))) {\n            throw new RangeError('Unexpected missing property');\n        }\n        if (!maybeConstrained) {\n            // Also cache the reverse mapping\n            const keyReverse = JSON.stringify({\n                func: 'isoToCalendarDate',\n                isoYear: isoEstimate.year,\n                isoMonth: isoEstimate.month,\n                isoDay: isoEstimate.day,\n                id: this.id\n            });\n            cache.set(keyReverse, date);\n        }\n        return isoEstimate;\n    }\n    temporalToCalendarDate(date, cache) {\n        const isoDate = { year: GetSlot(date, ISO_YEAR), month: GetSlot(date, ISO_MONTH), day: GetSlot(date, ISO_DAY) };\n        const result = this.isoToCalendarDate(isoDate, cache);\n        return result;\n    }\n    compareCalendarDates(date1Param, date2Param) {\n        // `date1` and `date2` are already records. The calls below simply validate\n        // that all three required fields are present.\n        const date1 = ES.PrepareTemporalFields(date1Param, ['day', 'month', 'year'], ['day', 'month', 'year']);\n        const date2 = ES.PrepareTemporalFields(date2Param, ['day', 'month', 'year'], ['day', 'month', 'year']);\n        if (date1.year !== date2.year)\n            return ES.ComparisonResult(date1.year - date2.year);\n        if (date1.month !== date2.month)\n            return ES.ComparisonResult(date1.month - date2.month);\n        if (date1.day !== date2.day)\n            return ES.ComparisonResult(date1.day - date2.day);\n        return 0;\n    }\n    /** Ensure that a calendar date actually exists. If not, return the closest earlier date. */\n    regulateDate(calendarDate, overflow = 'constrain', cache) {\n        const isoDate = this.calendarToIsoDate(calendarDate, overflow, cache);\n        return this.isoToCalendarDate(isoDate, cache);\n    }\n    addDaysIso(isoDate, days) {\n        const added = ES.AddISODate(isoDate.year, isoDate.month, isoDate.day, 0, 0, 0, days, 'constrain');\n        return added;\n    }\n    addDaysCalendar(calendarDate, days, cache) {\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const addedIso = this.addDaysIso(isoDate, days);\n        const addedCalendar = this.isoToCalendarDate(addedIso, cache);\n        return addedCalendar;\n    }\n    addMonthsCalendar(calendarDateParam, months, overflow, cache) {\n        let calendarDate = calendarDateParam;\n        const { day } = calendarDate;\n        for (let i = 0, absMonths = MathAbs(months); i < absMonths; i++) {\n            const { month } = calendarDate;\n            const oldCalendarDate = calendarDate;\n            const days = months < 0\n                ? -Math.max(day, this.daysInPreviousMonth(calendarDate, cache))\n                : this.daysInMonth(calendarDate, cache);\n            const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n            let addedIso = this.addDaysIso(isoDate, days);\n            calendarDate = this.isoToCalendarDate(addedIso, cache);\n            // Normally, we can advance one month by adding the number of days in the\n            // current month. However, if we're at the end of the current month and\n            // the next month has fewer days, then we rolled over to the after-next\n            // month. Below we detect this condition and back up until we're back in\n            // the desired month.\n            if (months > 0) {\n                const monthsInOldYear = this.monthsInYear(oldCalendarDate, cache);\n                while (calendarDate.month - 1 !== month % monthsInOldYear) {\n                    addedIso = this.addDaysIso(addedIso, -1);\n                    calendarDate = this.isoToCalendarDate(addedIso, cache);\n                }\n            }\n            if (calendarDate.day !== day) {\n                // try to retain the original day-of-month, if possible\n                calendarDate = this.regulateDate({ ...calendarDate, day }, 'constrain', cache);\n            }\n        }\n        if (overflow === 'reject' && calendarDate.day !== day) {\n            throw new RangeError(`Day ${day} does not exist in resulting calendar month`);\n        }\n        return calendarDate;\n    }\n    addCalendar(calendarDate, { years = 0, months = 0, weeks = 0, days = 0 }, overflow, cache) {\n        const { year, day, monthCode } = calendarDate;\n        const addedYears = this.adjustCalendarDate({ year: year + years, monthCode, day }, cache);\n        const addedMonths = this.addMonthsCalendar(addedYears, months, overflow, cache);\n        const initialDays = days + weeks * 7;\n        const addedDays = this.addDaysCalendar(addedMonths, initialDays, cache);\n        return addedDays;\n    }\n    untilCalendar(calendarOne, calendarTwo, largestUnit, cache) {\n        let days = 0;\n        let weeks = 0;\n        let months = 0;\n        let years = 0;\n        switch (largestUnit) {\n            case 'day':\n                days = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n                break;\n            case 'week': {\n                const totalDays = this.calendarDaysUntil(calendarOne, calendarTwo, cache);\n                days = totalDays % 7;\n                weeks = (totalDays - days) / 7;\n                break;\n            }\n            case 'month':\n            case 'year': {\n                const diffYears = calendarTwo.year - calendarOne.year;\n                const diffMonths = calendarTwo.month - calendarOne.month;\n                const diffDays = calendarTwo.day - calendarOne.day;\n                const sign = this.compareCalendarDates(calendarTwo, calendarOne);\n                if (!sign) {\n                    return { years: 0, months: 0, weeks: 0, days: 0 };\n                }\n                if (largestUnit === 'year' && diffYears) {\n                    const isOneFurtherInYear = diffMonths * sign < 0 || (diffMonths === 0 && diffDays * sign < 0);\n                    years = isOneFurtherInYear ? diffYears - sign : diffYears;\n                }\n                const yearsAdded = years ? this.addCalendar(calendarOne, { years }, 'constrain', cache) : calendarOne;\n                // Now we have less than one year remaining. Add one month at a time\n                // until we go over the target, then back up one month and calculate\n                // remaining days and weeks.\n                let current;\n                let next = yearsAdded;\n                do {\n                    months += sign;\n                    current = next;\n                    next = this.addMonthsCalendar(current, sign, 'constrain', cache);\n                    if (next.day !== calendarOne.day) {\n                        // In case the day was constrained down, try to un-constrain it\n                        next = this.regulateDate({ ...next, day: calendarOne.day }, 'constrain', cache);\n                    }\n                } while (this.compareCalendarDates(calendarTwo, next) * sign >= 0);\n                months -= sign; // correct for loop above which overshoots by 1\n                const remainingDays = this.calendarDaysUntil(current, calendarTwo, cache);\n                days = remainingDays;\n                break;\n            }\n        }\n        return { years, months, weeks, days };\n    }\n    daysInMonth(calendarDate, cache) {\n        // Add enough days to roll over to the next month. One we're in the next\n        // month, we can calculate the length of the current month. NOTE: This\n        // algorithm assumes that months are continuous. It would break if a\n        // calendar skipped days, like the Julian->Gregorian switchover. But the\n        // only ICU calendars that currently skip days (japanese/roc/buddhist) is a\n        // bug (https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)\n        // that's currently detected by `checkIcuBugs()` which will throw. So this\n        // code should be safe for all ICU calendars.\n        const { day } = calendarDate;\n        const max = this.maximumMonthLength(calendarDate);\n        const min = this.minimumMonthLength(calendarDate);\n        // easiest case: we already know the month length if min and max are the same.\n        if (min === max)\n            return min;\n        // Add enough days to get into the next month, without skipping it\n        const increment = day <= max - min ? max : min;\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const addedIsoDate = this.addDaysIso(isoDate, increment);\n        const addedCalendarDate = this.isoToCalendarDate(addedIsoDate, cache);\n        // Now back up to the last day of the original month\n        const endOfMonthIso = this.addDaysIso(addedIsoDate, -addedCalendarDate.day);\n        const endOfMonthCalendar = this.isoToCalendarDate(endOfMonthIso, cache);\n        return endOfMonthCalendar.day;\n    }\n    daysInPreviousMonth(calendarDate, cache) {\n        const { day, month, year } = calendarDate;\n        // Check to see if we already know the month length, and return it if so\n        const previousMonthYear = month > 1 ? year : year - 1;\n        let previousMonthDate = { year: previousMonthYear, month, day: 1 };\n        const previousMonth = month > 1 ? month - 1 : this.monthsInYear(previousMonthDate, cache);\n        previousMonthDate = { ...previousMonthDate, month: previousMonth };\n        const min = this.minimumMonthLength(previousMonthDate);\n        const max = this.maximumMonthLength(previousMonthDate);\n        if (min === max)\n            return max;\n        const isoDate = this.calendarToIsoDate(calendarDate, 'constrain', cache);\n        const lastDayOfPreviousMonthIso = this.addDaysIso(isoDate, -day);\n        const lastDayOfPreviousMonthCalendar = this.isoToCalendarDate(lastDayOfPreviousMonthIso, cache);\n        return lastDayOfPreviousMonthCalendar.day;\n    }\n    startOfCalendarYear(calendarDate) {\n        return { year: calendarDate.year, month: 1, monthCode: 'M01', day: 1 };\n    }\n    startOfCalendarMonth(calendarDate) {\n        return { year: calendarDate.year, month: calendarDate.month, day: 1 };\n    }\n    calendarDaysUntil(calendarOne, calendarTwo, cache) {\n        const oneIso = this.calendarToIsoDate(calendarOne, 'constrain', cache);\n        const twoIso = this.calendarToIsoDate(calendarTwo, 'constrain', cache);\n        return this.isoDaysUntil(oneIso, twoIso);\n    }\n    isoDaysUntil(oneIso, twoIso) {\n        const duration = ES.DifferenceISODate(oneIso.year, oneIso.month, oneIso.day, twoIso.year, twoIso.month, twoIso.day, 'day');\n        return duration.days;\n    }\n    monthDayFromFields(fields, overflow, cache) {\n        let { year, month, monthCode, day, era, eraYear } = fields;\n        if (monthCode === undefined) {\n            if (year === undefined && (era === undefined || eraYear === undefined)) {\n                throw new TypeError('`monthCode`, `year`, or `era` and `eraYear` is required');\n            }\n            ({ monthCode, year } = this.adjustCalendarDate({ year, month, monthCode, day, era, eraYear }, cache, overflow));\n        }\n        let isoYear, isoMonth, isoDay;\n        let closestCalendar, closestIso;\n        // Look backwards starting from the calendar year of 1972-01-01 up to 100\n        // calendar years to find a year that has this month and day. Normal months\n        // and days will match immediately, but for leap days and leap months we may\n        // have to look for a while.\n        const startDateIso = { year: 1972, month: 1, day: 1 };\n        const { year: calendarYear } = this.isoToCalendarDate(startDateIso, cache);\n        for (let i = 0; i < 100; i++) {\n            const testCalendarDate = this.adjustCalendarDate({ day, monthCode, year: calendarYear - i }, cache);\n            const isoDate = this.calendarToIsoDate(testCalendarDate, 'constrain', cache);\n            const roundTripCalendarDate = this.isoToCalendarDate(isoDate, cache);\n            ({ year: isoYear, month: isoMonth, day: isoDay } = isoDate);\n            if (roundTripCalendarDate.monthCode === monthCode && roundTripCalendarDate.day === day) {\n                return { month: isoMonth, day: isoDay, year: isoYear };\n            }\n            else if (overflow === 'constrain') {\n                // non-ISO constrain algorithm tries to find the closest date in a matching month\n                if (closestCalendar === undefined ||\n                    (roundTripCalendarDate.monthCode === closestCalendar.monthCode &&\n                        roundTripCalendarDate.day > closestCalendar.day)) {\n                    closestCalendar = roundTripCalendarDate;\n                    closestIso = isoDate;\n                }\n            }\n        }\n        if (overflow === 'constrain' && closestIso !== undefined)\n            return closestIso;\n        throw new RangeError(`No recent ${this.id} year with monthCode ${monthCode} and day ${day}`);\n    }\n}\nclass HebrewHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'hebrew';\n        this.calendarType = 'lunisolar';\n        this.months = {\n            Tishri: { leap: 1, regular: 1, monthCode: 'M01', days: 30 },\n            Heshvan: { leap: 2, regular: 2, monthCode: 'M02', days: { min: 29, max: 30 } },\n            Kislev: { leap: 3, regular: 3, monthCode: 'M03', days: { min: 29, max: 30 } },\n            Tevet: { leap: 4, regular: 4, monthCode: 'M04', days: 29 },\n            Shevat: { leap: 5, regular: 5, monthCode: 'M05', days: 30 },\n            Adar: { leap: undefined, regular: 6, monthCode: 'M06', days: 29 },\n            'Adar I': { leap: 6, regular: undefined, monthCode: 'M05L', days: 30 },\n            'Adar II': { leap: 7, regular: undefined, monthCode: 'M06', days: 29 },\n            Nisan: { leap: 8, regular: 7, monthCode: 'M07', days: 30 },\n            Iyar: { leap: 9, regular: 8, monthCode: 'M08', days: 29 },\n            Sivan: { leap: 10, regular: 9, monthCode: 'M09', days: 30 },\n            Tamuz: { leap: 11, regular: 10, monthCode: 'M10', days: 29 },\n            Av: { leap: 12, regular: 11, monthCode: 'M11', days: 30 },\n            Elul: { leap: 13, regular: 12, monthCode: 'M12', days: 29 }\n        };\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = false;\n    }\n    inLeapYear(calendarDate) {\n        const { year } = calendarDate;\n        // FYI: In addition to adding a month in leap years, the Hebrew calendar\n        // also has per-year changes to the number of days of Heshvan and Kislev.\n        // Given that these can be calculated by counting the number of days in\n        // those months, I assume that these DO NOT need to be exposed as\n        // Hebrew-only prototype fields or methods.\n        return (7 * year + 1) % 19 < 7;\n    }\n    monthsInYear(calendarDate) {\n        return this.inLeapYear(calendarDate) ? 13 : 12;\n    }\n    minimumMonthLength(calendarDate) {\n        return this.minMaxMonthLength(calendarDate, 'min');\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minMaxMonthLength(calendarDate, 'max');\n    }\n    minMaxMonthLength(calendarDate, minOrMax) {\n        const { month, year } = calendarDate;\n        const monthCode = this.getMonthCode(year, month);\n        const monthInfo = ObjectEntries(this.months).find((m) => m[1].monthCode === monthCode);\n        if (monthInfo === undefined)\n            throw new RangeError(`unmatched Hebrew month: ${month}`);\n        const daysInMonth = monthInfo[1].days;\n        return typeof daysInMonth === 'number' ? daysInMonth : daysInMonth[minOrMax];\n    }\n    /** Take a guess at what ISO date a particular calendar date corresponds to */\n    estimateIsoDate(calendarDate) {\n        const { year } = calendarDate;\n        return { year: year - 3760, month: 1, day: 1 };\n    }\n    getMonthCode(year, month) {\n        if (this.inLeapYear({ year })) {\n            return month === 6 ? buildMonthCode(5, true) : buildMonthCode(month < 6 ? month : month - 1);\n        }\n        else {\n            return buildMonthCode(month);\n        }\n    }\n    adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n        // The incoming type is actually CalendarDate (same as args to\n        // Calendar.dateFromParams) but TS isn't smart enough to follow all the\n        // reassignments below, so as an alternative to 10+ type casts, we'll lie\n        // here and claim that the type has `day` and `year` filled in already.\n        let { year, eraYear, month, monthCode, day, monthExtra } = calendarDate;\n        if (year === undefined && eraYear !== undefined)\n            year = eraYear;\n        if (eraYear === undefined && year !== undefined)\n            eraYear = year;\n        if (fromLegacyDate) {\n            // In Pre Node-14 V8, DateTimeFormat.formatToParts `month: 'numeric'`\n            // output returns the numeric equivalent of `month` as a string, meaning\n            // that `'6'` in a leap year is Adar I, while `'6'` in a non-leap year\n            // means Adar. In this case, `month` will already be correct and no action\n            // is needed. However, in Node 14 and later formatToParts returns the name\n            // of the Hebrew month (e.g. \"Tevet\"), so we'll need to look up the\n            // correct `month` using the string name as a key.\n            if (monthExtra) {\n                const monthInfo = this.months[monthExtra];\n                if (!monthInfo)\n                    throw new RangeError(`Unrecognized month from formatToParts: ${monthExtra}`);\n                month = this.inLeapYear({ year }) ? monthInfo.leap : monthInfo.regular;\n            }\n            // Because we're getting data from legacy Date, then `month` will always be present\n            monthCode = this.getMonthCode(year, month);\n            const result = { year, month: month, day, era: undefined, eraYear, monthCode };\n            return result;\n        }\n        else {\n            // When called without input coming from legacy Date output, simply ensure\n            // that all fields are present.\n            this.validateCalendarDate(calendarDate);\n            if (month === undefined) {\n                if (monthCode.endsWith('L')) {\n                    if (monthCode !== 'M05L') {\n                        throw new RangeError(`Hebrew leap month must have monthCode M05L, not ${monthCode}`);\n                    }\n                    month = 6;\n                    if (!this.inLeapYear({ year })) {\n                        if (overflow === 'reject') {\n                            throw new RangeError(`Hebrew monthCode M05L is invalid in year ${year} which is not a leap year`);\n                        }\n                        else {\n                            // constrain to last day of previous month (Av)\n                            month = 5;\n                            day = 30;\n                            monthCode = 'M05';\n                        }\n                    }\n                }\n                else {\n                    month = monthCodeNumberPart(monthCode);\n                    // if leap month is before this one, the month index is one more than the month code\n                    if (this.inLeapYear({ year }) && month >= 6)\n                        month++;\n                    const largestMonth = this.monthsInYear({ year });\n                    if (month < 1 || month > largestMonth)\n                        throw new RangeError(`Invalid monthCode: ${monthCode}`);\n                }\n            }\n            else {\n                if (overflow === 'reject') {\n                    ES.RejectToRange(month, 1, this.monthsInYear({ year }));\n                    ES.RejectToRange(day, 1, this.maximumMonthLength({ year, month }));\n                }\n                else {\n                    month = ES.ConstrainToRange(month, 1, this.monthsInYear({ year }));\n                    day = ES.ConstrainToRange(day, 1, this.maximumMonthLength({ year, month }));\n                }\n                if (monthCode === undefined) {\n                    monthCode = this.getMonthCode(year, month);\n                }\n                else {\n                    const calculatedMonthCode = this.getMonthCode(year, month);\n                    if (calculatedMonthCode !== monthCode) {\n                        throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Hebrew year ${year}`);\n                    }\n                }\n            }\n            return { ...calendarDate, day, month, monthCode: monthCode, year, eraYear };\n        }\n    }\n}\n/**\n * For Temporal purposes, the Islamic calendar is simple because it's always the\n * same 12 months in the same order.\n */\nclass IslamicBaseHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.calendarType = 'lunar';\n        this.DAYS_PER_ISLAMIC_YEAR = 354 + 11 / 30;\n        this.DAYS_PER_ISO_YEAR = 365.2425;\n        this.constantEra = 'ah';\n    }\n    inLeapYear(calendarDate, cache) {\n        // In leap years, the 12th month has 30 days. In non-leap years: 29.\n        const days = this.daysInMonth({ year: calendarDate.year, month: 12, day: 1 }, cache);\n        return days === 30;\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength( /* calendarDate */) {\n        return 29;\n    }\n    maximumMonthLength( /* calendarDate */) {\n        return 30;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year } = this.adjustCalendarDate(calendarDate);\n        return { year: MathFloor((year * this.DAYS_PER_ISLAMIC_YEAR) / this.DAYS_PER_ISO_YEAR) + 622, month: 1, day: 1 };\n    }\n}\n// There are 6 Islamic calendars with the same implementation in this polyfill.\n// They vary only in their ID. They do emit different output from the underlying\n// Intl implementation, but our code for each of them is identical.\nclass IslamicHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic';\n    }\n}\nclass IslamicUmalquraHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-umalqura';\n    }\n}\nclass IslamicTblaHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-tbla';\n    }\n}\nclass IslamicCivilHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-civil';\n    }\n}\nclass IslamicRgsaHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamic-rgsa';\n    }\n}\nclass IslamicCcHelper extends IslamicBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'islamicc';\n    }\n}\nclass PersianHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'persian';\n        this.calendarType = 'solar';\n        this.constantEra = 'ap';\n    }\n    inLeapYear(calendarDate, cache) {\n        // Same logic (count days in the last month) for Persian as for Islamic,\n        // even though Persian is solar and Islamic is lunar.\n        return IslamicHelper.prototype.inLeapYear.call(this, calendarDate, cache);\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 12)\n            return 29;\n        return month <= 6 ? 31 : 30;\n    }\n    maximumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 12)\n            return 30;\n        return month <= 6 ? 31 : 30;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year } = this.adjustCalendarDate(calendarDate);\n        return { year: year + 621, month: 1, day: 1 };\n    }\n}\nclass IndianHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.id = 'indian';\n        this.calendarType = 'solar';\n        this.constantEra = 'saka';\n        // Indian months always start at the same well-known Gregorian month and\n        // day. So this conversion is easy and fast. See\n        // https://en.wikipedia.org/wiki/Indian_national_calendar\n        this.months = {\n            1: { length: 30, month: 3, day: 22, leap: { length: 31, month: 3, day: 21 } },\n            2: { length: 31, month: 4, day: 21 },\n            3: { length: 31, month: 5, day: 22 },\n            4: { length: 31, month: 6, day: 22 },\n            5: { length: 31, month: 7, day: 23 },\n            6: { length: 31, month: 8, day: 23 },\n            7: { length: 30, month: 9, day: 23 },\n            8: { length: 30, month: 10, day: 23 },\n            9: { length: 30, month: 11, day: 22 },\n            10: { length: 30, month: 12, day: 22 },\n            11: { length: 30, month: 1, nextYear: true, day: 21 },\n            12: { length: 30, month: 2, nextYear: true, day: 20 }\n        };\n        // https://bugs.chromium.org/p/v8/issues/detail?id=10529 causes Intl's Indian\n        // calendar output to fail for all dates before 0001-01-01 ISO.  For example,\n        // in Node 12 0000-01-01 is calculated as 6146/12/-583 instead of 10/11/-79 as\n        // expected.\n        this.vulnerableToBceBug = new Date('0000-01-01T00:00Z').toLocaleDateString('en-US-u-ca-indian', { timeZone: 'UTC' }) !== '10/11/-79 Saka';\n    }\n    inLeapYear(calendarDate) {\n        // From https://en.wikipedia.org/wiki/Indian_national_calendar:\n        // Years are counted in the Saka era, which starts its year 0 in the year 78\n        // of the Common Era. To determine leap years, add 78 to the Saka year – if\n        // the result is a leap year in the Gregorian calendar, then the Saka year\n        // is a leap year as well.\n        return isGregorianLeapYear(calendarDate.year + 78);\n    }\n    monthsInYear( /* calendarYear, cache */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        return this.getMonthInfo(calendarDate).length;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.getMonthInfo(calendarDate).length;\n    }\n    getMonthInfo(calendarDate) {\n        const { month } = calendarDate;\n        let monthInfo = this.months[month];\n        if (monthInfo === undefined)\n            throw new RangeError(`Invalid month: ${month}`);\n        if (this.inLeapYear(calendarDate) && monthInfo.leap)\n            monthInfo = monthInfo.leap;\n        return monthInfo;\n    }\n    estimateIsoDate(calendarDateParam) {\n        // FYI, this \"estimate\" is always the exact ISO date, which makes the Indian\n        // calendar fast!\n        const calendarDate = this.adjustCalendarDate(calendarDateParam);\n        const monthInfo = this.getMonthInfo(calendarDate);\n        const isoYear = calendarDate.year + 78 + (monthInfo.nextYear ? 1 : 0);\n        const isoMonth = monthInfo.month;\n        const isoDay = monthInfo.day;\n        const isoDate = ES.AddISODate(isoYear, isoMonth, isoDay, 0, 0, 0, calendarDate.day - 1, 'constrain');\n        return isoDate;\n    }\n    checkIcuBugs(isoDate) {\n        if (this.vulnerableToBceBug && isoDate.year < 1) {\n            throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 0001-01-01` +\n                ' (see https://bugs.chromium.org/p/v8/issues/detail?id=10529)');\n        }\n    }\n}\n/**\n * This function adds additional metadata that makes it easier to work with\n * eras. Note that it mutates and normalizes the original era objects, which is\n * OK because this is non-observable, internal-only metadata.\n *\n * The result is an array of eras with the shape defined above.\n * */\nfunction adjustEras(erasParam) {\n    let eras = erasParam;\n    if (eras.length === 0) {\n        throw new RangeError('Invalid era data: eras are required');\n    }\n    if (eras.length === 1 && eras[0].reverseOf) {\n        throw new RangeError('Invalid era data: anchor era cannot count years backwards');\n    }\n    if (eras.length === 1 && !eras[0].name) {\n        throw new RangeError('Invalid era data: at least one named era is required');\n    }\n    if (eras.filter((e) => e.reverseOf != null).length > 1) {\n        throw new RangeError('Invalid era data: only one era can count years backwards');\n    }\n    // Find the \"anchor era\" which is the era used for (era-less) `year`. Reversed\n    // eras can never be anchors. The era without an `anchorEpoch` property is the\n    // anchor.\n    let anchorEra;\n    eras.forEach((e) => {\n        if (e.isAnchor || (!e.anchorEpoch && !e.reverseOf)) {\n            if (anchorEra)\n                throw new RangeError('Invalid era data: cannot have multiple anchor eras');\n            anchorEra = e;\n            e.anchorEpoch = { year: e.hasYearZero ? 0 : 1 };\n        }\n        else if (!e.name) {\n            throw new RangeError('If era name is blank, it must be the anchor era');\n        }\n    });\n    // If the era name is undefined, then it's an anchor that doesn't interact\n    // with eras at all. For example, Japanese `year` is always the same as ISO\n    // `year`.  So this \"era\" is the anchor era but isn't used for era matching.\n    // Strip it from the list that's returned.\n    eras = eras.filter((e) => e.name);\n    eras.forEach((e) => {\n        // Some eras are mirror images of another era e.g. B.C. is the reverse of A.D.\n        // Replace the string-valued \"reverseOf\" property with the actual era object\n        // that's reversed.\n        const { reverseOf } = e;\n        if (reverseOf) {\n            const reversedEra = eras.find((era) => era.name === reverseOf);\n            if (reversedEra === undefined)\n                throw new RangeError(`Invalid era data: unmatched reverseOf era: ${reverseOf}`);\n            e.reverseOf = reversedEra;\n            e.anchorEpoch = reversedEra.anchorEpoch;\n            e.isoEpoch = reversedEra.isoEpoch;\n        }\n        if (e.anchorEpoch.month === undefined)\n            e.anchorEpoch.month = 1;\n        if (e.anchorEpoch.day === undefined)\n            e.anchorEpoch.day = 1;\n    });\n    // Ensure that the latest epoch is first in the array. This lets us try to\n    // match eras in index order, with the last era getting the remaining older\n    // years. Any reverse-signed era must be at the end.\n    ArraySort.call(eras, (e1, e2) => {\n        if (e1.reverseOf)\n            return 1;\n        if (e2.reverseOf)\n            return -1;\n        if (!e1.isoEpoch || !e2.isoEpoch)\n            throw new RangeError('Invalid era data: missing ISO epoch');\n        return e2.isoEpoch.year - e1.isoEpoch.year;\n    });\n    // If there's a reversed era, then the one before it must be the era that's\n    // being reversed.\n    const lastEraReversed = eras[eras.length - 1].reverseOf;\n    if (lastEraReversed) {\n        if (lastEraReversed !== eras[eras.length - 2])\n            throw new RangeError('Invalid era data: invalid reverse-sign era');\n    }\n    // Finally, add a \"genericName\" property in the format \"era{n} where `n` is\n    // zero-based index, with the oldest era being zero. This format is used by\n    // older versions of ICU data.\n    eras.forEach((e, i) => {\n        e.genericName = `era${eras.length - 1 - i}`;\n    });\n    return { eras: eras, anchorEra: (anchorEra || eras[0]) };\n}\nfunction isGregorianLeapYear(year) {\n    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);\n}\n/** Base for all Gregorian-like calendars. */\nclass GregorianBaseHelper extends HelperBase {\n    constructor(id, originalEras) {\n        super();\n        this.calendarType = 'solar';\n        // Several calendars based on the Gregorian calendar use Julian dates (not\n        // proleptic Gregorian dates) before the Julian switchover in Oct 1582. See\n        // https://bugs.chromium.org/p/chromium/issues/detail?id=1173158.\n        this.v8IsVulnerableToJulianBug = new Date('+001001-01-01T00:00Z')\n            .toLocaleDateString('en-US-u-ca-japanese', { timeZone: 'UTC' })\n            .startsWith('12');\n        this.calendarIsVulnerableToJulianBug = false;\n        this.id = id;\n        const { eras, anchorEra } = adjustEras(originalEras);\n        this.anchorEra = anchorEra;\n        this.eras = eras;\n    }\n    inLeapYear(calendarDate) {\n        // Calendars that don't override this method use the same months and leap\n        // years as Gregorian. Once we know the ISO year corresponding to the\n        // calendar year, we'll know if it's a leap year or not.\n        const { year } = this.estimateIsoDate({ month: 1, day: 1, year: calendarDate.year });\n        return isGregorianLeapYear(year);\n    }\n    monthsInYear( /* calendarDate */) {\n        return 12;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        if (month === 2)\n            return this.inLeapYear(calendarDate) ? 29 : 28;\n        return [4, 6, 9, 11].indexOf(month) >= 0 ? 30 : 31;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minimumMonthLength(calendarDate);\n    }\n    /** Fill in missing parts of the (year, era, eraYear) tuple */\n    completeEraYear(calendarDate) {\n        const checkField = (name, value) => {\n            const currentValue = calendarDate[name];\n            if (currentValue != null && currentValue != value) {\n                throw new RangeError(`Input ${name} ${currentValue} doesn't match calculated value ${value}`);\n            }\n        };\n        const eraFromYear = (year) => {\n            let eraYear;\n            const adjustedCalendarDate = { ...calendarDate, year };\n            const matchingEra = this.eras.find((e, i) => {\n                if (i === this.eras.length - 1) {\n                    if (e.reverseOf) {\n                        // This is a reverse-sign era (like BCE) which must be the oldest\n                        // era. Count years backwards.\n                        if (year > 0)\n                            throw new RangeError(`Signed year ${year} is invalid for era ${e.name}`);\n                        eraYear = e.anchorEpoch.year - year;\n                        return true;\n                    }\n                    // last era always gets all \"leftover\" (older than epoch) years,\n                    // so no need for a comparison like below.\n                    eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n                    return true;\n                }\n                const comparison = this.compareCalendarDates(adjustedCalendarDate, e.anchorEpoch);\n                if (comparison >= 0) {\n                    eraYear = year - e.anchorEpoch.year + (e.hasYearZero ? 0 : 1);\n                    return true;\n                }\n                return false;\n            });\n            if (!matchingEra)\n                throw new RangeError(`Year ${year} was not matched by any era`);\n            return { eraYear: eraYear, era: matchingEra.name };\n        };\n        let { year, eraYear, era } = calendarDate;\n        if (year != null) {\n            ({ eraYear, era } = eraFromYear(year));\n            checkField('era', era);\n            checkField('eraYear', eraYear);\n        }\n        else if (eraYear != null) {\n            const matchingEra = era === undefined ? undefined : this.eras.find((e) => e.name === era || e.genericName === era);\n            if (!matchingEra)\n                throw new RangeError(`Era ${era} (ISO year ${eraYear}) was not matched by any era`);\n            if (eraYear < 1 && matchingEra.reverseOf) {\n                throw new RangeError(`Years in ${era} era must be positive, not ${year}`);\n            }\n            if (matchingEra.reverseOf) {\n                year = matchingEra.anchorEpoch.year - eraYear;\n            }\n            else {\n                year = eraYear + matchingEra.anchorEpoch.year - (matchingEra.hasYearZero ? 0 : 1);\n            }\n            checkField('year', year);\n            // We'll accept dates where the month/day is earlier than the start of\n            // the era or after its end as long as it's in the same year. If that\n            // happens, we'll adjust the era/eraYear pair to be the correct era for\n            // the `year`.\n            ({ eraYear, era } = eraFromYear(year));\n        }\n        else {\n            throw new RangeError('Either `year` or `eraYear` and `era` are required');\n        }\n        return { ...calendarDate, year, eraYear, era };\n    }\n    adjustCalendarDate(calendarDateParam, cache, overflow = 'constrain') {\n        let calendarDate = calendarDateParam;\n        // Because this is not a lunisolar calendar, it's safe to convert monthCode to a number\n        const { month, monthCode } = calendarDate;\n        if (month === undefined)\n            calendarDate = { ...calendarDate, month: monthCodeNumberPart(monthCode) };\n        this.validateCalendarDate(calendarDate);\n        calendarDate = this.completeEraYear(calendarDate);\n        return super.adjustCalendarDate(calendarDate, cache, overflow);\n    }\n    estimateIsoDate(calendarDateParam) {\n        const calendarDate = this.adjustCalendarDate(calendarDateParam);\n        const { year, month, day } = calendarDate;\n        const { anchorEra } = this;\n        const isoYearEstimate = year + anchorEra.isoEpoch.year - (anchorEra.hasYearZero ? 0 : 1);\n        return ES.RegulateISODate(isoYearEstimate, month, day, 'constrain');\n    }\n    checkIcuBugs(isoDate) {\n        if (this.calendarIsVulnerableToJulianBug && this.v8IsVulnerableToJulianBug) {\n            const beforeJulianSwitch = ES.CompareISODate(isoDate.year, isoDate.month, isoDate.day, 1582, 10, 15) < 0;\n            if (beforeJulianSwitch) {\n                throw new RangeError(`calendar '${this.id}' is broken for ISO dates before 1582-10-15` +\n                    ' (see https://bugs.chromium.org/p/chromium/issues/detail?id=1173158)');\n            }\n        }\n    }\n}\nclass OrthodoxBaseHelper extends GregorianBaseHelper {\n    constructor(id, originalEras) {\n        super(id, originalEras);\n    }\n    inLeapYear(calendarDate) {\n        // Leap years happen one year before the Julian leap year. Note that this\n        // calendar is based on the Julian calendar which has a leap year every 4\n        // years, unlike the Gregorian calendar which doesn't have leap years on\n        // years divisible by 100 except years divisible by 400.\n        //\n        // Note that we're assuming that leap years in before-epoch times match\n        // how leap years are defined now. This is probably not accurate but I'm\n        // not sure how better to do it.\n        const { year } = calendarDate;\n        return (year + 1) % 4 === 0;\n    }\n    monthsInYear( /* calendarDate */) {\n        return 13;\n    }\n    minimumMonthLength(calendarDate) {\n        const { month } = calendarDate;\n        // Ethiopian/Coptic calendars have 12 30-day months and an extra 5-6 day 13th month.\n        if (month === 13)\n            return this.inLeapYear(calendarDate) ? 6 : 5;\n        return 30;\n    }\n    maximumMonthLength(calendarDate) {\n        return this.minimumMonthLength(calendarDate);\n    }\n}\n// `coptic` and `ethiopic` calendars are very similar to `ethioaa` calendar,\n// with the following differences:\n// - Coptic uses BCE-like positive numbers for years before its epoch (the other\n//   two use negative year numbers before epoch)\n// - Coptic has a different epoch date\n// - Ethiopic has an additional second era that starts at the same date as the\n//   zero era of ethioaa.\nclass EthioaaHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('ethioaa', [{ name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } }]);\n    }\n}\nclass CopticHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('coptic', [\n            { name: 'era1', isoEpoch: { year: 284, month: 8, day: 29 } },\n            { name: 'era0', reverseOf: 'era1' }\n        ]);\n    }\n}\n// Anchor is currently the older era to match ethioaa, but should it be the newer era?\n// See https://github.com/tc39/ecma402/issues/534 for discussion.\nclass EthiopicHelper extends OrthodoxBaseHelper {\n    constructor() {\n        super('ethiopic', [\n            { name: 'era0', isoEpoch: { year: -5492, month: 7, day: 17 } },\n            { name: 'era1', isoEpoch: { year: 8, month: 8, day: 27 }, anchorEpoch: { year: 5501 } }\n        ]);\n    }\n}\nclass RocHelper extends GregorianBaseHelper {\n    constructor() {\n        super('roc', [\n            { name: 'minguo', isoEpoch: { year: 1912, month: 1, day: 1 } },\n            { name: 'before-roc', reverseOf: 'minguo' }\n        ]);\n        this.calendarIsVulnerableToJulianBug = true;\n    }\n}\nclass BuddhistHelper extends GregorianBaseHelper {\n    constructor() {\n        super('buddhist', [{ name: 'be', hasYearZero: true, isoEpoch: { year: -543, month: 1, day: 1 } }]);\n        this.calendarIsVulnerableToJulianBug = true;\n    }\n}\nclass GregoryHelper extends GregorianBaseHelper {\n    constructor() {\n        super('gregory', [\n            { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n            { name: 'bce', reverseOf: 'ce' }\n        ]);\n    }\n    reviseIntlEra(calendarDate /*, isoDate: IsoDate*/) {\n        let { era, eraYear } = calendarDate;\n        // Firefox 96 introduced a bug where the `'short'` format of the era\n        // option mistakenly returns the one-letter (narrow) format instead. The\n        // code below handles either the correct or Firefox-buggy format. See\n        // https://bugzilla.mozilla.org/show_bug.cgi?id=1752253\n        if (era === 'bc' || era === 'b')\n            era = 'bce';\n        if (era === 'ad' || era === 'a')\n            era = 'ce';\n        return { era, eraYear };\n    }\n}\n// NOTE: Only the 5 modern eras (Meiji and later) are included. For dates\n// before Meiji 1, the `ce` and `bce` eras are used. Challenges with pre-Meiji\n// eras include:\n// - Start/end dates of older eras are not precisely defined, which is\n//   challenging given Temporal's need for precision\n// - Some era dates and/or names are disputed by historians\n// - As historical research proceeds, new eras are discovered and existing era\n//   dates are modified, leading to considerable churn which is not good for\n//   Temporal use.\n//  - The earliest era (in 645 CE) may not end up being the earliest depending\n//    on future historical scholarship\n//  - Before Meiji, Japan used a lunar (or lunisolar?) calendar but AFAIK\n//    that's not reflected in the ICU implementation.\n//\n// For more discussion: https://github.com/tc39/proposal-temporal/issues/526.\n//\n// Here's a full list of CLDR/ICU eras:\n// https://github.com/unicode-org/icu/blob/master/icu4c/source/data/locales/root.txt#L1582-L1818\n// https://github.com/unicode-org/cldr/blob/master/common/supplemental/supplementalData.xml#L4310-L4546\n//\n// NOTE: Japan started using the Gregorian calendar in 6 Meiji, replacing a\n// lunisolar calendar. So the day before January 1 of 6 Meiji (1873) was not\n// December 31, but December 2, of 5 Meiji (1872). The existing Ecma-402\n// Japanese calendar doesn't seem to take this into account, so neither do we:\n// > args = ['en-ca-u-ca-japanese', { era: 'short' }]\n// > new Date('1873-01-01T12:00').toLocaleString(...args)\n// '1 1, 6 Meiji, 12:00:00 PM'\n// > new Date('1872-12-31T12:00').toLocaleString(...args)\n// '12 31, 5 Meiji, 12:00:00 PM'\nclass JapaneseHelper extends GregorianBaseHelper {\n    constructor() {\n        super('japanese', [\n            // The Japanese calendar `year` is just the ISO year, because (unlike other\n            // ICU calendars) there's no obvious \"default era\", we use the ISO year.\n            { name: 'reiwa', isoEpoch: { year: 2019, month: 5, day: 1 }, anchorEpoch: { year: 2019, month: 5, day: 1 } },\n            { name: 'heisei', isoEpoch: { year: 1989, month: 1, day: 8 }, anchorEpoch: { year: 1989, month: 1, day: 8 } },\n            { name: 'showa', isoEpoch: { year: 1926, month: 12, day: 25 }, anchorEpoch: { year: 1926, month: 12, day: 25 } },\n            { name: 'taisho', isoEpoch: { year: 1912, month: 7, day: 30 }, anchorEpoch: { year: 1912, month: 7, day: 30 } },\n            { name: 'meiji', isoEpoch: { year: 1868, month: 9, day: 8 }, anchorEpoch: { year: 1868, month: 9, day: 8 } },\n            { name: 'ce', isoEpoch: { year: 1, month: 1, day: 1 } },\n            { name: 'bce', reverseOf: 'ce' }\n        ]);\n        this.calendarIsVulnerableToJulianBug = true;\n        // The last 3 Japanese eras confusingly return only one character in the\n        // default \"short\" era, so need to use the long format.\n        this.eraLength = 'long';\n    }\n    reviseIntlEra(calendarDate, isoDate) {\n        const { era, eraYear } = calendarDate;\n        const { year: isoYear } = isoDate;\n        if (this.eras.find((e) => e.name === era))\n            return { era, eraYear };\n        return (isoYear < 1 ? { era: 'bce', eraYear: 1 - isoYear } : { era: 'ce', eraYear: isoYear });\n    }\n}\nclass ChineseBaseHelper extends HelperBase {\n    constructor() {\n        super(...arguments);\n        this.calendarType = 'lunisolar';\n        // All built-in calendars except Chinese/Dangi and Hebrew use an era\n        this.hasEra = false;\n    }\n    inLeapYear(calendarDate, cache) {\n        const months = this.getMonthList(calendarDate.year, cache);\n        return ObjectEntries(months).length === 13;\n    }\n    monthsInYear(calendarDate, cache) {\n        return this.inLeapYear(calendarDate, cache) ? 13 : 12;\n    }\n    minimumMonthLength( /* calendarDate */) {\n        return 29;\n    }\n    maximumMonthLength( /* calendarDate */) {\n        return 30;\n    }\n    getMonthList(calendarYear, cache) {\n        if (calendarYear === undefined) {\n            throw new TypeError('Missing year');\n        }\n        const key = JSON.stringify({ func: 'getMonthList', calendarYear, id: this.id });\n        const cached = cache.get(key);\n        if (cached)\n            return cached;\n        const dateTimeFormat = this.getFormatter();\n        const getCalendarDate = (isoYear, daysPastFeb1) => {\n            const isoStringFeb1 = toUtcIsoDateString({ isoYear, isoMonth: 2, isoDay: 1 });\n            const legacyDate = new Date(isoStringFeb1);\n            // Now add the requested number of days, which may wrap to the next month.\n            legacyDate.setUTCDate(daysPastFeb1 + 1);\n            const newYearGuess = dateTimeFormat.formatToParts(legacyDate);\n            const calendarMonthString = newYearGuess.find((tv) => tv.type === 'month').value;\n            const calendarDay = +newYearGuess.find((tv) => tv.type === 'day').value;\n            let calendarYearToVerify = newYearGuess.find((tv) => tv.type === 'relatedYear');\n            if (calendarYearToVerify !== undefined) {\n                calendarYearToVerify = +calendarYearToVerify.value;\n            }\n            else {\n                // Node 12 has outdated ICU data that lacks the `relatedYear` field in the\n                // output of Intl.DateTimeFormat.formatToParts.\n                throw new RangeError(`Intl.DateTimeFormat.formatToParts lacks relatedYear in ${this.id} calendar. Try Node 14+ or modern browsers.`);\n            }\n            return { calendarMonthString, calendarDay, calendarYearToVerify };\n        };\n        // First, find a date close to Chinese New Year. Feb 17 will either be in\n        // the first month or near the end of the last month of the previous year.\n        let isoDaysDelta = 17;\n        let { calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta);\n        // If we didn't guess the first month correctly, add (almost in some months)\n        // a lunar month\n        if (calendarMonthString !== '1') {\n            isoDaysDelta += 29;\n            ({ calendarMonthString, calendarDay } = getCalendarDate(calendarYear, isoDaysDelta));\n        }\n        // Now back up to near the start of the first month, but not too near that\n        // off-by-one issues matter.\n        isoDaysDelta -= calendarDay - 5;\n        const result = {};\n        let monthIndex = 1;\n        let oldCalendarDay;\n        let oldMonthString;\n        let done = false;\n        do {\n            ({ calendarMonthString, calendarDay, calendarYearToVerify } = getCalendarDate(calendarYear, isoDaysDelta));\n            if (oldCalendarDay) {\n                result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n            }\n            if (calendarYearToVerify !== calendarYear) {\n                done = true;\n            }\n            else {\n                result[calendarMonthString] = { monthIndex: monthIndex++ };\n                // Move to the next month. Because months are sometimes 29 days, the day of the\n                // calendar month will move forward slowly but not enough to flip over to a new\n                // month before the loop ends at 12-13 months.\n                isoDaysDelta += 30;\n            }\n            oldCalendarDay = calendarDay;\n            oldMonthString = calendarMonthString;\n        } while (!done);\n        result[oldMonthString].daysInMonth = oldCalendarDay + 30 - calendarDay;\n        cache.set(key, result);\n        return result;\n    }\n    estimateIsoDate(calendarDate) {\n        const { year, month } = calendarDate;\n        return { year, month: month >= 12 ? 12 : month + 1, day: 1 };\n    }\n    adjustCalendarDate(calendarDate, cache, overflow = 'constrain', fromLegacyDate = false) {\n        let { year, month, monthExtra, day, monthCode, eraYear } = calendarDate;\n        if (fromLegacyDate) {\n            // Legacy Date output returns a string that's an integer with an optional\n            // \"bis\" suffix used only by the Chinese/Dangi calendar to indicate a leap\n            // month. Below we'll normalize the output.\n            year = eraYear;\n            if (monthExtra && monthExtra !== 'bis')\n                throw new RangeError(`Unexpected leap month suffix: ${monthExtra}`);\n            const monthCode = buildMonthCode(month, monthExtra !== undefined);\n            const monthString = `${month}${monthExtra || ''}`;\n            const months = this.getMonthList(year, cache);\n            const monthInfo = months[monthString];\n            if (monthInfo === undefined)\n                throw new RangeError(`Unmatched month ${monthString} in Chinese year ${year}`);\n            month = monthInfo.monthIndex;\n            return { year: year, month, day: day, era: undefined, eraYear, monthCode };\n        }\n        else {\n            // When called without input coming from legacy Date output,\n            // simply ensure that all fields are present.\n            this.validateCalendarDate(calendarDate);\n            if (year === undefined)\n                year = eraYear;\n            if (eraYear === undefined)\n                eraYear = year;\n            if (month === undefined) {\n                const months = this.getMonthList(year, cache);\n                let numberPart = monthCode.replace('L', 'bis').slice(1);\n                if (numberPart[0] === '0')\n                    numberPart = numberPart.slice(1);\n                let monthInfo = months[numberPart];\n                month = monthInfo && monthInfo.monthIndex;\n                // If this leap month isn't present in this year, constrain down to the last day of the previous month.\n                if (month === undefined &&\n                    monthCode.endsWith('L') &&\n                    !ArrayIncludes.call(['M01L', 'M12L', 'M13L'], monthCode) &&\n                    overflow === 'constrain') {\n                    let withoutML = monthCode.slice(1, -1);\n                    if (withoutML[0] === '0')\n                        withoutML = withoutML.slice(1);\n                    monthInfo = months[withoutML];\n                    if (monthInfo) {\n                        ({ daysInMonth: day, monthIndex: month } = monthInfo);\n                        monthCode = buildMonthCode(withoutML);\n                    }\n                }\n                if (month === undefined) {\n                    throw new RangeError(`Unmatched month ${monthCode} in Chinese year ${year}`);\n                }\n            }\n            else if (monthCode === undefined) {\n                const months = this.getMonthList(year, cache);\n                const monthEntries = ObjectEntries(months);\n                const largestMonth = monthEntries.length;\n                if (overflow === 'reject') {\n                    ES.RejectToRange(month, 1, largestMonth);\n                    ES.RejectToRange(day, 1, this.maximumMonthLength());\n                }\n                else {\n                    month = ES.ConstrainToRange(month, 1, largestMonth);\n                    day = ES.ConstrainToRange(day, 1, this.maximumMonthLength());\n                }\n                const matchingMonthEntry = monthEntries.find(([, v]) => v.monthIndex === month);\n                if (matchingMonthEntry === undefined) {\n                    throw new RangeError(`Invalid month ${month} in Chinese year ${year}`);\n                }\n                monthCode = buildMonthCode(matchingMonthEntry[0].replace('bis', ''), matchingMonthEntry[0].indexOf('bis') !== -1);\n            }\n            else {\n                // Both month and monthCode are present. Make sure they don't conflict.\n                const months = this.getMonthList(year, cache);\n                let numberPart = monthCode.replace('L', 'bis').slice(1);\n                if (numberPart[0] === '0')\n                    numberPart = numberPart.slice(1);\n                const monthInfo = months[numberPart];\n                if (!monthInfo)\n                    throw new RangeError(`Unmatched monthCode ${monthCode} in Chinese year ${year}`);\n                if (month !== monthInfo.monthIndex) {\n                    throw new RangeError(`monthCode ${monthCode} doesn't correspond to month ${month} in Chinese year ${year}`);\n                }\n            }\n            return {\n                ...calendarDate,\n                year: year,\n                eraYear,\n                month,\n                monthCode: monthCode,\n                day: day\n            };\n        }\n    }\n}\nclass ChineseHelper extends ChineseBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'chinese';\n    }\n}\n// Dangi (Korean) calendar has same implementation as Chinese\nclass DangiHelper extends ChineseBaseHelper {\n    constructor() {\n        super(...arguments);\n        this.id = 'dangi';\n    }\n}\n/**\n * Common implementation of all non-ISO calendars.\n * Per-calendar id and logic live in `id` and `helper` properties attached later.\n * This split allowed an easy separation between code that was similar between\n * ISO and non-ISO implementations vs. code that was very different.\n */\nconst nonIsoImpl = {\n    // `helper` is added when this object is spread into each calendar's\n    // implementation\n    helper: undefined,\n    dateFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        const cache = new OneObjectCache();\n        // Intentionally alphabetical\n        const fields = ES.PrepareTemporalFields(fieldsParam, ['day', 'era', 'eraYear', 'month', 'monthCode', 'year'], ['day']);\n        const { year, month, day } = this.helper.calendarToIsoDate(fields, overflow, cache);\n        const result = ES.CreateTemporalDate(year, month, day, calendar);\n        cache.setObject(result);\n        return result;\n    },\n    yearMonthFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        const cache = new OneObjectCache();\n        // Intentionally alphabetical\n        const fields = ES.PrepareTemporalFields(fieldsParam, ['era', 'eraYear', 'month', 'monthCode', 'year'], []);\n        const { year, month, day } = this.helper.calendarToIsoDate({ ...fields, day: 1 }, overflow, cache);\n        const result = ES.CreateTemporalYearMonth(year, month, calendar, /* referenceISODay = */ day);\n        cache.setObject(result);\n        return result;\n    },\n    monthDayFromFields(fieldsParam, options, calendar) {\n        const overflow = ES.ToTemporalOverflow(options);\n        // All built-in calendars require `day`, but some allow other fields to be\n        // substituted for `month`. And for lunisolar calendars, either `monthCode`\n        // or `year` must be provided because `month` is ambiguous without a year or\n        // a code.\n        const cache = new OneObjectCache();\n        const fields = ES.PrepareTemporalFields(fieldsParam, ['day', 'era', 'eraYear', 'month', 'monthCode', 'year'], ['day']);\n        const { year, month, day } = this.helper.monthDayFromFields(fields, overflow, cache);\n        // `year` is a reference year where this month/day exists in this calendar\n        const result = ES.CreateTemporalMonthDay(month, day, calendar, /* referenceISOYear = */ year);\n        cache.setObject(result);\n        return result;\n    },\n    fields(fieldsParam) {\n        let fields = fieldsParam;\n        if (ArrayIncludes.call(fields, 'year'))\n            fields = [...fields, 'era', 'eraYear'];\n        return fields;\n    },\n    mergeFields(fields, additionalFields) {\n        const fieldsCopy = { ...fields };\n        const additionalFieldsCopy = { ...additionalFields };\n        // era and eraYear are intentionally unused\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { month, monthCode, year, era, eraYear, ...original } = fieldsCopy;\n        const { month: newMonth, monthCode: newMonthCode, year: newYear, era: newEra, eraYear: newEraYear } = additionalFieldsCopy;\n        if (newMonth === undefined && newMonthCode === undefined) {\n            original.month = month;\n            original.monthCode = monthCode;\n        }\n        if (newYear === undefined && newEra === undefined && newEraYear === undefined) {\n            // Only `year` is needed. We don't set era and eraYear because it's\n            // possible to create a conflict for eras that start or end mid-year. See\n            // https://github.com/tc39/proposal-temporal/issues/1784.\n            original.year = year;\n        }\n        return { ...original, ...additionalFieldsCopy };\n    },\n    dateAdd(date, years, months, weeks, days, overflow, calendar) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const added = this.helper.addCalendar(calendarDate, { years, months, weeks, days }, overflow, cache);\n        const isoAdded = this.helper.calendarToIsoDate(added, 'constrain', cache);\n        const { year, month, day } = isoAdded;\n        const newTemporalObject = ES.CreateTemporalDate(year, month, day, calendar);\n        // The new object's cache starts with the cache of the old object\n        const newCache = new OneObjectCache(cache);\n        newCache.setObject(newTemporalObject);\n        return newTemporalObject;\n    },\n    dateUntil(one, two, largestUnit) {\n        const cacheOne = OneObjectCache.getCacheForObject(one);\n        const cacheTwo = OneObjectCache.getCacheForObject(two);\n        const calendarOne = this.helper.temporalToCalendarDate(one, cacheOne);\n        const calendarTwo = this.helper.temporalToCalendarDate(two, cacheTwo);\n        const result = this.helper.untilCalendar(calendarOne, calendarTwo, largestUnit, cacheOne);\n        return result;\n    },\n    year(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.year;\n    },\n    month(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.month;\n    },\n    day(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.day;\n    },\n    era(date) {\n        if (!this.helper.hasEra)\n            return undefined;\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.era;\n    },\n    eraYear(date) {\n        if (!this.helper.hasEra)\n            return undefined;\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.eraYear;\n    },\n    monthCode(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        return calendarDate.monthCode;\n    },\n    dayOfWeek(date) {\n        return impl['iso8601'].dayOfWeek(date);\n    },\n    dayOfYear(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.isoToCalendarDate(date, cache);\n        const startOfYear = this.helper.startOfCalendarYear(calendarDate);\n        const diffDays = this.helper.calendarDaysUntil(startOfYear, calendarDate, cache);\n        return diffDays + 1;\n    },\n    weekOfYear(date) {\n        return impl['iso8601'].weekOfYear(date);\n    },\n    daysInWeek(date) {\n        return impl['iso8601'].daysInWeek(date);\n    },\n    daysInMonth(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        // Easy case: if the helper knows the length without any heavy calculation.\n        const max = this.helper.maximumMonthLength(calendarDate);\n        const min = this.helper.minimumMonthLength(calendarDate);\n        if (max === min)\n            return max;\n        // The harder case is where months vary every year, e.g. islamic calendars.\n        // Find the answer by calculating the difference in days between the first\n        // day of the current month and the first day of the next month.\n        const startOfMonthCalendar = this.helper.startOfCalendarMonth(calendarDate);\n        const startOfNextMonthCalendar = this.helper.addMonthsCalendar(startOfMonthCalendar, 1, 'constrain', cache);\n        const result = this.helper.calendarDaysUntil(startOfMonthCalendar, startOfNextMonthCalendar, cache);\n        return result;\n    },\n    daysInYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ES.ToTemporalDate(date);\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const startOfYearCalendar = this.helper.startOfCalendarYear(calendarDate);\n        const startOfNextYearCalendar = this.helper.addCalendar(startOfYearCalendar, { years: 1 }, 'constrain', cache);\n        const result = this.helper.calendarDaysUntil(startOfYearCalendar, startOfNextYearCalendar, cache);\n        return result;\n    },\n    monthsInYear(date) {\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const result = this.helper.monthsInYear(calendarDate, cache);\n        return result;\n    },\n    inLeapYear(dateParam) {\n        let date = dateParam;\n        if (!HasSlot(date, ISO_YEAR))\n            date = ES.ToTemporalDate(date);\n        const cache = OneObjectCache.getCacheForObject(date);\n        const calendarDate = this.helper.temporalToCalendarDate(date, cache);\n        const result = this.helper.inLeapYear(calendarDate, cache);\n        return result;\n    }\n};\nfor (const Helper of [\n    HebrewHelper,\n    PersianHelper,\n    EthiopicHelper,\n    EthioaaHelper,\n    CopticHelper,\n    ChineseHelper,\n    DangiHelper,\n    RocHelper,\n    IndianHelper,\n    BuddhistHelper,\n    GregoryHelper,\n    JapaneseHelper,\n    IslamicHelper,\n    IslamicUmalquraHelper,\n    IslamicTblaHelper,\n    IslamicCivilHelper,\n    IslamicRgsaHelper,\n    IslamicCcHelper\n]) {\n    const helper = new Helper();\n    // Clone the singleton non-ISO implementation that's the same for all\n    // calendars. The `helper` property contains per-calendar logic.\n    impl[helper.id] = { ...nonIsoImpl, helper };\n}\n//# sourceMappingURL=calendar.js.map","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CALENDAR, EPOCHNANOSECONDS, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nexport class PlainDate {\n    constructor(isoYearParam, isoMonthParam, isoDayParam, calendarParam = ES.GetISO8601Calendar()) {\n        const isoYear = ES.ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ES.ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ES.ToIntegerThrowOnInfinity(isoDayParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalDateSlots. This check\n        //       exists only to improve the error message.\n        if (arguments.length < 3) {\n            throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n        }\n        ES.CreateTemporalDateSlots(this, isoYear, isoMonth, isoDay, calendar);\n    }\n    get calendar() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get era() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get year() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfWeek() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get weekOfYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInWeek() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalDateLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalDateLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalDateLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const props = ES.PrepareTemporalFields(temporalDateLike, fieldNames, 'partial');\n        if (!props) {\n            throw new TypeError('invalid date-like');\n        }\n        let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.CalendarDateFromFields(calendar, fields, options);\n    }\n    withCalendar(calendarParam) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        return new PlainDate(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), calendar);\n    }\n    add(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.ToTemporalDuration(temporalDurationLike);\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n    }\n    subtract(temporalDurationLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const duration = ES.CreateNegatedTemporalDuration(ES.ToTemporalDuration(temporalDurationLike));\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.CalendarDateAdd(GetSlot(this, CALENDAR), this, duration, options);\n    }\n    until(other, options = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.DifferenceTemporalPlainDate('until', this, other, options);\n    }\n    since(other, options = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.DifferenceTemporalPlainDate('since', this, other, options);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDate(otherParam);\n        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const showCalendar = ES.ToShowCalendarOption(options);\n        return ES.TemporalDateToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainDate');\n    }\n    toPlainDateTime(temporalTimeParam = undefined) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        if (temporalTimeParam === undefined)\n            return ES.CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n        const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    toZonedDateTime(item) {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        let timeZone, temporalTime;\n        if (ES.IsObject(item)) {\n            const timeZoneLike = item.timeZone;\n            if (timeZoneLike === undefined) {\n                // The cast below is needed because it's possible here for\n                // `timeZoneLike` here to be `{ plainTime: Temporal.PlainTimeLike }`,\n                // not a TimeZoneProtocol.\n                // TODO: should we check for that shape to improve on the (bad) error\n                // message that the caller will get from ToTemporalTimeZone?\n                timeZone = ES.ToTemporalTimeZone(item);\n            }\n            else {\n                timeZone = ES.ToTemporalTimeZone(timeZoneLike);\n                temporalTime = item.plainTime;\n            }\n        }\n        else {\n            timeZone = ES.ToTemporalTimeZone(item);\n        }\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        let hour = 0, minute = 0, second = 0, millisecond = 0, microsecond = 0, nanosecond = 0;\n        if (temporalTime !== undefined) {\n            temporalTime = ES.ToTemporalTime(temporalTime);\n            hour = GetSlot(temporalTime, ISO_HOUR);\n            minute = GetSlot(temporalTime, ISO_MINUTE);\n            second = GetSlot(temporalTime, ISO_SECOND);\n            millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n            microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n            nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        }\n        const dt = ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toPlainYearMonth() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n        return ES.CalendarYearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n        return ES.CalendarMonthDayFromFields(calendar, fields);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalDate(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalDate(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            return ES.CreateTemporalDate(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR));\n        }\n        return ES.ToTemporalDate(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalDate(oneParam);\n        const two = ES.ToTemporalDate(twoParam);\n        return ES.CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainDate, 'Temporal.PlainDate');\n//# sourceMappingURL=plaindate.js.map","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CALENDAR, EPOCHNANOSECONDS, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nexport class PlainDateTime {\n    constructor(isoYearParam, isoMonthParam, isoDayParam, hourParam = 0, minuteParam = 0, secondParam = 0, millisecondParam = 0, microsecondParam = 0, nanosecondParam = 0, calendarParam = ES.GetISO8601Calendar()) {\n        const isoYear = ES.ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ES.ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ES.ToIntegerThrowOnInfinity(isoDayParam);\n        const hour = ES.ToIntegerThrowOnInfinity(hourParam);\n        const minute = ES.ToIntegerThrowOnInfinity(minuteParam);\n        const second = ES.ToIntegerThrowOnInfinity(secondParam);\n        const millisecond = ES.ToIntegerThrowOnInfinity(millisecondParam);\n        const microsecond = ES.ToIntegerThrowOnInfinity(microsecondParam);\n        const nanosecond = ES.ToIntegerThrowOnInfinity(nanosecondParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectDateTime in CreateTemporalDateTimeSlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 3) {\n            throw new RangeError('missing argument: isoYear, isoMonth and isoDay are required');\n        }\n        ES.CreateTemporalDateTimeSlots(this, isoYear, isoMonth, isoDay, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    get calendar() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get year() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get hour() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_HOUR);\n    }\n    get minute() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MINUTE);\n    }\n    get second() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_SECOND);\n    }\n    get millisecond() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_NANOSECOND);\n    }\n    get era() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfWeek() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), this);\n    }\n    get dayOfYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get weekOfYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInWeek() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalDateTimeLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalDateTimeLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalDateTimeLike);\n        const options = ES.GetOptionsObject(optionsParam);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const props = ES.PrepareTemporalFields(temporalDateTimeLike, fieldNames, 'partial');\n        if (!props) {\n            throw new TypeError('invalid date-time-like');\n        }\n        let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n        const { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.InterpretTemporalDateTimeFields(calendar, fields, options);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withPlainTime(temporalTimeParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const year = GetSlot(this, ISO_YEAR);\n        const month = GetSlot(this, ISO_MONTH);\n        const day = GetSlot(this, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        if (temporalTimeParam === undefined)\n            return ES.CreateTemporalDateTime(year, month, day, 0, 0, 0, 0, 0, 0, calendar);\n        const temporalTime = ES.ToTemporalTime(temporalTimeParam);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withPlainDate(temporalDateParam) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ES.ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        let calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        calendar = ES.ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    withCalendar(calendarParam) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        return new PlainDateTime(GetSlot(this, ISO_YEAR), GetSlot(this, ISO_MONTH), GetSlot(this, ISO_DAY), GetSlot(this, ISO_HOUR), GetSlot(this, ISO_MINUTE), GetSlot(this, ISO_SECOND), GetSlot(this, ISO_MILLISECOND), GetSlot(this, ISO_MICROSECOND), GetSlot(this, ISO_NANOSECOND), calendar);\n    }\n    add(temporalDurationLike, options = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.AddDurationToOrSubtractDurationFromPlainDateTime('add', this, temporalDurationLike, options);\n    }\n    subtract(temporalDurationLike, options = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.AddDurationToOrSubtractDurationFromPlainDateTime('subtract', this, temporalDurationLike, options);\n    }\n    until(other, options = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.DifferenceTemporalPlainDateTime('until', this, other, options);\n    }\n    since(other, options = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.DifferenceTemporalPlainDateTime('since', this, other, options);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            day: 1,\n            hour: 24,\n            minute: 60,\n            second: 60,\n            millisecond: 1000,\n            microsecond: 1000,\n            nanosecond: 1000\n        };\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n        let year = GetSlot(this, ISO_YEAR);\n        let month = GetSlot(this, ISO_MONTH);\n        let day = GetSlot(this, ISO_DAY);\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, GetSlot(this, CALENDAR));\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalDateTime(otherParam);\n        for (const slot of [\n            ISO_YEAR,\n            ISO_MONTH,\n            ISO_DAY,\n            ISO_HOUR,\n            ISO_MINUTE,\n            ISO_SECOND,\n            ISO_MILLISECOND,\n            ISO_MICROSECOND,\n            ISO_NANOSECOND\n        ]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        const showCalendar = ES.ToShowCalendarOption(options);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        return ES.TemporalDateTimeToString(this, precision, showCalendar, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToString(this, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainDateTime');\n    }\n    toZonedDateTime(temporalTimeZoneLike, optionsParam = undefined) {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const timeZone = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n        const options = ES.GetOptionsObject(optionsParam);\n        const disambiguation = ES.ToTemporalDisambiguation(options);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, this, disambiguation);\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n    }\n    toPlainDate() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToDate(this);\n    }\n    toPlainYearMonth() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n        return ES.CalendarYearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n        return ES.CalendarMonthDayFromFields(calendar, fields);\n    }\n    toPlainTime() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToTime(this);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalDateTime(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoHour: GetSlot(this, ISO_HOUR),\n            isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n            isoMinute: GetSlot(this, ISO_MINUTE),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n            isoSecond: GetSlot(this, ISO_SECOND),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalDateTime(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            return ES.CreateTemporalDateTime(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND), GetSlot(item, CALENDAR));\n        }\n        return ES.ToTemporalDateTime(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalDateTime(oneParam);\n        const two = ES.ToTemporalDateTime(twoParam);\n        for (const slot of [\n            ISO_YEAR,\n            ISO_MONTH,\n            ISO_DAY,\n            ISO_HOUR,\n            ISO_MINUTE,\n            ISO_SECOND,\n            ISO_MILLISECOND,\n            ISO_MICROSECOND,\n            ISO_NANOSECOND\n        ]) {\n            const val1 = GetSlot(one, slot);\n            const val2 = GetSlot(two, slot);\n            if (val1 !== val2)\n                return ES.ComparisonResult(val1 - val2);\n        }\n        return 0;\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainDateTime, 'Temporal.PlainDateTime');\n//# sourceMappingURL=plaindatetime.js.map","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { YEARS, MONTHS, WEEKS, DAYS, HOURS, MINUTES, SECONDS, MILLISECONDS, MICROSECONDS, NANOSECONDS, CreateSlots, GetSlot, SetSlot } from './slots';\nimport JSBI from 'jsbi';\nexport class Duration {\n    constructor(yearsParam = 0, monthsParam = 0, weeksParam = 0, daysParam = 0, hoursParam = 0, minutesParam = 0, secondsParam = 0, millisecondsParam = 0, microsecondsParam = 0, nanosecondsParam = 0) {\n        const years = ES.ToIntegerWithoutRounding(yearsParam);\n        const months = ES.ToIntegerWithoutRounding(monthsParam);\n        const weeks = ES.ToIntegerWithoutRounding(weeksParam);\n        const days = ES.ToIntegerWithoutRounding(daysParam);\n        const hours = ES.ToIntegerWithoutRounding(hoursParam);\n        const minutes = ES.ToIntegerWithoutRounding(minutesParam);\n        const seconds = ES.ToIntegerWithoutRounding(secondsParam);\n        const milliseconds = ES.ToIntegerWithoutRounding(millisecondsParam);\n        const microseconds = ES.ToIntegerWithoutRounding(microsecondsParam);\n        const nanoseconds = ES.ToIntegerWithoutRounding(nanosecondsParam);\n        ES.RejectDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        CreateSlots(this);\n        SetSlot(this, YEARS, years);\n        SetSlot(this, MONTHS, months);\n        SetSlot(this, WEEKS, weeks);\n        SetSlot(this, DAYS, days);\n        SetSlot(this, HOURS, hours);\n        SetSlot(this, MINUTES, minutes);\n        SetSlot(this, SECONDS, seconds);\n        SetSlot(this, MILLISECONDS, milliseconds);\n        SetSlot(this, MICROSECONDS, microseconds);\n        SetSlot(this, NANOSECONDS, nanoseconds);\n        if (DEBUG) {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${ES.TemporalDurationToString(this)}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get years() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, YEARS);\n    }\n    get months() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MONTHS);\n    }\n    get weeks() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, WEEKS);\n    }\n    get days() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, DAYS);\n    }\n    get hours() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, HOURS);\n    }\n    get minutes() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MINUTES);\n    }\n    get seconds() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, SECONDS);\n    }\n    get milliseconds() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MILLISECONDS);\n    }\n    get microseconds() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, MICROSECONDS);\n    }\n    get nanoseconds() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, NANOSECONDS);\n    }\n    get sign() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return ES.DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS));\n    }\n    get blank() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return (ES.DurationSign(GetSlot(this, YEARS), GetSlot(this, MONTHS), GetSlot(this, WEEKS), GetSlot(this, DAYS), GetSlot(this, HOURS), GetSlot(this, MINUTES), GetSlot(this, SECONDS), GetSlot(this, MILLISECONDS), GetSlot(this, MICROSECONDS), GetSlot(this, NANOSECONDS)) === 0);\n    }\n    with(durationLike) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        const props = ES.PrepareTemporalFields(durationLike, \n        // NOTE: Field order here is important.\n        [\n            'days',\n            'hours',\n            'microseconds',\n            'milliseconds',\n            'minutes',\n            'months',\n            'nanoseconds',\n            'seconds',\n            'weeks',\n            'years'\n        ], 'partial');\n        if (!props) {\n            throw new TypeError('invalid duration-like');\n        }\n        const { years = GetSlot(this, YEARS), months = GetSlot(this, MONTHS), weeks = GetSlot(this, WEEKS), days = GetSlot(this, DAYS), hours = GetSlot(this, HOURS), minutes = GetSlot(this, MINUTES), seconds = GetSlot(this, SECONDS), milliseconds = GetSlot(this, MILLISECONDS), microseconds = GetSlot(this, MICROSECONDS), nanoseconds = GetSlot(this, NANOSECONDS) } = props;\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    negated() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return ES.CreateNegatedTemporalDuration(this);\n    }\n    abs() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return new Duration(Math.abs(GetSlot(this, YEARS)), Math.abs(GetSlot(this, MONTHS)), Math.abs(GetSlot(this, WEEKS)), Math.abs(GetSlot(this, DAYS)), Math.abs(GetSlot(this, HOURS)), Math.abs(GetSlot(this, MINUTES)), Math.abs(GetSlot(this, SECONDS)), Math.abs(GetSlot(this, MILLISECONDS)), Math.abs(GetSlot(this, MICROSECONDS)), Math.abs(GetSlot(this, NANOSECONDS)));\n    }\n    add(other, options = undefined) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return ES.AddDurationToOrSubtractDurationFromDuration('add', this, other, options);\n    }\n    subtract(other, options = undefined) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return ES.AddDurationToOrSubtractDurationFromDuration('subtract', this, other, options);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        let years = GetSlot(this, YEARS);\n        let months = GetSlot(this, MONTHS);\n        let weeks = GetSlot(this, WEEKS);\n        let days = GetSlot(this, DAYS);\n        let hours = GetSlot(this, HOURS);\n        let minutes = GetSlot(this, MINUTES);\n        let seconds = GetSlot(this, SECONDS);\n        let milliseconds = GetSlot(this, MILLISECONDS);\n        let microseconds = GetSlot(this, MICROSECONDS);\n        let nanoseconds = GetSlot(this, NANOSECONDS);\n        let defaultLargestUnit = ES.DefaultTemporalLargestUnit(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        let smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'datetime', undefined);\n        let smallestUnitPresent = true;\n        if (!smallestUnit) {\n            smallestUnitPresent = false;\n            smallestUnit = 'nanosecond';\n        }\n        defaultLargestUnit = ES.LargerOfTwoTemporalUnits(defaultLargestUnit, smallestUnit);\n        let largestUnit = ES.GetTemporalUnit(options, 'largestUnit', 'datetime', undefined, ['auto']);\n        let largestUnitPresent = true;\n        if (!largestUnit) {\n            largestUnitPresent = false;\n            largestUnit = defaultLargestUnit;\n        }\n        if (largestUnit === 'auto')\n            largestUnit = defaultLargestUnit;\n        if (!smallestUnitPresent && !largestUnitPresent) {\n            throw new RangeError('at least one of smallestUnit or largestUnit is required');\n        }\n        if (ES.LargerOfTwoTemporalUnits(largestUnit, smallestUnit) !== largestUnit) {\n            throw new RangeError(`largestUnit ${largestUnit} cannot be smaller than smallestUnit ${smallestUnit}`);\n        }\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const roundingIncrement = ES.ToTemporalDateTimeRoundingIncrement(options, smallestUnit);\n        let relativeTo = ES.ToRelativeTemporalObject(options);\n        ({ years, months, weeks, days } = ES.UnbalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } =\n            ES.AdjustRoundedDurationDays(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, roundingIncrement, smallestUnit, roundingMode, relativeTo));\n        ({ years, months, weeks, days } = ES.BalanceDurationRelative(years, months, weeks, days, largestUnit, relativeTo));\n        if (ES.IsTemporalZonedDateTime(relativeTo)) {\n            relativeTo = ES.MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n        }\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, largestUnit, relativeTo));\n        return new Duration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds);\n    }\n    total(optionsParam) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        let years = GetSlot(this, YEARS);\n        let months = GetSlot(this, MONTHS);\n        let weeks = GetSlot(this, WEEKS);\n        let days = GetSlot(this, DAYS);\n        let hours = GetSlot(this, HOURS);\n        let minutes = GetSlot(this, MINUTES);\n        let seconds = GetSlot(this, SECONDS);\n        let milliseconds = GetSlot(this, MILLISECONDS);\n        let microseconds = GetSlot(this, MICROSECONDS);\n        let nanoseconds = GetSlot(this, NANOSECONDS);\n        if (optionsParam === undefined)\n            throw new TypeError('options argument is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('unit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const unit = ES.GetTemporalUnit(options, 'unit', 'datetime', ES.REQUIRED);\n        const relativeTo = ES.ToRelativeTemporalObject(options);\n        // Convert larger units down to days\n        ({ years, months, weeks, days } = ES.UnbalanceDurationRelative(years, months, weeks, days, unit, relativeTo));\n        // If the unit we're totalling is smaller than `days`, convert days down to that unit.\n        let intermediate;\n        if (ES.IsTemporalZonedDateTime(relativeTo)) {\n            intermediate = ES.MoveRelativeZonedDateTime(relativeTo, years, months, weeks, 0);\n        }\n        ({ days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds } = ES.BalanceDuration(days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, unit, intermediate));\n        // Finally, truncate to the correct unit and calculate remainder\n        const { total } = ES.RoundDuration(years, months, weeks, days, hours, minutes, seconds, milliseconds, microseconds, nanoseconds, 1, unit, 'trunc', relativeTo);\n        return total;\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        if (precision === 'minute')\n            throw new RangeError('smallestUnit must not be \"minute\"');\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        return ES.TemporalDurationToString(this, precision, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDurationToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalDuration(this))\n            throw new TypeError('invalid receiver');\n        if (typeof Intl !== 'undefined' && typeof Intl.DurationFormat !== 'undefined') {\n            return new Intl.DurationFormat(locales, options).format(this);\n        }\n        console.warn('Temporal.Duration.prototype.toLocaleString() requires Intl.DurationFormat.');\n        return ES.TemporalDurationToString(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() to compare Temporal.Duration');\n    }\n    static from(item) {\n        if (ES.IsTemporalDuration(item)) {\n            return new Duration(GetSlot(item, YEARS), GetSlot(item, MONTHS), GetSlot(item, WEEKS), GetSlot(item, DAYS), GetSlot(item, HOURS), GetSlot(item, MINUTES), GetSlot(item, SECONDS), GetSlot(item, MILLISECONDS), GetSlot(item, MICROSECONDS), GetSlot(item, NANOSECONDS));\n        }\n        return ES.ToTemporalDuration(item);\n    }\n    static compare(oneParam, twoParam, optionsParam = undefined) {\n        const one = ES.ToTemporalDuration(oneParam);\n        const two = ES.ToTemporalDuration(twoParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const relativeTo = ES.ToRelativeTemporalObject(options);\n        const y1 = GetSlot(one, YEARS);\n        const mon1 = GetSlot(one, MONTHS);\n        const w1 = GetSlot(one, WEEKS);\n        let d1 = GetSlot(one, DAYS);\n        const h1 = GetSlot(one, HOURS);\n        const min1 = GetSlot(one, MINUTES);\n        const s1 = GetSlot(one, SECONDS);\n        const ms1 = GetSlot(one, MILLISECONDS);\n        const µs1 = GetSlot(one, MICROSECONDS);\n        let ns1 = GetSlot(one, NANOSECONDS);\n        const y2 = GetSlot(two, YEARS);\n        const mon2 = GetSlot(two, MONTHS);\n        const w2 = GetSlot(two, WEEKS);\n        let d2 = GetSlot(two, DAYS);\n        const h2 = GetSlot(two, HOURS);\n        const min2 = GetSlot(two, MINUTES);\n        const s2 = GetSlot(two, SECONDS);\n        const ms2 = GetSlot(two, MILLISECONDS);\n        const µs2 = GetSlot(two, MICROSECONDS);\n        let ns2 = GetSlot(two, NANOSECONDS);\n        const shift1 = ES.CalculateOffsetShift(relativeTo, y1, mon1, w1, d1);\n        const shift2 = ES.CalculateOffsetShift(relativeTo, y2, mon2, w2, d2);\n        if (y1 !== 0 || y2 !== 0 || mon1 !== 0 || mon2 !== 0 || w1 !== 0 || w2 !== 0) {\n            ({ days: d1 } = ES.UnbalanceDurationRelative(y1, mon1, w1, d1, 'day', relativeTo));\n            ({ days: d2 } = ES.UnbalanceDurationRelative(y2, mon2, w2, d2, 'day', relativeTo));\n        }\n        const totalNs1 = ES.TotalDurationNanoseconds(d1, h1, min1, s1, ms1, µs1, ns1, shift1);\n        const totalNs2 = ES.TotalDurationNanoseconds(d2, h2, min2, s2, ms2, µs2, ns2, shift2);\n        return ES.ComparisonResult(JSBI.toNumber(JSBI.subtract(totalNs1, totalNs2)));\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(Duration, 'Temporal.Duration');\n//# sourceMappingURL=duration.js.map","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_MONTH, ISO_DAY, ISO_YEAR, CALENDAR, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nconst ObjectCreate = Object.create;\nexport class PlainMonthDay {\n    constructor(isoMonthParam, isoDayParam, calendarParam = ES.GetISO8601Calendar(), referenceISOYearParam = 1972) {\n        const isoMonth = ES.ToIntegerThrowOnInfinity(isoMonthParam);\n        const isoDay = ES.ToIntegerThrowOnInfinity(isoDayParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        const referenceISOYear = ES.ToIntegerThrowOnInfinity(referenceISOYearParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalMonthDaySlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 2) {\n            throw new RangeError('missing argument: isoMonth and isoDay are required');\n        }\n        ES.CreateTemporalMonthDaySlots(this, isoMonth, isoDay, calendar, referenceISOYear);\n    }\n    get monthCode() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get day() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDay(GetSlot(this, CALENDAR), this);\n    }\n    get calendar() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    with(temporalMonthDayLike, optionsParam = undefined) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalMonthDayLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalMonthDayLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'month', 'monthCode', 'year']);\n        const props = ES.PrepareTemporalFields(temporalMonthDayLike, fieldNames, 'partial');\n        if (!props) {\n            throw new TypeError('invalid month-day-like');\n        }\n        let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.CalendarMonthDayFromFields(calendar, fields, options);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalMonthDay(otherParam);\n        for (const slot of [ISO_MONTH, ISO_DAY, ISO_YEAR]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const showCalendar = ES.ToShowCalendarOption(options);\n        return ES.TemporalMonthDayToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalMonthDayToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use equals() to compare Temporal.PlainMonthDay');\n    }\n    toPlainDate(item) {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(item))\n            throw new TypeError('argument should be an object');\n        const calendar = GetSlot(this, CALENDAR);\n        const receiverFieldNames = ES.CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ES.PrepareTemporalFields(this, receiverFieldNames, []);\n        const inputFieldNames = ES.CalendarFields(calendar, ['year']);\n        const inputFields = ES.PrepareTemporalFields(item, inputFieldNames, []);\n        let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n        // TODO: Use MergeLists abstract operation.\n        const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n        mergedFields = ES.PrepareTemporalFields(mergedFields, mergedFieldNames, []);\n        const options = ObjectCreate(null);\n        options.overflow = 'reject';\n        return ES.CalendarDateFromFields(calendar, mergedFields, options);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalMonthDay(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalMonthDay(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            return ES.CreateTemporalMonthDay(GetSlot(item, ISO_MONTH), GetSlot(item, ISO_DAY), GetSlot(item, CALENDAR), GetSlot(item, ISO_YEAR));\n        }\n        return ES.ToTemporalMonthDay(item, options);\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainMonthDay, 'Temporal.PlainMonthDay');\n//# sourceMappingURL=plainmonthday.js.map","import * as ES from './ecmascript';\nimport { GetIntrinsic } from './intrinsicclass';\nconst instant = () => {\n    const Instant = GetIntrinsic('%Temporal.Instant%');\n    return new Instant(ES.SystemUTCEpochNanoSeconds());\n};\nconst plainDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    const tZ = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ES.ToTemporalCalendar(calendarLike);\n    const inst = instant();\n    return ES.BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst plainDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    const tZ = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ES.GetISO8601Calendar();\n    const inst = instant();\n    return ES.BuiltinTimeZoneGetPlainDateTimeFor(tZ, inst, calendar);\n};\nconst zonedDateTime = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    const tZ = ES.ToTemporalTimeZone(temporalTimeZoneLike);\n    const calendar = ES.ToTemporalCalendar(calendarLike);\n    return ES.CreateTemporalZonedDateTime(ES.SystemUTCEpochNanoSeconds(), tZ, calendar);\n};\nconst zonedDateTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    return zonedDateTime(ES.GetISO8601Calendar(), temporalTimeZoneLike);\n};\nconst plainDate = (calendarLike, temporalTimeZoneLike = timeZone()) => {\n    return ES.TemporalDateTimeToDate(plainDateTime(calendarLike, temporalTimeZoneLike));\n};\nconst plainDateISO = (temporalTimeZoneLike = timeZone()) => {\n    return ES.TemporalDateTimeToDate(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst plainTimeISO = (temporalTimeZoneLike = timeZone()) => {\n    return ES.TemporalDateTimeToTime(plainDateTimeISO(temporalTimeZoneLike));\n};\nconst timeZone = () => {\n    return ES.SystemTimeZone();\n};\nexport const Now = {\n    instant,\n    plainDateTime,\n    plainDateTimeISO,\n    plainDate,\n    plainDateISO,\n    plainTimeISO,\n    timeZone,\n    zonedDateTime,\n    zonedDateTimeISO,\n    [Symbol.toStringTag]: 'Temporal.Now'\n};\nObject.defineProperty(Now, Symbol.toStringTag, {\n    value: 'Temporal.Now',\n    writable: false,\n    enumerable: false,\n    configurable: true\n});\n//# sourceMappingURL=now.js.map","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CALENDAR, EPOCHNANOSECONDS, CreateSlots, GetSlot, SetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nconst ObjectAssign = Object.assign;\nfunction TemporalTimeToString(time, precision, options = undefined) {\n    let hour = GetSlot(time, ISO_HOUR);\n    let minute = GetSlot(time, ISO_MINUTE);\n    let second = GetSlot(time, ISO_SECOND);\n    let millisecond = GetSlot(time, ISO_MILLISECOND);\n    let microsecond = GetSlot(time, ISO_MICROSECOND);\n    let nanosecond = GetSlot(time, ISO_NANOSECOND);\n    if (options) {\n        const { unit, increment, roundingMode } = options;\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, increment, unit, roundingMode));\n    }\n    const hourString = ES.ISODateTimePartString(hour);\n    const minuteString = ES.ISODateTimePartString(minute);\n    const seconds = ES.FormatSecondsStringPart(second, millisecond, microsecond, nanosecond, precision);\n    return `${hourString}:${minuteString}${seconds}`;\n}\nexport class PlainTime {\n    constructor(isoHourParam = 0, isoMinuteParam = 0, isoSecondParam = 0, isoMillisecondParam = 0, isoMicrosecondParam = 0, isoNanosecondParam = 0) {\n        const isoHour = ES.ToIntegerThrowOnInfinity(isoHourParam);\n        const isoMinute = ES.ToIntegerThrowOnInfinity(isoMinuteParam);\n        const isoSecond = ES.ToIntegerThrowOnInfinity(isoSecondParam);\n        const isoMillisecond = ES.ToIntegerThrowOnInfinity(isoMillisecondParam);\n        const isoMicrosecond = ES.ToIntegerThrowOnInfinity(isoMicrosecondParam);\n        const isoNanosecond = ES.ToIntegerThrowOnInfinity(isoNanosecondParam);\n        ES.RejectTime(isoHour, isoMinute, isoSecond, isoMillisecond, isoMicrosecond, isoNanosecond);\n        CreateSlots(this);\n        SetSlot(this, ISO_HOUR, isoHour);\n        SetSlot(this, ISO_MINUTE, isoMinute);\n        SetSlot(this, ISO_SECOND, isoSecond);\n        SetSlot(this, ISO_MILLISECOND, isoMillisecond);\n        SetSlot(this, ISO_MICROSECOND, isoMicrosecond);\n        SetSlot(this, ISO_NANOSECOND, isoNanosecond);\n        SetSlot(this, CALENDAR, ES.GetISO8601Calendar());\n        if (DEBUG) {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${TemporalTimeToString(this, 'auto')}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get calendar() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        // PlainTime's calendar isn't settable, so can't be a userland calendar\n        return GetSlot(this, CALENDAR);\n    }\n    get hour() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_HOUR);\n    }\n    get minute() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MINUTE);\n    }\n    get second() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_SECOND);\n    }\n    get millisecond() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, ISO_NANOSECOND);\n    }\n    with(temporalTimeLike, optionsParam = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalTimeLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalTimeLike);\n        const partialTime = ES.ToTemporalTimeRecord(temporalTimeLike, 'partial');\n        const options = ES.GetOptionsObject(optionsParam);\n        const overflow = ES.ToTemporalOverflow(options);\n        const fields = ES.ToTemporalTimeRecord(this);\n        let { hour, minute, second, millisecond, microsecond, nanosecond } = ObjectAssign(fields, partialTime);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RegulateTime(hour, minute, second, millisecond, microsecond, nanosecond, overflow));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    add(temporalDurationLike) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.AddDurationToOrSubtractDurationFromPlainTime('add', this, temporalDurationLike);\n    }\n    subtract(temporalDurationLike) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.AddDurationToOrSubtractDurationFromPlainTime('subtract', this, temporalDurationLike);\n    }\n    until(other, options = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.DifferenceTemporalPlainTime('until', this, other, options);\n    }\n    since(other, options = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.DifferenceTemporalPlainTime('since', this, other, options);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', ES.REQUIRED);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const MAX_INCREMENTS = {\n            hour: 24,\n            minute: 60,\n            second: 60,\n            millisecond: 1000,\n            microsecond: 1000,\n            nanosecond: 1000\n        };\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, MAX_INCREMENTS[smallestUnit], false);\n        let hour = GetSlot(this, ISO_HOUR);\n        let minute = GetSlot(this, ISO_MINUTE);\n        let second = GetSlot(this, ISO_SECOND);\n        let millisecond = GetSlot(this, ISO_MILLISECOND);\n        let microsecond = GetSlot(this, ISO_MICROSECOND);\n        let nanosecond = GetSlot(this, ISO_NANOSECOND);\n        ({ hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundTime(hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode));\n        return new PlainTime(hour, minute, second, millisecond, microsecond, nanosecond);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalTime(otherParam);\n        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return true;\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        return TemporalTimeToString(this, precision, { unit, increment, roundingMode });\n    }\n    toJSON() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return TemporalTimeToString(this, 'auto');\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainTime');\n    }\n    toPlainDateTime(temporalDateParam) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ES.ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        const calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        return ES.CreateTemporalDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n    }\n    toZonedDateTime(item) {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(item)) {\n            throw new TypeError('invalid argument');\n        }\n        const dateLike = item.plainDate;\n        if (dateLike === undefined) {\n            throw new TypeError('missing date property');\n        }\n        const temporalDate = ES.ToTemporalDate(dateLike);\n        const timeZoneLike = item.timeZone;\n        if (timeZoneLike === undefined) {\n            throw new TypeError('missing timeZone property');\n        }\n        const timeZone = ES.ToTemporalTimeZone(timeZoneLike);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        const calendar = GetSlot(temporalDate, CALENDAR);\n        const hour = GetSlot(this, ISO_HOUR);\n        const minute = GetSlot(this, ISO_MINUTE);\n        const second = GetSlot(this, ISO_SECOND);\n        const millisecond = GetSlot(this, ISO_MILLISECOND);\n        const microsecond = GetSlot(this, ISO_MICROSECOND);\n        const nanosecond = GetSlot(this, ISO_NANOSECOND);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalTime(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoHour: GetSlot(this, ISO_HOUR),\n            isoMicrosecond: GetSlot(this, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(this, ISO_MILLISECOND),\n            isoMinute: GetSlot(this, ISO_MINUTE),\n            isoNanosecond: GetSlot(this, ISO_NANOSECOND),\n            isoSecond: GetSlot(this, ISO_SECOND)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        const overflow = ES.ToTemporalOverflow(options);\n        if (ES.IsTemporalTime(item)) {\n            return new PlainTime(GetSlot(item, ISO_HOUR), GetSlot(item, ISO_MINUTE), GetSlot(item, ISO_SECOND), GetSlot(item, ISO_MILLISECOND), GetSlot(item, ISO_MICROSECOND), GetSlot(item, ISO_NANOSECOND));\n        }\n        return ES.ToTemporalTime(item, overflow);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalTime(oneParam);\n        const two = ES.ToTemporalTime(twoParam);\n        for (const slot of [ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND]) {\n            const val1 = GetSlot(one, slot);\n            const val2 = GetSlot(two, slot);\n            if (val1 !== val2)\n                return ES.ComparisonResult(val1 - val2);\n        }\n        return 0;\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainTime, 'Temporal.PlainTime');\n//# sourceMappingURL=plaintime.js.map","import { DEBUG } from './debug';\nimport * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { TIMEZONE_ID, EPOCHNANOSECONDS, ISO_YEAR, ISO_MONTH, ISO_DAY, ISO_HOUR, ISO_MINUTE, ISO_SECOND, ISO_MILLISECOND, ISO_MICROSECOND, ISO_NANOSECOND, CreateSlots, GetSlot, SetSlot } from './slots';\nimport JSBI from 'jsbi';\nexport class TimeZone {\n    constructor(timeZoneIdentifierParam) {\n        // Note: if the argument is not passed, GetCanonicalTimeZoneIdentifier(undefined) will throw.\n        //       This check exists only to improve the error message.\n        if (arguments.length < 1) {\n            throw new RangeError('missing argument: identifier is required');\n        }\n        const timeZoneIdentifier = ES.GetCanonicalTimeZoneIdentifier(timeZoneIdentifierParam);\n        CreateSlots(this);\n        SetSlot(this, TIMEZONE_ID, timeZoneIdentifier);\n        if (DEBUG) {\n            Object.defineProperty(this, '_repr_', {\n                value: `${this[Symbol.toStringTag]} <${timeZoneIdentifier}>`,\n                writable: false,\n                enumerable: false,\n                configurable: false\n            });\n        }\n    }\n    get id() {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(this);\n    }\n    getOffsetNanosecondsFor(instantParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const instant = ES.ToTemporalInstant(instantParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        if (ES.TestTimeZoneOffsetString(id)) {\n            return ES.ParseTimeZoneOffsetString(id);\n        }\n        return ES.GetIANATimeZoneOffsetNanoseconds(GetSlot(instant, EPOCHNANOSECONDS), id);\n    }\n    getOffsetStringFor(instantParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const instant = ES.ToTemporalInstant(instantParam);\n        return ES.BuiltinTimeZoneGetOffsetStringFor(this, instant);\n    }\n    getPlainDateTimeFor(instantParam, calendarParam = ES.GetISO8601Calendar()) {\n        const instant = ES.ToTemporalInstant(instantParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        return ES.BuiltinTimeZoneGetPlainDateTimeFor(this, instant, calendar);\n    }\n    getInstantFor(dateTimeParam, optionsParam = undefined) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const dateTime = ES.ToTemporalDateTime(dateTimeParam);\n        const options = ES.GetOptionsObject(optionsParam);\n        const disambiguation = ES.ToTemporalDisambiguation(options);\n        return ES.BuiltinTimeZoneGetInstantFor(this, dateTime, disambiguation);\n    }\n    getPossibleInstantsFor(dateTimeParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const dateTime = ES.ToTemporalDateTime(dateTimeParam);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        const id = GetSlot(this, TIMEZONE_ID);\n        if (ES.TestTimeZoneOffsetString(id)) {\n            const epochNs = ES.GetEpochFromISOParts(GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n            if (epochNs === null)\n                throw new RangeError('DateTime outside of supported range');\n            const offsetNs = ES.ParseTimeZoneOffsetString(id);\n            return [new Instant(JSBI.subtract(epochNs, JSBI.BigInt(offsetNs)))];\n        }\n        const possibleEpochNs = ES.GetIANATimeZoneEpochValue(id, GetSlot(dateTime, ISO_YEAR), GetSlot(dateTime, ISO_MONTH), GetSlot(dateTime, ISO_DAY), GetSlot(dateTime, ISO_HOUR), GetSlot(dateTime, ISO_MINUTE), GetSlot(dateTime, ISO_SECOND), GetSlot(dateTime, ISO_MILLISECOND), GetSlot(dateTime, ISO_MICROSECOND), GetSlot(dateTime, ISO_NANOSECOND));\n        return possibleEpochNs.map((ns) => new Instant(ns));\n    }\n    getNextTransition(startingPointParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const startingPoint = ES.ToTemporalInstant(startingPointParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        // Offset time zones or UTC have no transitions\n        if (ES.TestTimeZoneOffsetString(id) || id === 'UTC') {\n            return null;\n        }\n        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        epochNanoseconds = ES.GetIANATimeZoneNextTransition(epochNanoseconds, id);\n        return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n    }\n    getPreviousTransition(startingPointParam) {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        const startingPoint = ES.ToTemporalInstant(startingPointParam);\n        const id = GetSlot(this, TIMEZONE_ID);\n        // Offset time zones or UTC have no transitions\n        if (ES.TestTimeZoneOffsetString(id) || id === 'UTC') {\n            return null;\n        }\n        let epochNanoseconds = GetSlot(startingPoint, EPOCHNANOSECONDS);\n        const Instant = GetIntrinsic('%Temporal.Instant%');\n        epochNanoseconds = ES.GetIANATimeZonePreviousTransition(epochNanoseconds, id);\n        return epochNanoseconds === null ? null : new Instant(epochNanoseconds);\n    }\n    toString() {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(GetSlot(this, TIMEZONE_ID));\n    }\n    toJSON() {\n        if (!ES.IsTemporalTimeZone(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToString(this);\n    }\n    static from(item) {\n        return ES.ToTemporalTimeZone(item);\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(TimeZone, 'Temporal.TimeZone');\n//# sourceMappingURL=timezone.js.map","import * as ES from './ecmascript';\nimport { MakeIntrinsicClass } from './intrinsicclass';\nimport { ISO_YEAR, ISO_MONTH, ISO_DAY, CALENDAR, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nconst ObjectCreate = Object.create;\nexport class PlainYearMonth {\n    constructor(isoYearParam, isoMonthParam, calendarParam = ES.GetISO8601Calendar(), referenceISODayParam = 1) {\n        const isoYear = ES.ToIntegerThrowOnInfinity(isoYearParam);\n        const isoMonth = ES.ToIntegerThrowOnInfinity(isoMonthParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        const referenceISODay = ES.ToIntegerThrowOnInfinity(referenceISODayParam);\n        // Note: if the arguments are not passed,\n        //       ToIntegerThrowOnInfinity(undefined) will have returned 0, which will\n        //       be rejected by RejectISODate in CreateTemporalYearMonthSlots. This\n        //       check exists only to improve the error message.\n        if (arguments.length < 2) {\n            throw new RangeError('missing argument: isoYear and isoMonth are required');\n        }\n        ES.CreateTemporalYearMonthSlots(this, isoYear, isoMonth, calendar, referenceISODay);\n    }\n    get year() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarYear(GetSlot(this, CALENDAR), this);\n    }\n    get month() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonth(GetSlot(this, CALENDAR), this);\n    }\n    get monthCode() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), this);\n    }\n    get calendar() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get era() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEra(GetSlot(this, CALENDAR), this);\n    }\n    get eraYear() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEraYear(GetSlot(this, CALENDAR), this);\n    }\n    get daysInMonth() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), this);\n    }\n    get daysInYear() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), this);\n    }\n    get monthsInYear() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), this);\n    }\n    get inLeapYear() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), this);\n    }\n    with(temporalYearMonthLike, optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalYearMonthLike)) {\n            throw new TypeError('invalid argument');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalYearMonthLike);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['month', 'monthCode', 'year']);\n        const props = ES.PrepareTemporalFields(temporalYearMonthLike, fieldNames, 'partial');\n        if (!props) {\n            throw new TypeError('invalid year-month-like');\n        }\n        let fields = ES.PrepareTemporalFields(this, fieldNames, []);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.PrepareTemporalFields(fields, fieldNames, []);\n        const options = ES.GetOptionsObject(optionsParam);\n        return ES.CalendarYearMonthFromFields(calendar, fields, options);\n    }\n    add(temporalDurationLike, options = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.AddDurationToOrSubtractDurationFromPlainYearMonth('add', this, temporalDurationLike, options);\n    }\n    subtract(temporalDurationLike, options = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.AddDurationToOrSubtractDurationFromPlainYearMonth('subtract', this, temporalDurationLike, options);\n    }\n    until(other, options = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.DifferenceTemporalPlainYearMonth('until', this, other, options);\n    }\n    since(other, options = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.DifferenceTemporalPlainYearMonth('since', this, other, options);\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalYearMonth(otherParam);\n        for (const slot of [ISO_YEAR, ISO_MONTH, ISO_DAY]) {\n            const val1 = GetSlot(this, slot);\n            const val2 = GetSlot(other, slot);\n            if (val1 !== val2)\n                return false;\n        }\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const showCalendar = ES.ToShowCalendarOption(options);\n        return ES.TemporalYearMonthToString(this, showCalendar);\n    }\n    toJSON() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalYearMonthToString(this);\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.PlainYearMonth');\n    }\n    toPlainDate(item) {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(item))\n            throw new TypeError('argument should be an object');\n        const calendar = GetSlot(this, CALENDAR);\n        const receiverFieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.PrepareTemporalFields(this, receiverFieldNames, []);\n        const inputFieldNames = ES.CalendarFields(calendar, ['day']);\n        const inputFields = ES.PrepareTemporalFields(item, inputFieldNames, []);\n        let mergedFields = ES.CalendarMergeFields(calendar, fields, inputFields);\n        // TODO: Use MergeLists abstract operation.\n        const mergedFieldNames = [...new Set([...receiverFieldNames, ...inputFieldNames])];\n        mergedFields = ES.PrepareTemporalFields(mergedFields, mergedFieldNames, []);\n        const options = ObjectCreate(null);\n        options.overflow = 'reject';\n        return ES.CalendarDateFromFields(calendar, mergedFields, options);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalYearMonth(this))\n            throw new TypeError('invalid receiver');\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(this, ISO_DAY),\n            isoMonth: GetSlot(this, ISO_MONTH),\n            isoYear: GetSlot(this, ISO_YEAR)\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalYearMonth(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            return ES.CreateTemporalYearMonth(GetSlot(item, ISO_YEAR), GetSlot(item, ISO_MONTH), GetSlot(item, CALENDAR), GetSlot(item, ISO_DAY));\n        }\n        return ES.ToTemporalYearMonth(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalYearMonth(oneParam);\n        const two = ES.ToTemporalYearMonth(twoParam);\n        return ES.CompareISODate(GetSlot(one, ISO_YEAR), GetSlot(one, ISO_MONTH), GetSlot(one, ISO_DAY), GetSlot(two, ISO_YEAR), GetSlot(two, ISO_MONTH), GetSlot(two, ISO_DAY));\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(PlainYearMonth, 'Temporal.PlainYearMonth');\n//# sourceMappingURL=plainyearmonth.js.map","import * as ES from './ecmascript';\nimport { GetIntrinsic, MakeIntrinsicClass } from './intrinsicclass';\nimport { CALENDAR, EPOCHNANOSECONDS, ISO_HOUR, INSTANT, ISO_DAY, ISO_MONTH, ISO_YEAR, ISO_MICROSECOND, ISO_MILLISECOND, ISO_MINUTE, ISO_NANOSECOND, ISO_SECOND, TIME_ZONE, GetSlot } from './slots';\nimport { DateTimeFormat } from './intl';\nimport JSBI from 'jsbi';\nimport { BILLION, MILLION, THOUSAND, ZERO } from './ecmascript';\nexport class ZonedDateTime {\n    constructor(epochNanosecondsParam, timeZoneParam, calendarParam = ES.GetISO8601Calendar()) {\n        // Note: if the argument is not passed, ToBigInt(undefined) will throw. This check exists only\n        //       to improve the error message.\n        //       ToTemporalTimeZone(undefined) will end up calling TimeZone.from(\"undefined\"), which\n        //       could succeed.\n        if (arguments.length < 1) {\n            throw new TypeError('missing argument: epochNanoseconds is required');\n        }\n        const epochNanoseconds = ES.ToBigInt(epochNanosecondsParam);\n        const timeZone = ES.ToTemporalTimeZone(timeZoneParam);\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        ES.CreateTemporalZonedDateTimeSlots(this, epochNanoseconds, timeZone, calendar);\n    }\n    get calendar() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, CALENDAR);\n    }\n    get timeZone() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(this, TIME_ZONE);\n    }\n    get year() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get month() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonth(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get monthCode() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthCode(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get day() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDay(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get hour() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_HOUR);\n    }\n    get minute() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MINUTE);\n    }\n    get second() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_SECOND);\n    }\n    get millisecond() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MILLISECOND);\n    }\n    get microsecond() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_MICROSECOND);\n    }\n    get nanosecond() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return GetSlot(dateTime(this), ISO_NANOSECOND);\n    }\n    get era() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEra(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get eraYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarEraYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get epochSeconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return JSBI.toNumber(JSBI.divide(value, BILLION));\n    }\n    get epochMilliseconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return JSBI.toNumber(JSBI.divide(value, MILLION));\n    }\n    get epochMicroseconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const value = GetSlot(this, EPOCHNANOSECONDS);\n        return ES.ToBigIntExternal(JSBI.divide(value, THOUSAND));\n    }\n    get epochNanoseconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.ToBigIntExternal(GetSlot(this, EPOCHNANOSECONDS));\n    }\n    get dayOfWeek() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfWeek(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get dayOfYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDayOfYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get weekOfYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarWeekOfYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get hoursInDay() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const year = GetSlot(dt, ISO_YEAR);\n        const month = GetSlot(dt, ISO_MONTH);\n        const day = GetSlot(dt, ISO_DAY);\n        const today = new DateTime(year, month, day, 0, 0, 0, 0, 0, 0);\n        const tomorrowFields = ES.AddISODate(year, month, day, 0, 0, 0, 1, 'reject');\n        const tomorrow = new DateTime(tomorrowFields.year, tomorrowFields.month, tomorrowFields.day, 0, 0, 0, 0, 0, 0);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const todayNs = GetSlot(ES.BuiltinTimeZoneGetInstantFor(timeZone, today, 'compatible'), EPOCHNANOSECONDS);\n        const tomorrowNs = GetSlot(ES.BuiltinTimeZoneGetInstantFor(timeZone, tomorrow, 'compatible'), EPOCHNANOSECONDS);\n        return JSBI.toNumber(JSBI.subtract(tomorrowNs, todayNs)) / 3.6e12;\n    }\n    get daysInWeek() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInWeek(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get daysInMonth() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInMonth(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get daysInYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarDaysInYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get monthsInYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarMonthsInYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get inLeapYear() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.CalendarInLeapYear(GetSlot(this, CALENDAR), dateTime(this));\n    }\n    get offset() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.BuiltinTimeZoneGetOffsetStringFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n    }\n    get offsetNanoseconds() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.GetOffsetNanosecondsFor(GetSlot(this, TIME_ZONE), GetSlot(this, INSTANT));\n    }\n    with(temporalZonedDateTimeLike, optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (!ES.IsObject(temporalZonedDateTimeLike)) {\n            throw new TypeError('invalid zoned-date-time-like');\n        }\n        ES.RejectObjectWithCalendarOrTimeZone(temporalZonedDateTimeLike);\n        // TODO: Reorder according to spec.\n        const options = ES.GetOptionsObject(optionsParam);\n        const disambiguation = ES.ToTemporalDisambiguation(options);\n        const offset = ES.ToTemporalOffset(options, 'prefer');\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, [\n            'day',\n            'hour',\n            'microsecond',\n            'millisecond',\n            'minute',\n            'month',\n            'monthCode',\n            'nanosecond',\n            'second',\n            'year'\n        ]);\n        const fieldsWithOffset = ES.ArrayPush(fieldNames, 'offset');\n        const props = ES.PrepareTemporalFields(temporalZonedDateTimeLike, fieldsWithOffset, 'partial');\n        const fieldsWithTimeZoneAndOffset = ES.ArrayPush(fieldsWithOffset, 'timeZone');\n        let fields = ES.PrepareTemporalFields(this, fieldsWithTimeZoneAndOffset, ['timeZone', 'offset']);\n        fields = ES.CalendarMergeFields(calendar, fields, props);\n        fields = ES.PrepareTemporalFields(fields, fieldsWithTimeZoneAndOffset, ['timeZone', 'offset']);\n        let { year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.InterpretTemporalDateTimeFields(calendar, fields, options);\n        const offsetNs = ES.ParseTimeZoneOffsetString(fields.offset);\n        const epochNanoseconds = ES.InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, disambiguation, offset, \n        /* matchMinute = */ false);\n        return ES.CreateTemporalZonedDateTime(epochNanoseconds, GetSlot(this, TIME_ZONE), calendar);\n    }\n    withPlainDate(temporalDateParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const temporalDate = ES.ToTemporalDate(temporalDateParam);\n        const year = GetSlot(temporalDate, ISO_YEAR);\n        const month = GetSlot(temporalDate, ISO_MONTH);\n        const day = GetSlot(temporalDate, ISO_DAY);\n        let calendar = GetSlot(temporalDate, CALENDAR);\n        const thisDt = dateTime(this);\n        const hour = GetSlot(thisDt, ISO_HOUR);\n        const minute = GetSlot(thisDt, ISO_MINUTE);\n        const second = GetSlot(thisDt, ISO_SECOND);\n        const millisecond = GetSlot(thisDt, ISO_MILLISECOND);\n        const microsecond = GetSlot(thisDt, ISO_MICROSECOND);\n        const nanosecond = GetSlot(thisDt, ISO_NANOSECOND);\n        calendar = ES.ConsolidateCalendars(GetSlot(this, CALENDAR), calendar);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    withPlainTime(temporalTimeParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const PlainTime = GetIntrinsic('%Temporal.PlainTime%');\n        const temporalTime = temporalTimeParam === undefined ? new PlainTime() : ES.ToTemporalTime(temporalTimeParam);\n        const thisDt = dateTime(this);\n        const year = GetSlot(thisDt, ISO_YEAR);\n        const month = GetSlot(thisDt, ISO_MONTH);\n        const day = GetSlot(thisDt, ISO_DAY);\n        const calendar = GetSlot(this, CALENDAR);\n        const hour = GetSlot(temporalTime, ISO_HOUR);\n        const minute = GetSlot(temporalTime, ISO_MINUTE);\n        const second = GetSlot(temporalTime, ISO_SECOND);\n        const millisecond = GetSlot(temporalTime, ISO_MILLISECOND);\n        const microsecond = GetSlot(temporalTime, ISO_MICROSECOND);\n        const nanosecond = GetSlot(temporalTime, ISO_NANOSECOND);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const PlainDateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const dt = new PlainDateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, calendar);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dt, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    withTimeZone(timeZoneParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const timeZone = ES.ToTemporalTimeZone(timeZoneParam);\n        return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), timeZone, GetSlot(this, CALENDAR));\n    }\n    withCalendar(calendarParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = ES.ToTemporalCalendar(calendarParam);\n        return ES.CreateTemporalZonedDateTime(GetSlot(this, EPOCHNANOSECONDS), GetSlot(this, TIME_ZONE), calendar);\n    }\n    add(temporalDurationLike, options = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.AddDurationToOrSubtractDurationFromZonedDateTime('add', this, temporalDurationLike, options);\n    }\n    subtract(temporalDurationLike, options = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.AddDurationToOrSubtractDurationFromZonedDateTime('subtract', this, temporalDurationLike, options);\n    }\n    until(other, options = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.DifferenceTemporalZonedDateTime('until', this, other, options);\n    }\n    since(other, options = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.DifferenceTemporalZonedDateTime('since', this, other, options);\n    }\n    round(optionsParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        if (optionsParam === undefined)\n            throw new TypeError('options parameter is required');\n        const options = typeof optionsParam === 'string'\n            ? ES.CreateOnePropObject('smallestUnit', optionsParam)\n            : ES.GetOptionsObject(optionsParam);\n        const smallestUnit = ES.GetTemporalUnit(options, 'smallestUnit', 'time', ES.REQUIRED, ['day']);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'halfExpand');\n        const maximumIncrements = {\n            day: 1,\n            hour: 24,\n            minute: 60,\n            second: 60,\n            millisecond: 1000,\n            microsecond: 1000,\n            nanosecond: 1000\n        };\n        const roundingIncrement = ES.ToTemporalRoundingIncrement(options, maximumIncrements[smallestUnit], false);\n        // first, round the underlying DateTime fields\n        const dt = dateTime(this);\n        let year = GetSlot(dt, ISO_YEAR);\n        let month = GetSlot(dt, ISO_MONTH);\n        let day = GetSlot(dt, ISO_DAY);\n        let hour = GetSlot(dt, ISO_HOUR);\n        let minute = GetSlot(dt, ISO_MINUTE);\n        let second = GetSlot(dt, ISO_SECOND);\n        let millisecond = GetSlot(dt, ISO_MILLISECOND);\n        let microsecond = GetSlot(dt, ISO_MICROSECOND);\n        let nanosecond = GetSlot(dt, ISO_NANOSECOND);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const calendar = GetSlot(this, CALENDAR);\n        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0);\n        const instantStart = ES.BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n        const endNs = ES.AddZonedDateTime(instantStart, timeZone, calendar, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0);\n        const dayLengthNs = JSBI.subtract(endNs, JSBI.BigInt(GetSlot(instantStart, EPOCHNANOSECONDS)));\n        if (JSBI.equal(dayLengthNs, ZERO)) {\n            throw new RangeError('cannot round a ZonedDateTime in a calendar with zero-length days');\n        }\n        ({ year, month, day, hour, minute, second, millisecond, microsecond, nanosecond } = ES.RoundISODateTime(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, roundingIncrement, smallestUnit, roundingMode, \n        // Days are guaranteed to be shorter than Number.MAX_SAFE_INTEGER\n        // (which can hold up to 104 days in nanoseconds)\n        JSBI.toNumber(dayLengthNs)));\n        // Now reset all DateTime fields but leave the TimeZone. The offset will\n        // also be retained if the new date/time values are still OK with the old\n        // offset. Otherwise the offset will be changed to be compatible with the\n        // new date/time values. If DST disambiguation is required, the `compatible`\n        // disambiguation algorithm will be used.\n        const offsetNs = ES.GetOffsetNanosecondsFor(timeZone, GetSlot(this, INSTANT));\n        const epochNanoseconds = ES.InterpretISODateTimeOffset(year, month, day, hour, minute, second, millisecond, microsecond, nanosecond, 'option', offsetNs, timeZone, 'compatible', 'prefer', \n        /* matchMinute = */ false);\n        return ES.CreateTemporalZonedDateTime(epochNanoseconds, timeZone, GetSlot(this, CALENDAR));\n    }\n    equals(otherParam) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const other = ES.ToTemporalZonedDateTime(otherParam);\n        const one = GetSlot(this, EPOCHNANOSECONDS);\n        const two = GetSlot(other, EPOCHNANOSECONDS);\n        if (!JSBI.equal(JSBI.BigInt(one), JSBI.BigInt(two)))\n            return false;\n        if (!ES.TimeZoneEquals(GetSlot(this, TIME_ZONE), GetSlot(other, TIME_ZONE)))\n            return false;\n        return ES.CalendarEquals(GetSlot(this, CALENDAR), GetSlot(other, CALENDAR));\n    }\n    toString(optionsParam = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const options = ES.GetOptionsObject(optionsParam);\n        const { precision, unit, increment } = ES.ToSecondsStringPrecision(options);\n        const roundingMode = ES.ToTemporalRoundingMode(options, 'trunc');\n        const showCalendar = ES.ToShowCalendarOption(options);\n        const showTimeZone = ES.ToShowTimeZoneNameOption(options);\n        const showOffset = ES.ToShowOffsetOption(options);\n        return ES.TemporalZonedDateTimeToString(this, precision, showCalendar, showTimeZone, showOffset, {\n            unit,\n            increment,\n            roundingMode\n        });\n    }\n    toLocaleString(locales = undefined, options = undefined) {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return new DateTimeFormat(locales, options).format(this);\n    }\n    toJSON() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalZonedDateTimeToString(this, 'auto');\n    }\n    valueOf() {\n        throw new TypeError('use compare() or equals() to compare Temporal.ZonedDateTime');\n    }\n    startOfDay() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const DateTime = GetIntrinsic('%Temporal.PlainDateTime%');\n        const calendar = GetSlot(this, CALENDAR);\n        const dtStart = new DateTime(GetSlot(dt, ISO_YEAR), GetSlot(dt, ISO_MONTH), GetSlot(dt, ISO_DAY), 0, 0, 0, 0, 0, 0, calendar);\n        const timeZone = GetSlot(this, TIME_ZONE);\n        const instant = ES.BuiltinTimeZoneGetInstantFor(timeZone, dtStart, 'compatible');\n        return ES.CreateTemporalZonedDateTime(GetSlot(instant, EPOCHNANOSECONDS), timeZone, calendar);\n    }\n    toInstant() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const TemporalInstant = GetIntrinsic('%Temporal.Instant%');\n        return new TemporalInstant(GetSlot(this, EPOCHNANOSECONDS));\n    }\n    toPlainDate() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToDate(dateTime(this));\n    }\n    toPlainTime() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return ES.TemporalDateTimeToTime(dateTime(this));\n    }\n    toPlainDateTime() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        return dateTime(this);\n    }\n    toPlainYearMonth() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['monthCode', 'year']);\n        const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n        return ES.CalendarYearMonthFromFields(calendar, fields);\n    }\n    toPlainMonthDay() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const calendar = GetSlot(this, CALENDAR);\n        const fieldNames = ES.CalendarFields(calendar, ['day', 'monthCode']);\n        const fields = ES.PrepareTemporalFields(this, fieldNames, []);\n        return ES.CalendarMonthDayFromFields(calendar, fields);\n    }\n    getISOFields() {\n        if (!ES.IsTemporalZonedDateTime(this))\n            throw new TypeError('invalid receiver');\n        const dt = dateTime(this);\n        const tz = GetSlot(this, TIME_ZONE);\n        return {\n            calendar: GetSlot(this, CALENDAR),\n            isoDay: GetSlot(dt, ISO_DAY),\n            isoHour: GetSlot(dt, ISO_HOUR),\n            isoMicrosecond: GetSlot(dt, ISO_MICROSECOND),\n            isoMillisecond: GetSlot(dt, ISO_MILLISECOND),\n            isoMinute: GetSlot(dt, ISO_MINUTE),\n            isoMonth: GetSlot(dt, ISO_MONTH),\n            isoNanosecond: GetSlot(dt, ISO_NANOSECOND),\n            isoSecond: GetSlot(dt, ISO_SECOND),\n            isoYear: GetSlot(dt, ISO_YEAR),\n            offset: ES.BuiltinTimeZoneGetOffsetStringFor(tz, GetSlot(this, INSTANT)),\n            timeZone: tz\n        };\n    }\n    static from(item, optionsParam = undefined) {\n        const options = ES.GetOptionsObject(optionsParam);\n        if (ES.IsTemporalZonedDateTime(item)) {\n            ES.ToTemporalOverflow(options); // validate and ignore\n            ES.ToTemporalDisambiguation(options);\n            ES.ToTemporalOffset(options, 'reject');\n            return ES.CreateTemporalZonedDateTime(GetSlot(item, EPOCHNANOSECONDS), GetSlot(item, TIME_ZONE), GetSlot(item, CALENDAR));\n        }\n        return ES.ToTemporalZonedDateTime(item, options);\n    }\n    static compare(oneParam, twoParam) {\n        const one = ES.ToTemporalZonedDateTime(oneParam);\n        const two = ES.ToTemporalZonedDateTime(twoParam);\n        const ns1 = GetSlot(one, EPOCHNANOSECONDS);\n        const ns2 = GetSlot(two, EPOCHNANOSECONDS);\n        if (JSBI.lessThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2)))\n            return -1;\n        if (JSBI.greaterThan(JSBI.BigInt(ns1), JSBI.BigInt(ns2)))\n            return 1;\n        return 0;\n    }\n}\nSymbol.toStringTag;\nMakeIntrinsicClass(ZonedDateTime, 'Temporal.ZonedDateTime');\nfunction dateTime(zdt) {\n    return ES.BuiltinTimeZoneGetPlainDateTimeFor(GetSlot(zdt, TIME_ZONE), GetSlot(zdt, INSTANT), GetSlot(zdt, CALENDAR));\n}\n//# sourceMappingURL=zoneddatetime.js.map","// This entry point treats Temporal as a library, and does not polyfill it onto\n// the global object.\n// This is in order to avoid breaking the web in the future, if the polyfill\n// gains wide adoption before the API is finalized. We do not want checks such\n// as `if (typeof Temporal === 'undefined')` in the wild, until browsers start\n// shipping the finalized API.\nimport * as Temporal from './temporal';\nimport * as Intl from './intl';\nimport { toTemporalInstant } from './legacydate';\n// Work around https://github.com/babel/babel/issues/2025.\nconst types = [\n    Temporal.Instant,\n    Temporal.Calendar,\n    Temporal.PlainDate,\n    Temporal.PlainDateTime,\n    Temporal.Duration,\n    Temporal.PlainMonthDay,\n    // Temporal.Now, // plain object (not a constructor), so no `prototype`\n    Temporal.PlainTime,\n    Temporal.TimeZone,\n    Temporal.PlainYearMonth,\n    Temporal.ZonedDateTime\n];\nfor (const type of types) {\n    const descriptor = Object.getOwnPropertyDescriptor(type, 'prototype');\n    if (descriptor.configurable || descriptor.enumerable || descriptor.writable) {\n        descriptor.configurable = false;\n        descriptor.enumerable = false;\n        descriptor.writable = false;\n        Object.defineProperty(type, 'prototype', descriptor);\n    }\n}\nexport { Temporal, Intl, toTemporalInstant };\n//# sourceMappingURL=index.js.map","import { Instant } from './instant';\nimport JSBI from 'jsbi';\nimport * as ES from './ecmascript';\nimport { MILLION } from './ecmascript';\nexport function toTemporalInstant() {\n    // Observable access to valueOf is not correct here, but unavoidable\n    const epochNanoseconds = JSBI.multiply(JSBI.BigInt(+this), MILLION);\n    return new Instant(ES.ToBigInt(epochNanoseconds));\n}\n//# sourceMappingURL=legacydate.js.map"],"names":["INTRINSICS","MakeIntrinsicClass","Class","name","Object","defineProperty","prototype","Symbol","toStringTag","value","writable","enumerable","configurable","prop","getOwnPropertyNames","desc","getOwnPropertyDescriptor","DefineIntrinsic","key","undefined","Error","GetIntrinsic","intrinsic","EPOCHNANOSECONDS","TIMEZONE_ID","ISO_YEAR","ISO_MONTH","ISO_DAY","ISO_HOUR","ISO_MINUTE","ISO_SECOND","ISO_MILLISECOND","ISO_MICROSECOND","ISO_NANOSECOND","CALENDAR","INSTANT","TIME_ZONE","YEARS","MONTHS","WEEKS","DAYS","HOURS","MINUTES","SECONDS","MILLISECONDS","MICROSECONDS","NANOSECONDS","CALENDAR_ID","slots","WeakMap","CreateSlots","container","set","create","GetSlots","get","HasSlot","ids","myslots","reduce","all","id","GetSlot","TypeError","SetSlot","tzComponent","timeZoneID","RegExp","source","calComponent","calendarID","yearpart","monthpart","daypart","datesplit","timesplit","offset","zonesplit","calendar","zoneddatetime","time","yearmonth","monthday","fraction","durationTime","duration","ArrayIncludes","Array","includes","ArrayPrototypePush","push","IntlDateTimeFormat","globalThis","Intl","DateTimeFormat","MathMin","Math","min","MathMax","max","MathAbs","abs","MathFloor","floor","MathSign","sign","MathTrunc","trunc","NumberIsNaN","Number","isNaN","NumberIsFinite","isFinite","NumberCtor","StringCtor","String","NumberMaxSafeInteger","MAX_SAFE_INTEGER","ObjectAssign","assign","ObjectCreate","ObjectGetOwnPropertyDescriptor","ObjectIs","is","ReflectApply","Reflect","apply","ZERO","JSBI","BigInt","ONE","SIXTY","THOUSAND","MILLION","BILLION","NEGATIVE_ONE","DAY_NANOS","multiply","NS_MIN","NS_MAX","BEFORE_FIRST_OFFSET_TRANSITION","ABOUT_TEN_YEARS_NANOS","ABOUT_ONE_YEAR_NANOS","TWO_WEEKS_NANOS","BUILTIN_CALENDAR_IDS","IsInteger","IsObject","ToNumber","ToInteger","num","integer","ToString","ToIntegerThrowOnInfinity","RangeError","ToPositiveInteger","valueParam","property","ToIntegerWithoutRounding","divmod","x","y","quotient","divide","remainder","lessThan","ArrayPush","arr","newItem","BUILTIN_CASTS","Map","BUILTIN_DEFAULTS","SINGULAR_PLURAL_UNITS","SINGULAR_FOR","map","e","PLURAL_FOR","p","s","UNITS_DESCENDING","DURATION_FIELDS","from","keys","sort","IntlDateTimeFormatEnUsCache","getIntlDateTimeFormatEnUsForTimeZone","timeZoneIdentifier","instance","timeZone","hour12","era","year","month","day","hour","minute","second","IsTemporalInstant","item","IsTemporalTimeZone","IsTemporalCalendar","IsTemporalDuration","IsTemporalDate","IsTemporalTime","IsTemporalDateTime","IsTemporalYearMonth","IsTemporalMonthDay","IsTemporalZonedDateTime","RejectObjectWithCalendarOrTimeZone","ParseTemporalTimeZone","stringIdent","ianaName","z","ParseTemporalTimeZoneString","canonicalIdent","GetCanonicalTimeZoneIdentifier","toString","result","ParseISODateTime","FormatCalendarAnnotation","showCalendar","isoString","match","PARSE.zoneddatetime","exec","yearString","slice","hasTime","millisecond","microsecond","nanosecond","offsetSign","offsetHours","offsetMinutes","offsetSeconds","offsetFraction","endsWith","RejectDateTime","ParseTemporalYearMonthString","PARSE.yearmonth","referenceISODay","ParseTemporalMonthDayString","PARSE.monthday","referenceISOYear","ParseTemporalDurationString","PARSE.duration","every","element","years","months","weeks","days","hours","fHours","minutes","fMinutes","seconds","fSeconds","milliseconds","microseconds","nanoseconds","length","DurationHandleFractions","fHoursParam","minutesParam","fMinutesParam","secondsParam","millisecondsParam","microsecondsParam","nanosecondsParam","forEach","val","mins","secs","mils","fMilliseconds","mics","fMicroseconds","RejectDuration","ParseTemporalInstant","ParseTemporalInstantString","offsetNs","ParseTimeZoneOffsetString","BalanceISODateTime","epochNs","GetEpochFromISOParts","RegulateISODate","yearParam","monthParam","dayParam","overflow","RejectISODate","ConstrainISODate","RegulateTime","hourParam","minuteParam","secondParam","millisecondParam","microsecondParam","nanosecondParam","RejectTime","ConstrainTime","ConstrainToRange","ToTemporalDurationRecord","partial","ToTemporalPartialDurationRecord","temporalDurationLike","any","ToTemporalOverflow","options","GetOption","ToTemporalDisambiguation","ToTemporalRoundingMode","fallback","NegateTemporalRoundingMode","roundingMode","ToTemporalOffset","ToShowCalendarOption","ToTemporalRoundingIncrement","dividend","inclusive","maximum","Infinity","increment","GetNumberOption","minimum","valueRaw","ToTemporalDateTimeRoundingIncrement","smallestUnit","week","ToSecondsStringPrecision","GetTemporalUnit","ALLOWED_UNITS","allowed","c","join","precision","unit","digits","fractionalSecondDigits","stringDigits","REQUIRED","unitGroup","requiredOrDefault","extraValues","allowedSingular","singular","category","defaultVal","allowedValues","plural","retval","has","ToRelativeTemporalObject","relativeTo","offsetBehaviour","matchMinutes","TemporalDateTimeToDate","GetTemporalCalendarWithISODefault","fields","PrepareTemporalFields","CalendarFields","dateOptions","InterpretTemporalDateTimeFields","GetISO8601Calendar","ToTemporalCalendar","ToTemporalTimeZone","CreateTemporalZonedDateTime","InterpretISODateTimeOffset","CreateTemporalDate","DefaultTemporalLargestUnit","v","LargerOfTwoTemporalUnits","unit1","unit2","indexOf","MergeLargestUnitOption","optionsParam","largestUnit","bag","requiredFields","emptySourceErrorMessage","call","eraYear","ToTemporalTimeRecord","completeness","field","valueDesc","ToTemporalDate","itemParam","BuiltinTimeZoneGetPlainDateTimeFor","CalendarDateFromFields","ParseTemporalDateString","date","ToTemporalDateTime","CreateTemporalDateTime","ParseTemporalDateTimeString","ToTemporalDuration","ToTemporalInstant","ns","ToTemporalMonthDay","calendarAbsent","maybeStringCalendar","monthCode","CalendarMonthDayFromFields","CreateTemporalMonthDay","ToTemporalTime","ParseTemporalTimeString","PARSE.time","test","ToTemporalYearMonth","CalendarYearMonthFromFields","CreateTemporalYearMonth","disambiguation","offsetOpt","matchMinute","dt","BuiltinTimeZoneGetInstantFor","subtract","possibleInstants","GetPossibleInstantsFor","candidate","candidateOffset","GetOffsetNanosecondsFor","roundedCandidateOffset","toNumber","RoundNumberToIncrement","offsetStr","FormatTimeZoneOffsetString","timeZoneString","DisambiguatePossibleInstants","ToTemporalZonedDateTime","ParseTemporalZonedDateTimeString","CreateTemporalDateSlots","isoYear","isoMonth","isoDay","RejectDateRange","TemporalPlainDate","CreateTemporalDateTimeSlots","h","ms","RejectDateTimeRange","TemporalPlainDateTime","CreateTemporalMonthDaySlots","TemporalPlainMonthDay","CreateTemporalYearMonthSlots","RejectYearMonthRange","RejectToRange","TemporalPlainYearMonth","CreateTemporalZonedDateTimeSlots","epochNanoseconds","ValidateEpochNanoseconds","instant","TemporalZonedDateTime","fieldNamesParam","fieldNames","CalendarMergeFields","additionalFields","calMergeFields","mergeFields","CalendarDateAdd","dateAddParam","dateAdd","CalendarDateUntil","otherDate","dateUntilParam","dateUntil","CalendarYear","dateLike","CalendarMonth","CalendarMonthCode","CalendarDay","CalendarEra","CalendarEraYear","CalendarDayOfWeek","dayOfWeek","CalendarDayOfYear","dayOfYear","CalendarWeekOfYear","weekOfYear","CalendarDaysInWeek","daysInWeek","CalendarDaysInMonth","daysInMonth","CalendarDaysInYear","daysInYear","CalendarMonthsInYear","monthsInYear","CalendarInLeapYear","inLeapYear","calendarLikeParam","calendarLike","identifier","TemporalCalendar","IsBuiltinCalendar","CalendarEquals","one","two","ConsolidateCalendars","sOne","sTwo","dateFromFields","yearMonthFromFields","monthDayFromFields","temporalTimeZoneLikeParam","temporalTimeZoneLike","TimeZoneEquals","dateTime","TemporalDateTimeToTime","getOffsetNanosecondsFor","BuiltinTimeZoneGetOffsetStringFor","GetISOPartsFromEpoch","Instant","numInstants","utcns","dayBefore","dayAfter","add","offsetBefore","PlainDateTime","earlier","AddDateTime","later","possible","getPossibleInstantsFor","ISOYearString","ISODateTimePartString","part","FormatSecondsStringPart","fractionNumber","padStart","TemporalInstantToString","outputTimeZone","FormatISOTimeZoneOffsetString","TemporalDurationToString","formatNumber","DurationSign","RoundDuration","dateParts","timeParts","secondParts","nsBigInt","msBigInt","secondsBigInt","total","TotalDurationNanoseconds","decimalPart","unshift","equal","TemporalDateToString","TemporalDateTimeToString","RoundISODateTime","TemporalMonthDayToString","monthDay","resultString","calendarString","TemporalYearMonthToString","yearMonth","TemporalZonedDateTimeToString","zdt","showTimeZone","showOffset","RoundInstant","tz","TestTimeZoneOffsetString","string","OFFSET","resolvedOptions","GetIANATimeZoneOffsetNanoseconds","GetIANATimeZoneDateTimeParts","utc","offsetNanosecondsParam","offsetNanoseconds","hourString","minuteString","secondString","post","legacyDate","Date","setUTCHours","setUTCFullYear","getTime","greaterThan","epochMilliseconds","nanos","getUTCFullYear","getUTCMonth","getUTCDate","getUTCHours","getUTCMinutes","getUTCSeconds","getUTCMilliseconds","GetFormatterParts","formatter","parseFromEnUsFormat","datetime","parts","split","toUpperCase","format","maxJSBI","afterLatestPossibleTzdbRuleChange","SystemUTCEpochNanoSeconds","GetIANATimeZonePreviousTransition","afterLatestRule","isFarFuture","lowercap","rightNanos","rightOffsetNs","leftNanos","leftOffsetNs","bisect","LeapYear","ISODaysInMonth","standard","leapyear","DayOfWeek","m","Y","dow","DayOfYear","mon","w","d","BalanceISOYearMonth","BalanceISODate","testYear","deltaDays","BalanceTime","NonNegativeModulo","daysParam","hoursParam","offsetShift","NanosecondsToDays","TemporalInstant","dayLengthNs","startNs","start","endNs","end","dtStart","dtEnd","DifferenceISODateTime","intermediateNs","AddZonedDateTime","isOverflow","relativeInstant","oneDayFartherNs","relativeNs","BalanceDuration","nanosecondsBigInt","microsecondsBigInt","millisecondsBigInt","minutesBigInt","hoursBigInt","UnbalanceDurationRelative","yearsParam","monthsParam","weeksParam","relativeToParam","TemporalDuration","oneYear","oneMonth","oneWeek","relativeToDateOnly","newRelativeTo","untilOptions","oneYearMonths","oneYearDays","MoveRelativeDate","oneMonthDays","oneWeekDays","CalculateOffsetShift","after","CreateNegatedTemporalDuration","propSign","DifferenceISODate","y1","m1","d1","y2","m2","d2","CompareISODate","mid","AddISODate","midSign","larger","smaller","DifferenceTime","h1","min1","s1","ms1","ns1","h2","min2","s2","ms2","ns2","DifferenceInstant","diff","wholeDays","roundedRemainder","nsPerTimeUnit","roundedDiff","y1Param","mon1Param","d1Param","mon2","mon1","timeSign","date1","date2","DifferenceZonedDateTime","nsDiff","timeRemainderNs","intermediate","DifferenceTemporalInstant","operation","otherParam","other","first","GetOptionsObject","defaultLargestUnit","roundingIncrement","onens","twons","DifferenceTemporalPlainDate","plainDate","otherCalendar","calendarId","otherCalendarId","DifferenceTemporalPlainDateTime","plainDateTime","DifferenceTemporalPlainTime","plainTime","DifferenceTemporalPlainYearMonth","otherCalendarID","otherFields","thisFields","thisDate","DifferenceTemporalZonedDateTime","zonedDateTime","AdjustRoundedDurationDays","AddTime","AddDuration","w1","w2","dateDuration1","dateDuration2","dateLargestUnit","differenceOptions","AddInstant","sum","addedDate","dtIntermediate","AddDurationToOrSubtractDurationFromDuration","AddDurationToOrSubtractDurationFromInstant","durationLike","ToLimitedTemporalDuration","disallowedProperties","record","AddDurationToOrSubtractDurationFromPlainDateTime","AddDurationToOrSubtractDurationFromPlainTime","temporalTime","AddDurationToOrSubtractDurationFromPlainYearMonth","startDate","durationToAdd","optionsCopy","AddDurationToOrSubtractDurationFromZonedDateTime","quantity","mode","RoundTime","nsPerUnit","rounded","DaysUntil","MoveRelativeZonedDateTime","direction","dayStart","dayEnd","greaterThanOrEqual","zdtRelative","dayLength","yearsDuration","yearsLater","yearsMonthsWeeksLater","daysLater","yearsPassed","oldRelativeTo","divisor","yearsMonths","yearsMonthsLater","allNanoseconds","ComparisonResult","ToBigIntExternal","arg","jsbiBI","ToBigInt","prim","toPrimFn","toPrimitive","SyntaxError","message","startsWith","now","CreateOnePropObject","propName","propValue","o","PARSE.offset","getState","leftParam","rightParam","lstateParam","rstateParam","left","right","lstate","rstate","middle","mstate","DATE","YM","MD","TIME","DATETIME","ZONED","INST","ORIGINAL","TZ_RESOLVED","TZ_GIVEN","CAL_ID","LOCALE","OPTIONS","descriptor","ObjectHasOwnProperty","hasOwnProperty","getPropLazy","obj","getResolvedTimeZoneLazy","ES.ToTemporalTimeZone","DateTimeFormatImpl","locale","this","hasOptions","original","ro","clonedResolved","dateAmend","yearMonthAmend","monthDayAmend","timeAmend","datetimeAmend","zonedDateTimeAmend","instantAmend","supportedLocalesOf","locales","propertyDescriptors","rest","extractOverrides","adjustFormatterTimeZone","formatRange","a","b","isTemporalObject","sameTemporalType","aa","aformatter","atz","bb","bformatter","btz","formatToParts","formatRangeToParts","amend","amended","opt","weekday","timeZoneName","dateStyle","hasTimeOptions","dayPeriod","timeStyle","hasDateOptions","ES.IsTemporalDate","ES.IsTemporalTime","ES.IsTemporalDateTime","ES.IsTemporalZonedDateTime","ES.IsTemporalYearMonth","ES.IsTemporalMonthDay","ES.IsTemporalInstant","temporalObj","main","DateTime","ES.BuiltinTimeZoneGetInstantFor","ES.ToString","objTimeZone","constructor","arguments","ES.ToBigInt","ES.ValidateEpochNanoseconds","epochSeconds","epochMicroseconds","ES.ToBigIntExternal","ES.AddDurationToOrSubtractDurationFromInstant","until","ES.DifferenceTemporalInstant","since","round","ES.CreateOnePropObject","ES.GetOptionsObject","ES.GetTemporalUnit","ES.REQUIRED","ES.ToTemporalRoundingMode","ES.ToTemporalRoundingIncrement","roundedNs","ES.RoundInstant","equals","ES.ToTemporalInstant","ES.ToSecondsStringPrecision","ES.TemporalInstantToString","toJSON","toLocaleString","valueOf","toZonedDateTime","ES.IsObject","ES.ToTemporalCalendar","ES.CreateTemporalZonedDateTime","toZonedDateTimeISO","timeZoneProperty","ES.GetISO8601Calendar","fromEpochSeconds","epochSecondsParam","ES.ToNumber","fromEpochMilliseconds","epochMillisecondsParam","fromEpochMicroseconds","epochMicrosecondsParam","fromEpochNanoseconds","epochNanosecondsParam","compare","oneParam","twoParam","oneNs","twoNs","ArraySort","ObjectEntries","entries","ObjectKeys","impl","Calendar","idParam","ES.IsBuiltinCalendar","ES.IsTemporalCalendar","fieldsArray","Set","delete","dateParam","durationParam","ES.ToTemporalDate","ES.ToTemporalDuration","ES.ToTemporalOverflow","ES.BalanceDuration","monthCodeNumberPart","buildMonthCode","leap","resolveNonLunisolarMonth","calendarDate","monthsPerYear","ES.RejectToRange","ES.ConstrainToRange","numberPart","fieldsParam","ES.PrepareTemporalFields","ES.RegulateISODate","ES.CreateTemporalDate","RegulateISOYearMonth","ES.RegulateISOYearMonth","ES.CreateTemporalYearMonth","useYear","ES.CreateTemporalMonthDay","merged","nextKey","newKeys","ES.AddISODate","ES.DifferenceISODate","ES.DayOfWeek","ES.DayOfYear","WeekOfYear","doy","doj","ES.WeekOfYear","ES.ISODaysInMonth","ES.LeapYear","OneObjectCache","cacheToClone","calls","hits","misses","performance","i","entry","MAX_CACHE_ENTRIES","report","setObject","objectMap","getCacheForObject","cache","toUtcIsoDateString","ES.ISOYearString","ES.ISODateTimePartString","simpleDateDiff","HelperBase","eraLength","hasEra","getFormatter","isoToCalendarDate","isoDate","JSON","stringify","func","cached","dateTimeFormat","type","matches","monthExtra","normalize","replace","toLowerCase","reviseIntlEra","checkIcuBugs","adjustCalendarDate","keyReverse","validateCalendarDate","constantEra","calendarDateParam","fromLegacyDate","calendarType","largestMonth","regulateMonthDayNaive","maximumMonthLength","calendarToIsoDate","originalDate","keyOriginal","isoEstimate","estimateIsoDate","calculateSameMonthResult","diffDays","testIsoEstimate","addDaysIso","minimumMonthLength","testCalendarDate","roundtripEstimate","diffTotalDaysEstimate","compareCalendarDates","maybeConstrained","oldRoundtripEstimate","oldSign","temporalToCalendarDate","date1Param","date2Param","ES.ComparisonResult","regulateDate","addDaysCalendar","addedIso","addMonthsCalendar","absMonths","oldCalendarDate","daysInPreviousMonth","monthsInOldYear","addCalendar","addedYears","addedMonths","initialDays","untilCalendar","calendarOne","calendarTwo","calendarDaysUntil","totalDays","diffYears","diffMonths","current","next","addedIsoDate","addedCalendarDate","endOfMonthIso","previousMonthDate","previousMonth","lastDayOfPreviousMonthIso","startOfCalendarYear","startOfCalendarMonth","oneIso","twoIso","isoDaysUntil","closestCalendar","closestIso","calendarYear","roundTripCalendarDate","HebrewHelper","super","Tishri","regular","Heshvan","Kislev","Tevet","Shevat","Adar","Nisan","Iyar","Sivan","Tamuz","Av","Elul","minMaxMonthLength","minOrMax","getMonthCode","monthInfo","find","IslamicBaseHelper","DAYS_PER_ISLAMIC_YEAR","DAYS_PER_ISO_YEAR","IslamicHelper","IslamicUmalquraHelper","IslamicTblaHelper","IslamicCivilHelper","IslamicRgsaHelper","IslamicCcHelper","PersianHelper","IndianHelper","nextYear","vulnerableToBceBug","toLocaleDateString","isGregorianLeapYear","getMonthInfo","GregorianBaseHelper","originalEras","v8IsVulnerableToJulianBug","calendarIsVulnerableToJulianBug","eras","anchorEra","adjustEras","erasParam","reverseOf","filter","isAnchor","anchorEpoch","hasYearZero","reversedEra","isoEpoch","e1","e2","lastEraReversed","genericName","completeEraYear","checkField","currentValue","eraFromYear","adjustedCalendarDate","matchingEra","ES.CompareISODate","OrthodoxBaseHelper","EthioaaHelper","CopticHelper","EthiopicHelper","RocHelper","BuddhistHelper","GregoryHelper","JapaneseHelper","ChineseBaseHelper","getMonthList","getCalendarDate","daysPastFeb1","isoStringFeb1","setUTCDate","newYearGuess","calendarMonthString","tv","calendarDay","calendarYearToVerify","isoDaysDelta","oldCalendarDay","oldMonthString","monthIndex","done","monthString","withoutML","monthEntries","matchingMonthEntry","ChineseHelper","DangiHelper","nonIsoImpl","helper","fieldsCopy","additionalFieldsCopy","newMonth","newMonthCode","newYear","newEra","newEraYear","added","isoAdded","newTemporalObject","cacheOne","cacheTwo","startOfYear","startOfMonthCalendar","startOfNextMonthCalendar","startOfYearCalendar","startOfNextYearCalendar","Helper","PlainDate","isoYearParam","isoMonthParam","isoDayParam","calendarParam","ES.ToIntegerThrowOnInfinity","ES.CreateTemporalDateSlots","ES.CalendarEra","ES.CalendarEraYear","ES.CalendarYear","ES.CalendarMonth","ES.CalendarMonthCode","ES.CalendarDay","ES.CalendarDayOfWeek","ES.CalendarDayOfYear","ES.CalendarWeekOfYear","ES.CalendarDaysInWeek","ES.CalendarDaysInMonth","ES.CalendarDaysInYear","ES.CalendarMonthsInYear","ES.CalendarInLeapYear","with","temporalDateLike","ES.RejectObjectWithCalendarOrTimeZone","ES.CalendarFields","props","ES.CalendarMergeFields","ES.CalendarDateFromFields","withCalendar","ES.CalendarDateAdd","ES.CreateNegatedTemporalDuration","ES.DifferenceTemporalPlainDate","slot","ES.CalendarEquals","ES.TemporalDateToString","ES.ToShowCalendarOption","toPlainDateTime","temporalTimeParam","ES.CreateTemporalDateTime","ES.ToTemporalTime","timeZoneLike","toPlainYearMonth","ES.CalendarYearMonthFromFields","toPlainMonthDay","ES.CalendarMonthDayFromFields","getISOFields","ES.CreateTemporalDateTimeSlots","temporalDateTimeLike","ES.InterpretTemporalDateTimeFields","withPlainTime","withPlainDate","temporalDateParam","temporalDate","ES.ConsolidateCalendars","ES.AddDurationToOrSubtractDurationFromPlainDateTime","ES.DifferenceTemporalPlainDateTime","ES.RoundISODateTime","ES.ToTemporalDateTime","ES.TemporalDateTimeToString","ES.ToTemporalDisambiguation","toPlainDate","ES.TemporalDateTimeToDate","toPlainTime","ES.TemporalDateTimeToTime","isoHour","isoMicrosecond","isoMillisecond","isoMinute","isoNanosecond","isoSecond","val1","val2","Duration","ES.ToIntegerWithoutRounding","ES.RejectDuration","ES.IsTemporalDuration","ES.DurationSign","blank","negated","ES.AddDurationToOrSubtractDurationFromDuration","ES.DefaultTemporalLargestUnit","smallestUnitPresent","ES.LargerOfTwoTemporalUnits","largestUnitPresent","ES.ToTemporalDateTimeRoundingIncrement","ES.ToRelativeTemporalObject","ES.UnbalanceDurationRelative","ES.RoundDuration","ES.AdjustRoundedDurationDays","BalanceDurationRelative","untilResult","ES.BalanceDurationRelative","ES.MoveRelativeZonedDateTime","ES.TemporalDurationToString","DurationFormat","console","warn","shift1","ES.CalculateOffsetShift","shift2","totalNs1","ES.TotalDurationNanoseconds","totalNs2","PlainMonthDay","referenceISOYearParam","ES.CreateTemporalMonthDaySlots","temporalMonthDayLike","ES.ToTemporalMonthDay","ES.TemporalMonthDayToString","receiverFieldNames","inputFieldNames","mergedFields","ES.SystemUTCEpochNanoSeconds","tZ","ES.BuiltinTimeZoneGetPlainDateTimeFor","plainDateTimeISO","SystemTimeZone","fmt","ES.SystemTimeZone","Now","plainDateISO","plainTimeISO","zonedDateTimeISO","TemporalTimeToString","ES.RoundTime","ES.FormatSecondsStringPart","PlainTime","isoHourParam","isoMinuteParam","isoSecondParam","isoMillisecondParam","isoMicrosecondParam","isoNanosecondParam","ES.RejectTime","temporalTimeLike","partialTime","ES.ToTemporalTimeRecord","ES.RegulateTime","ES.AddDurationToOrSubtractDurationFromPlainTime","ES.DifferenceTemporalPlainTime","TimeZone","timeZoneIdentifierParam","ES.GetCanonicalTimeZoneIdentifier","ES.IsTemporalTimeZone","instantParam","ES.TestTimeZoneOffsetString","ES.ParseTimeZoneOffsetString","ES.GetIANATimeZoneOffsetNanoseconds","getOffsetStringFor","ES.BuiltinTimeZoneGetOffsetStringFor","getPlainDateTimeFor","getInstantFor","dateTimeParam","ES.GetEpochFromISOParts","GetIANATimeZoneEpochValue","nsEarlier","nsLater","earliest","latest","ES.GetIANATimeZoneEpochValue","getNextTransition","startingPointParam","startingPoint","GetIANATimeZoneNextTransition","oneYearLater","uppercap","ES.GetIANATimeZoneNextTransition","getPreviousTransition","ES.GetIANATimeZonePreviousTransition","PlainYearMonth","referenceISODayParam","ES.CreateTemporalYearMonthSlots","temporalYearMonthLike","ES.AddDurationToOrSubtractDurationFromPlainYearMonth","ES.DifferenceTemporalPlainYearMonth","ES.ToTemporalYearMonth","ES.TemporalYearMonthToString","ZonedDateTime","timeZoneParam","ES.CreateTemporalZonedDateTimeSlots","hoursInDay","today","tomorrowFields","tomorrow","todayNs","tomorrowNs","ES.GetOffsetNanosecondsFor","temporalZonedDateTimeLike","ES.ToTemporalOffset","fieldsWithOffset","ES.ArrayPush","fieldsWithTimeZoneAndOffset","ES.InterpretISODateTimeOffset","thisDt","withTimeZone","ES.AddDurationToOrSubtractDurationFromZonedDateTime","ES.DifferenceTemporalZonedDateTime","instantStart","ES.AddZonedDateTime","ES.ToTemporalZonedDateTime","ES.TimeZoneEquals","ES.TemporalZonedDateTimeToString","ToShowTimeZoneNameOption","ES.ToShowTimeZoneNameOption","ToShowOffsetOption","ES.ToShowOffsetOption","startOfDay","toInstant","types","Temporal.Instant","Temporal.Calendar","Temporal.PlainDate","Temporal.PlainDateTime","Temporal.Duration","Temporal.PlainMonthDay","Temporal.PlainTime","Temporal.TimeZone","Temporal.PlainYearMonth","Temporal.ZonedDateTime","toTemporalInstant"],"mappings":"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"}